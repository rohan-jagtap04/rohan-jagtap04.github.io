{"version":3,"file":"index.es.js","sources":["../src/__internal__/with-meta.ts","../src/mark/strike-through.ts","../src/node/table/utils.ts","../src/node/table/index.ts","../src/node/footnote/definition.ts","../src/node/footnote/reference.ts","../src/node/task-list-item.ts","../src/composed/keymap.ts","../src/composed/inputrules.ts","../src/plugin/auto-insert-zero-space-plugin.ts","../src/plugin/column-resizing-plugin.ts","../src/plugin/table-editing-plugin.ts","../src/plugin/remark-gfm-plugin.ts","../src/composed/plugins.ts","../src/composed/schema.ts","../src/composed/commands.ts","../src/index.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nimport type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport const withMeta = <T extends MilkdownPlugin>(\n  plugin: T,\n  meta: Partial<Meta> & Pick<Meta, 'displayName'>,\n): T => {\n  Object.assign(plugin, {\n    meta: {\n      package: '@milkdown/preset-gfm',\n      ...meta,\n    },\n  })\n\n  return plugin\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { commandsCtx } from '@milkdown/core'\nimport { $command, $markAttr, $markSchema, $useKeymap } from '@milkdown/utils'\nimport { toggleMarkdownMark } from '@milkdown/prose'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the strikethrough mark.\nexport const strikethroughAttr = $markAttr('strike_through')\n\nwithMeta(strikethroughAttr, {\n  displayName: 'Attr<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Strikethrough mark schema.\nexport const strikethroughSchema = $markSchema('strike_through', ctx => ({\n  parseDOM: [\n    { tag: 'del' },\n    { style: 'text-decoration', getAttrs: value => (value === 'line-through') as false },\n  ],\n  toDOM: mark => ['del', ctx.get(strikethroughAttr.key)(mark)],\n  parseMarkdown: {\n    match: node => node.type === 'delete',\n    runner: (state, node, markType) => {\n      state.openMark(markType)\n      state.next(node.children)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: mark => mark.type.name === 'strike_through',\n    runner: (state, mark) => {\n      state.withMark(mark, 'delete')\n    },\n  },\n}))\n\nwithMeta(strikethroughSchema.mark, {\n  displayName: 'MarkSchema<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughSchema.ctx, {\n  displayName: 'MarkSchemaCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// A command to toggle the strikethrough mark.\nexport const toggleStrikethroughCommand = $command('ToggleStrikeThrough', () => () => {\n  const markType = strikethroughSchema.type()\n  const mark = '~~'\n  return toggleMarkdownMark(markType, mark)\n})\n\nwithMeta(toggleStrikethroughCommand, {\n  displayName: 'Command<ToggleStrikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Keymap for the strikethrough mark.\n/// - `Mod-Alt-x` - Toggle the strikethrough mark.\nexport const strikethroughKeymap = $useKeymap('strikeThroughKeymap', {\n  ToggleStrikethrough: {\n    shortcuts: 'Mod-Alt-x',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(toggleStrikethroughCommand.key)\n    },\n  },\n})\n\nwithMeta(strikethroughKeymap.ctx, {\n  displayName: 'KeymapCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughKeymap.shortcuts, {\n  displayName: 'Keymap<strikethrough>',\n  group: 'Strikethrough',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { ContentNodeWithPos } from '@milkdown/prose'\nimport { cloneTr, findParentNode } from '@milkdown/prose'\nimport type { Node } from '@milkdown/prose/model'\nimport type { Selection, Transaction } from '@milkdown/prose/state'\nimport type { TableRect } from '@milkdown/prose/tables'\nimport { CellSelection, TableMap } from '@milkdown/prose/tables'\n\nimport { tableCellSchema, tableHeaderSchema, tableRowSchema, tableSchema } from '.'\n\n/// @internal\nexport interface CellPos {\n  pos: number\n  start: number\n  node: Node\n}\n\n/// @internal\nexport const createTable = (rowsCount = 3, colsCount = 3): Node => {\n  const cells = Array(colsCount)\n    .fill(0)\n    .map(() => tableCellSchema.type().createAndFill()!)\n\n  const headerCells = Array(colsCount)\n    .fill(0)\n    .map(() => tableHeaderSchema.type().createAndFill()!)\n\n  const rows = Array(rowsCount)\n    .fill(0)\n    .map((_, i) => tableRowSchema.type().create(null, i === 0 ? headerCells : cells))\n\n  return tableSchema.type().create(null, rows)\n}\n\n/// Find the table node with position information for current selection.\nexport const findTable = (selection: Selection) =>\n  findParentNode(node => node.type.spec.tableRole === 'table')(selection)\n\n/// Get cells in a column of a table.\nexport const getCellsInCol = (columnIndex: number, selection: Selection): CellPos[] | undefined => {\n  const table = findTable(selection)\n  if (!table)\n    return undefined\n  const map = TableMap.get(table.node)\n  if (columnIndex < 0 || columnIndex >= map.width)\n    return undefined\n\n  return map\n    .cellsInRect({ left: columnIndex, right: columnIndex + 1, top: 0, bottom: map.height })\n    .map((pos) => {\n      const node = table.node.nodeAt(pos)\n      if (!node)\n        return undefined\n      const start = pos + table.start\n      return {\n        pos: start,\n        start: start + 1,\n        node,\n      }\n    })\n    .filter((x): x is CellPos => x != null)\n}\n\n/// Get cells in a row of a table.\nexport const getCellsInRow = (rowIndex: number, selection: Selection): CellPos[] | undefined => {\n  const table = findTable(selection)\n  if (!table)\n    return undefined\n  const map = TableMap.get(table.node)\n  if (rowIndex < 0 || rowIndex >= map.height)\n    return undefined\n\n  return map\n    .cellsInRect({ left: 0, right: map.width, top: rowIndex, bottom: rowIndex + 1 })\n    .map((pos) => {\n      const node = table.node.nodeAt(pos)\n      if (!node)\n        return undefined\n      const start = pos + table.start\n      return {\n        pos: start,\n        start: start + 1,\n        node,\n      }\n    })\n    .filter((x): x is CellPos => x != null)\n}\n\n/// Get all cells in a table.\nexport const getAllCellsInTable = (selection: Selection) => {\n  const table = findTable(selection)\n  if (!table)\n    return\n\n  const map = TableMap.get(table.node)\n  const cells = map.cellsInRect({\n    left: 0,\n    right: map.width,\n    top: 0,\n    bottom: map.height,\n  })\n  return cells.map((nodePos) => {\n    const node = table.node.nodeAt(nodePos)\n    const pos = nodePos + table.start\n    return { pos, start: pos + 1, node }\n  })\n}\n\n/// Select a possible table in current selection.\nexport const selectTable = (tr: Transaction) => {\n  const cells = getAllCellsInTable(tr.selection)\n  if (cells && cells[0]) {\n    const $firstCell = tr.doc.resolve(cells[0].pos)\n    const last = cells[cells.length - 1]\n    if (last) {\n      const $lastCell = tr.doc.resolve(last.pos)\n      return cloneTr(tr.setSelection(new CellSelection($lastCell, $firstCell)))\n    }\n  }\n  return tr\n}\n\n/// @internal\nexport function addRowWithAlignment(tr: Transaction, { map, tableStart, table }: TableRect, row: number) {\n  const rowPos = Array(row)\n    .fill(0)\n    .reduce((acc, _, i) => {\n      return acc + table.child(i).nodeSize\n    }, tableStart)\n\n  const cells = Array(map.width)\n    .fill(0)\n    .map((_, col) => {\n      const headerCol = table.nodeAt(map.map[col] as number)\n      return tableCellSchema.type().createAndFill({ alignment: headerCol?.attrs.alignment }) as Node\n    })\n\n  tr.insert(rowPos, tableRowSchema.type().create(null, cells))\n  return tr\n}\n\n/// @internal\nexport const selectLine = (type: 'row' | 'col') => (index: number) => (tr: Transaction) => {\n  const table = findTable(tr.selection)\n  const isRowSelection = type === 'row'\n  if (table) {\n    const map = TableMap.get(table.node)\n\n    // Check if the index is valid\n    if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {\n      const lastCell = map.positionAt(\n        isRowSelection ? index : map.height - 1,\n        isRowSelection ? map.width - 1 : index,\n        table.node,\n      )\n      const $lastCell = tr.doc.resolve(table.start + lastCell)\n\n      const createCellSelection = isRowSelection ? CellSelection.rowSelection : CellSelection.colSelection\n\n      const firstCell = map.positionAt(isRowSelection ? index : 0, isRowSelection ? 0 : index, table.node)\n      const $firstCell = tr.doc.resolve(table.start + firstCell)\n      return cloneTr(tr.setSelection(createCellSelection($lastCell, $firstCell) as unknown as Selection))\n    }\n  }\n  return tr\n}\n\n/// If the selection is in a table,\n/// select the {index} row.\nexport const selectRow = selectLine('row')\n\n/// If the selection is in a table,\n/// select the {index} column.\nexport const selectCol = selectLine('col')\n\nconst transpose = <T>(array: T[][]) => {\n  return array[0]!.map((_, i) => {\n    return array.map(column => column[i])\n  }) as T[][]\n}\n\nconst convertArrayOfRowsToTableNode = (tableNode: Node, arrayOfNodes: (Node | null)[][]) => {\n  const rowsPM = []\n  const map = TableMap.get(tableNode)\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const row = tableNode.child(rowIndex)\n    const rowCells = []\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      if (!arrayOfNodes[rowIndex]![colIndex])\n        continue\n\n      const cellPos = map.map[rowIndex * map.width + colIndex]!\n\n      const cell = arrayOfNodes[rowIndex]![colIndex]!\n      const oldCell = tableNode.nodeAt(cellPos)!\n      const newCell = oldCell.type.createChecked(\n        Object.assign({}, cell.attrs),\n        cell.content,\n        cell.marks,\n      )\n      rowCells.push(newCell)\n    }\n\n    rowsPM.push(row.type.createChecked(row.attrs, rowCells, row.marks))\n  }\n\n  const newTable = tableNode.type.createChecked(\n    tableNode.attrs,\n    rowsPM,\n    tableNode.marks,\n  )\n\n  return newTable\n}\n\nconst convertTableNodeToArrayOfRows = (tableNode: Node) => {\n  const map = TableMap.get(tableNode)\n  const rows: (Node | null)[][] = []\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const rowCells: (Node | null)[] = []\n    const seen: Record<number, boolean> = {}\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      const cellPos = map.map[rowIndex * map.width + colIndex]!\n      const cell = tableNode.nodeAt(cellPos)\n      const rect = map.findCell(cellPos)\n      if (seen[cellPos] || rect.top !== rowIndex) {\n        rowCells.push(null)\n        continue\n      }\n      seen[cellPos] = true\n\n      rowCells.push(cell)\n    }\n\n    rows.push(rowCells)\n  }\n\n  return rows\n}\n\nconst moveRowInArrayOfRows = (\n  rows: (Node | null)[][],\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  directionOverride: -1 | 1 | 0,\n) => {\n  const direction = indexesOrigin[0]! > indexesTarget[0]! ? -1 : 1\n\n  const rowsExtracted = rows.splice(indexesOrigin[0]!, indexesOrigin.length)\n  const positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0\n  let target: number\n\n  if (directionOverride === -1 && direction === 1) {\n    target = indexesTarget[0]! - 1\n  }\n  else if (directionOverride === 1 && direction === -1) {\n    target = indexesTarget[indexesTarget.length - 1]! - positionOffset + 1\n  }\n  else {\n    target\n      = direction === -1\n        ? indexesTarget[0]!\n        : indexesTarget[indexesTarget.length - 1]! - positionOffset\n  }\n\n  rows.splice(target, 0, ...rowsExtracted)\n  return rows\n}\n\nconst moveTableColumn = (\n  table: ContentNodeWithPos,\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  direction: -1 | 1 | 0,\n) => {\n  let rows = transpose(convertTableNodeToArrayOfRows(table.node))\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction)\n  rows = transpose(rows)\n\n  return convertArrayOfRowsToTableNode(table.node, rows)\n}\n\nconst moveTableRow = (\n  table: ContentNodeWithPos,\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  direction: -1 | 1 | 0,\n) => {\n  let rows = convertTableNodeToArrayOfRows(table.node)\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction)\n\n  return convertArrayOfRowsToTableNode(table.node, rows)\n}\n\nconst getSelectionRangeInColumn = (columnIndex: number, tr: Transaction) => {\n  let startIndex = columnIndex\n  let endIndex = columnIndex\n\n  // looking for selection start column (startIndex)\n  for (let i = columnIndex; i >= 0; i--) {\n    const cells = getCellsInCol(i, tr.selection)\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1\n        if (maybeEndIndex >= startIndex)\n          startIndex = i\n\n        if (maybeEndIndex > endIndex)\n          endIndex = maybeEndIndex\n      })\n    }\n  }\n  // looking for selection end column (endIndex)\n  for (let i = columnIndex; i <= endIndex; i++) {\n    const cells = getCellsInCol(i, tr.selection)\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1\n        if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex)\n          endIndex = maybeEndIndex\n      })\n    }\n  }\n\n  // filter out columns without cells (where all rows have colspan > 1 in the same column)\n  const indexes = []\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInCol(i, tr.selection)\n    if (maybeCells && maybeCells.length)\n      indexes.push(i)\n  }\n  startIndex = indexes[0]!\n  endIndex = indexes[indexes.length - 1]!\n\n  const firstSelectedColumnCells = getCellsInCol(startIndex, tr.selection)!\n  const firstRowCells = getCellsInRow(0, tr.selection)!\n  const $anchor = tr.doc.resolve(\n    firstSelectedColumnCells[firstSelectedColumnCells.length - 1]!.pos,\n  )\n\n  let headCell: CellPos | undefined\n  for (let i = endIndex; i >= startIndex; i--) {\n    const columnCells = getCellsInCol(i, tr.selection)\n    if (columnCells && columnCells.length) {\n      for (let j = firstRowCells.length - 1; j >= 0; j--) {\n        if (firstRowCells[j]!.pos === columnCells[0]!.pos) {\n          headCell = columnCells[0]\n          break\n        }\n      }\n      if (headCell)\n        break\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell!.pos)\n  return { $anchor, $head, indexes }\n}\n\nconst getSelectionRangeInRow = (rowIndex: number, tr: Transaction) => {\n  let startIndex = rowIndex\n  let endIndex = rowIndex\n  // looking for selection start row (startIndex)\n  for (let i = rowIndex; i >= 0; i--) {\n    const cells = getCellsInRow(i, tr.selection)\n    cells!.forEach((cell) => {\n      const maybeEndIndex = cell.node.attrs.rowspan + i - 1\n      if (maybeEndIndex >= startIndex)\n        startIndex = i\n\n      if (maybeEndIndex > endIndex)\n        endIndex = maybeEndIndex\n    })\n  }\n  // looking for selection end row (endIndex)\n  for (let i = rowIndex; i <= endIndex; i++) {\n    const cells = getCellsInRow(i, tr.selection)\n    cells!.forEach((cell) => {\n      const maybeEndIndex = cell.node.attrs.rowspan + i - 1\n      if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex)\n        endIndex = maybeEndIndex\n    })\n  }\n\n  // filter out rows without cells (where all columns have rowspan > 1 in the same row)\n  const indexes = []\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInRow(i, tr.selection)\n    if (maybeCells && maybeCells.length)\n      indexes.push(i)\n  }\n  startIndex = indexes[0]!\n  endIndex = indexes[indexes.length - 1]!\n\n  const firstSelectedRowCells = getCellsInRow(startIndex, tr.selection)!\n  const firstColumnCells = getCellsInCol(0, tr.selection)!\n  const $anchor = tr.doc.resolve(firstSelectedRowCells[firstSelectedRowCells.length - 1]!.pos)\n\n  let headCell: CellPos | undefined\n  for (let i = endIndex; i >= startIndex; i--) {\n    const rowCells = getCellsInRow(i, tr.selection)\n    if (rowCells && rowCells.length) {\n      for (let j = firstColumnCells.length - 1; j >= 0; j--) {\n        if (firstColumnCells[j]!.pos === rowCells[0]!.pos) {\n          headCell = rowCells[0]!\n          break\n        }\n      }\n      if (headCell)\n        break\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell!.pos)\n  return { $anchor, $head, indexes }\n}\n\n/// If the selection is in a table,\n/// Move the columns at `origin` to `target` in current table.\n/// The `select` is true by default, which means the selection will be set to the moved column.\nexport function moveCol(tr: Transaction, origin: number, target: number, select = true) {\n  const table = findTable(tr.selection)\n  if (!table)\n    return tr\n\n  const { indexes: indexesOriginColumn } = getSelectionRangeInColumn(origin, tr)\n  const { indexes: indexesTargetColumn } = getSelectionRangeInColumn(target, tr)\n\n  if (indexesOriginColumn.includes(target))\n    return tr\n\n  const newTable = moveTableColumn(\n    table,\n    indexesOriginColumn,\n    indexesTargetColumn,\n    0,\n  )\n\n  const _tr = cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable,\n  )\n\n  if (!select)\n    return _tr\n\n  const map = TableMap.get(newTable)\n  const start = table.start\n  const index = target\n  const lastCell = map.positionAt(map.height - 1, index, newTable)\n  const $lastCell = _tr.doc.resolve(start + lastCell)\n\n  const createCellSelection = CellSelection.colSelection\n\n  const firstCell = map.positionAt(0, index, newTable)\n  const $firstCell = _tr.doc.resolve(start + firstCell)\n\n  return _tr.setSelection(createCellSelection($lastCell, $firstCell))\n}\n\n/// If the selection is in a table,\n/// Move the rows at `origin` and `target` in current table.\n/// The `select` is true by default, which means the selection will be set to the moved row.\nexport function moveRow(tr: Transaction, origin: number, target: number, select = true) {\n  const table = findTable(tr.selection)\n  if (!table)\n    return tr\n\n  const { indexes: indexesOriginRow } = getSelectionRangeInRow(origin, tr)\n  const { indexes: indexesTargetRow } = getSelectionRangeInRow(target, tr)\n\n  if (indexesOriginRow.includes(target))\n    return tr\n\n  const newTable = moveTableRow(\n    table,\n    indexesOriginRow,\n    indexesTargetRow,\n    0,\n  )\n\n  const _tr = cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable,\n  )\n\n  if (!select)\n    return _tr\n\n  const map = TableMap.get(newTable)\n  const start = table.start\n  const index = target\n  const lastCell = map.positionAt(index, map.width - 1, newTable)\n  const $lastCell = _tr.doc.resolve(start + lastCell)\n\n  const createCellSelection = CellSelection.rowSelection\n\n  const firstCell = map.positionAt(index, 0, newTable)\n  const $firstCell = _tr.doc.resolve(start + firstCell)\n\n  return _tr.setSelection(createCellSelection($lastCell, $firstCell))\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MarkdownNode } from '@milkdown/transformer'\nimport { commandsCtx } from '@milkdown/core'\nimport { paragraphSchema } from '@milkdown/preset-commonmark'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport type { NodeType } from '@milkdown/prose/model'\nimport { Selection, TextSelection } from '@milkdown/prose/state'\nimport { CellSelection, addColumnAfter, addColumnBefore, deleteColumn, deleteRow, deleteTable, goToNextCell, isInTable, selectedRect, setCellAttr, tableNodes } from '@milkdown/prose/tables'\nimport { $command, $inputRule, $nodeSchema, $useKeymap } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\nimport { addRowWithAlignment, createTable, moveCol, moveRow, selectCol, selectRow, selectTable } from './utils'\n\nconst originalSchema = tableNodes({\n  tableGroup: 'block',\n  cellContent: 'paragraph',\n  cellAttributes: {\n    alignment: {\n      default: 'left',\n      getFromDOM: dom => (dom as HTMLElement).style.textAlign || 'left',\n      setDOMAttr: (value, attrs) => {\n        attrs.style = `text-align: ${value || 'left'}`\n      },\n    },\n  },\n})\n\n/// Schema for table node.\nexport const tableSchema = $nodeSchema('table', () => ({\n  ...originalSchema.table,\n  parseMarkdown: {\n    match: node => node.type === 'table',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align,\n        isHeader: i === 0,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table',\n    runner: (state, node) => {\n      const firstLine = node.content.firstChild?.content\n      if (!firstLine)\n        return\n\n      const align: (string | null)[] = []\n      firstLine.forEach((cell) => {\n        align.push(cell.attrs.alignment)\n      })\n      state.openNode('table', undefined, { align })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableSchema.node, {\n  displayName: 'NodeSchema<table>',\n  group: 'Table',\n})\n\nwithMeta(tableSchema.ctx, {\n  displayName: 'NodeSchemaCtx<table>',\n  group: 'Table',\n})\n\n/// Schema for table row node.\nexport const tableRowSchema = $nodeSchema('table_row', () => ({\n  ...originalSchema.table_row,\n  parseMarkdown: {\n    match: node => node.type === 'tableRow',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align: align[i],\n        isHeader: node.isHeader,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_row',\n    runner: (state, node) => {\n      state.openNode('tableRow')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableRowSchema.node, {\n  displayName: 'NodeSchema<tableRow>',\n  group: 'Table',\n})\n\nwithMeta(tableRowSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableRow>',\n  group: 'Table',\n})\n\n/// Schema for table cell node.\nexport const tableCellSchema = $nodeSchema('table_cell', () => ({\n  ...originalSchema.table_cell,\n  parseMarkdown: {\n    match: node => node.type === 'tableCell' && !node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state\n        .openNode(type, { alignment: align })\n        .openNode(state.schema.nodes.paragraph as NodeType)\n        .next(node.children)\n        .closeNode()\n        .closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_cell',\n    runner: (state, node) => {\n      state.openNode('tableCell').next(node.content).closeNode()\n    },\n  },\n}))\n\nwithMeta(tableCellSchema.node, {\n  displayName: 'NodeSchema<tableCell>',\n  group: 'Table',\n})\n\nwithMeta(tableCellSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableCell>',\n  group: 'Table',\n})\n\n/// Schema for table header node.\nexport const tableHeaderSchema = $nodeSchema('table_header', () => ({\n  ...originalSchema.table_header,\n  parseMarkdown: {\n    match: node => node.type === 'tableCell' && !!node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state.openNode(type, { alignment: align })\n      state.openNode(state.schema.nodes.paragraph as NodeType)\n      state.next(node.children)\n      state.closeNode()\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_header',\n    runner: (state, node) => {\n      state.openNode('tableCell')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableHeaderSchema.node, {\n  displayName: 'NodeSchema<tableHeader>',\n  group: 'Table',\n})\n\nwithMeta(tableHeaderSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableHeader>',\n  group: 'Table',\n})\n\n/// A input rule for creating table.\n/// For example, `|2x2|` will create a 2x2 table.\nexport const insertTableInputRule = $inputRule(() => new InputRule(\n  /^\\|(?<col>\\d+)[xX](?<row>\\d+)\\|\\s$/, (state, match, start, end) => {\n    const $start = state.doc.resolve(start)\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), tableSchema.type()))\n      return null\n\n    const tableNode = createTable(\n      Number(match.groups?.row),\n      Number(match.groups?.col),\n    )\n    const tr = state.tr.replaceRangeWith(start, end, tableNode).scrollIntoView()\n    return tr.setSelection(TextSelection.create(tr.doc, start + 3))\n  },\n))\n\nwithMeta(insertTableInputRule, {\n  displayName: 'InputRule<insertTableInputRule>',\n  group: 'Table',\n})\n\n/// A command for moving cursor to previous cell.\nexport const goToPrevTableCellCommand = $command('GoToPrevTableCell', () => () => goToNextCell(-1))\n\nwithMeta(goToPrevTableCellCommand, {\n  displayName: 'Command<goToPrevTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for moving cursor to next cell.\nexport const goToNextTableCellCommand = $command('GoToNextTableCell', () => () => goToNextCell(1))\n\nwithMeta(goToNextTableCellCommand, {\n  displayName: 'Command<goToNextTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for splitting current table into two tables.\n/// If the selection is at the end of the table,\n/// it will just quit the table and insert a new paragraph node.\nexport const breakTableCommand = $command('BreakTable', () => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n\n  const { $head } = state.selection\n  const pos = $head.after()\n  const tr = state.tr\n    .replaceWith(pos, pos, paragraphSchema.type().createAndFill()!)\n\n  tr.setSelection(Selection.near(tr.doc.resolve(pos), 1)).scrollIntoView()\n  dispatch?.(tr)\n  return true\n})\n\nwithMeta(breakTableCommand, {\n  displayName: 'Command<breakTableCommand>',\n  group: 'Table',\n})\n\n/// A command for inserting a table.\n/// You can specify the number of rows and columns.\n/// By default, it will insert a 3x3 table.\nexport const insertTableCommand = $command('InsertTable', () => ({ row, col }: { row?: number; col?: number } = {}) => (state, dispatch) => {\n  const { selection, tr } = state\n  const { from } = selection\n  const table = createTable(row, col)\n  const _tr = tr.replaceSelectionWith(table)\n  const sel = Selection.findFrom(_tr.doc.resolve(from), 1, true)\n  if (sel)\n    dispatch?.(_tr.setSelection(sel))\n\n  return true\n})\n\nwithMeta(insertTableCommand, {\n  displayName: 'Command<insertTableCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a row in a table.\n/// You should specify the `from` and `to` index.\nexport const moveRowCommand = $command('MoveRow', () => ({ from, to }: { from?: number; to?: number } = {}) => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(moveRow(tr, from ?? 0, to ?? 0, true))\n\n  return Boolean(result)\n})\n\nwithMeta(moveRowCommand, {\n  displayName: 'Command<moveRowCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a column in a table.\n/// You should specify the `from` and `to` index.\nexport const moveColCommand = $command('MoveCol', () => ({ from, to }: { from?: number; to?: number } = {}) => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(moveCol(tr, from ?? 0, to ?? 0, true))\n\n  return Boolean(result)\n})\n\nwithMeta(moveColCommand, {\n  displayName: 'Command<moveColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a row.\nexport const selectRowCommand = $command<number, 'SelectRow'>('SelectRow', () => (index = 0) => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(selectRow(index)(tr))\n\n  return Boolean(result)\n})\n\nwithMeta(selectRowCommand, {\n  displayName: 'Command<selectRowCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a column.\nexport const selectColCommand = $command<number, 'SelectCol'>('SelectCol', () => (index = 0) => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(selectCol(index)(tr))\n\n  return Boolean(result)\n})\n\nwithMeta(selectColCommand, {\n  displayName: 'Command<selectColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a table.\nexport const selectTableCommand = $command('SelectTable', () => () => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(selectTable(tr))\n\n  return Boolean(result)\n})\n\nwithMeta(selectTableCommand, {\n  displayName: 'Command<selectTableCommand>',\n  group: 'Table',\n})\n\n/// A command for deleting selected cells.\n/// If the selection is a row or column, the row or column will be deleted.\n/// If all cells are selected, the table will be deleted.\nexport const deleteSelectedCellsCommand = $command('DeleteSelectedCells', () => () => (state, dispatch) => {\n  const { selection } = state\n  if (!(selection instanceof CellSelection))\n    return false\n\n  const isRow = selection.isRowSelection()\n  const isCol = selection.isColSelection()\n\n  if (isRow && isCol)\n    return deleteTable(state, dispatch)\n\n  if (isCol)\n    return deleteColumn(state, dispatch)\n\n  else\n    return deleteRow(state, dispatch)\n})\n\nwithMeta(deleteSelectedCellsCommand, {\n  displayName: 'Command<deleteSelectedCellsCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column before the current column.\nexport const addColBeforeCommand = $command('AddColBefore', () => () => addColumnBefore)\n\nwithMeta(addColBeforeCommand, {\n  displayName: 'Command<addColBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column after the current column.\nexport const addColAfterCommand = $command('AddColAfter', () => () => addColumnAfter)\n\nwithMeta(addColAfterCommand, {\n  displayName: 'Command<addColAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row before the current row.\nexport const addRowBeforeCommand = $command('AddRowBefore', () => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n  if (dispatch) {\n    const rect = selectedRect(state)\n    dispatch(addRowWithAlignment(state.tr, rect, rect.top))\n  }\n  return true\n})\n\nwithMeta(addRowBeforeCommand, {\n  displayName: 'Command<addRowBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row after the current row.\nexport const addRowAfterCommand = $command('AddRowAfter', () => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n  if (dispatch) {\n    const rect = selectedRect(state)\n    dispatch(addRowWithAlignment(state.tr, rect, rect.bottom))\n  }\n  return true\n})\n\nwithMeta(addRowAfterCommand, {\n  displayName: 'Command<addRowAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for setting alignment property for selected cells.\n/// You can specify the alignment as `left`, `center`, or `right`.\n/// It's `left` by default.\nexport const setAlignCommand = $command<'left' | 'center' | 'right', 'SetAlign'>('SetAlign', () => (alignment = 'left') => setCellAttr('alignment', alignment))\n\nwithMeta(setAlignCommand, {\n  displayName: 'Command<setAlignCommand>',\n  group: 'Table',\n})\n\n/// Keymap for table commands.\n/// - `<Mod-]>`/`<Tab>`: Move to the next cell.\n/// - `<Mod-[>`/`<Shift-Tab>`: Move to the previous cell.\n/// - `<Mod-Enter>`: Exit the table, and break it if possible.\nexport const tableKeymap = $useKeymap('tableKeymap', {\n  NextCell: {\n    shortcuts: ['Mod-]', 'Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToNextTableCellCommand.key)\n    },\n  },\n  PrevCell: {\n    shortcuts: ['Mod-[', 'Shift-Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToPrevTableCellCommand.key)\n    },\n  },\n  ExitTable: {\n    shortcuts: ['Mod-Enter'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(breakTableCommand.key)\n    },\n  },\n})\n\nwithMeta(tableKeymap.ctx, {\n  displayName: 'KeymapCtx<table>',\n  group: 'Table',\n})\n\nwithMeta(tableKeymap.shortcuts, {\n  displayName: 'Keymap<table>',\n  group: 'Table',\n})\n\nexport * from './utils'\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_definition'\nconst markdownId = 'footnoteDefinition'\n\n/// Footnote definition node schema.\nexport const footnoteDefinitionSchema = $nodeSchema('footnote_definition', () => ({\n  group: 'block',\n  content: 'block+',\n  defining: true,\n  attrs: {\n    label: {\n      default: '',\n    },\n  },\n  parseDOM: [\n    {\n      tag: `dl[data-type=\"${id}\"]`,\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement))\n          throw expectDomTypeError(dom)\n\n        return {\n          label: dom.dataset.label,\n        }\n      },\n      contentElement: 'dd',\n    },\n  ],\n  toDOM: (node) => {\n    const label = node.attrs.label\n\n    return [\n      'dl',\n      {\n        // TODO: add a prosemirror plugin to sync label on change\n        'data-label': label,\n        'data-type': id,\n      },\n      ['dt', label],\n      ['dd', 0],\n    ]\n  },\n  parseMarkdown: {\n    match: ({ type }) => type === markdownId,\n    runner: (state, node, type) => {\n      state\n        .openNode(type, {\n          label: node.label as string,\n        })\n        .next(node.children)\n        .closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === id,\n    runner: (state, node) => {\n      state\n        .openNode(markdownId, undefined, {\n          label: node.attrs.label,\n          identifier: node.attrs.label,\n        })\n        .next(node.content)\n        .closeNode()\n    },\n  },\n}))\n\nwithMeta(footnoteDefinitionSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeDef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteDefinitionSchema.node, {\n  displayName: 'NodeSchema<footnodeDef>',\n  group: 'footnote',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_reference'\n\n/// Footnote reference node schema.\nexport const footnoteReferenceSchema = $nodeSchema('footnote_reference', () => ({\n  group: 'inline',\n  inline: true,\n  atom: true,\n  attrs: {\n    label: {\n      default: '',\n    },\n  },\n  parseDOM: [\n    {\n      tag: `sup[data-type=\"${id}\"]`,\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement))\n          throw expectDomTypeError(dom)\n\n        return {\n          label: dom.dataset.label,\n        }\n      },\n    },\n  ],\n  toDOM: (node) => {\n    const label = node.attrs.label\n    return [\n      'sup',\n      {\n        // TODO: add a prosemirror plugin to sync label on change\n        'data-label': label,\n        'data-type': id,\n      },\n      label,\n    ]\n  },\n  parseMarkdown: {\n    match: ({ type }) => type === 'footnoteReference',\n    runner: (state, node, type) => {\n      state.addNode(type, {\n        label: node.label as string,\n      })\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === id,\n    runner: (state, node) => {\n      state.addNode('footnoteReference', undefined, undefined, {\n        label: node.attrs.label,\n        identifier: node.attrs.label,\n      })\n    },\n  },\n}))\n\nwithMeta(footnoteReferenceSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeRef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteReferenceSchema.node, {\n  displayName: 'NodeSchema<footnodeRef>',\n  group: 'footnote',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { listItemSchema } from '@milkdown/preset-commonmark'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { $inputRule } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This schema extends the [list item](/preset-commonmark#list-item) schema and add task list support for it.\nexport const extendListItemSchemaForTask = listItemSchema.extendSchema((prev) => {\n  return (ctx) => {\n    const baseSchema = prev(ctx)\n    return {\n      ...baseSchema,\n      attrs: {\n        ...baseSchema.attrs,\n        checked: {\n          default: null,\n        },\n      },\n      parseDOM: [\n        {\n          tag: 'li[data-item-type=\"task\"]',\n          getAttrs: (dom) => {\n            if (!(dom instanceof HTMLElement))\n              throw expectDomTypeError(dom)\n\n            return {\n              label: dom.dataset.label,\n              listType: dom.dataset['list-type'],\n              spread: dom.dataset.spread,\n              checked: dom.dataset.checked ? dom.dataset.checked === 'true' : null,\n            }\n          },\n        },\n        ...baseSchema?.parseDOM || [],\n      ],\n      toDOM: (node) => {\n        if (baseSchema.toDOM && node.attrs.checked == null)\n          return baseSchema.toDOM(node)\n\n        return [\n          'li',\n          {\n            'data-item-type': 'task',\n            'data-label': node.attrs.label,\n            'data-list-type': node.attrs.listType,\n            'data-spread': node.attrs.spread,\n            'data-checked': node.attrs.checked,\n          },\n          0,\n        ]\n      },\n      parseMarkdown: {\n        match: ({ type }) => type === 'listItem',\n        runner: (state, node, type) => {\n          if (node.checked == null) {\n            baseSchema.parseMarkdown.runner(state, node, type)\n            return\n          }\n\n          const label = node.label != null ? `${node.label}.` : '•'\n          const checked = node.checked != null ? Boolean(node.checked) : null\n          const listType = node.label != null ? 'ordered' : 'bullet'\n          const spread = node.spread != null ? `${node.spread}` : 'true'\n\n          state.openNode(type, { label, listType, spread, checked })\n          state.next(node.children)\n          state.closeNode()\n        },\n      },\n      toMarkdown: {\n        match: node => node.type.name === 'list_item',\n        runner: (state, node) => {\n          if (node.attrs.checked == null) {\n            baseSchema.toMarkdown.runner(state, node)\n            return\n          }\n\n          const label = node.attrs.label\n          const listType = node.attrs.listType\n          const spread = node.attrs.spread === 'true'\n          const checked = node.attrs.checked\n\n          state.openNode('listItem', undefined, { label, listType, spread, checked })\n          state.next(node.content)\n          state.closeNode()\n        },\n      },\n    }\n  }\n})\n\nwithMeta(extendListItemSchemaForTask, {\n  displayName: 'NodeSchema<listItem>',\n  group: 'ListItem',\n})\n\n/// Input rule for wrapping a block in task list node.\n/// Users can type `[ ] ` or `[x] ` to wrap the block in task list node with checked status.\nexport const wrapInTaskListInputRule = $inputRule(() => {\n  return new InputRule(/^\\[(?<checked>\\s|x)\\]\\s$/, (state, match, start, end) => {\n    const pos = state.doc.resolve(start)\n    let depth = 0\n    let node = pos.node(depth)\n    while (node && node.type.name !== 'list_item') {\n      depth--\n      node = pos.node(depth)\n    }\n\n    if (!node || node.attrs.checked != null)\n      return null\n\n    const checked = Boolean(match.groups?.checked === 'x')\n\n    const finPos = pos.before(depth)\n    const tr = state.tr\n\n    tr.deleteRange(start, end)\n      .setNodeMarkup(finPos, undefined, { ...node.attrs, checked })\n\n    return tr\n  })\n})\n\nwithMeta(wrapInTaskListInputRule, {\n  displayName: 'InputRule<wrapInTaskListInputRule>',\n  group: 'ListItem',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin } from '@milkdown/ctx'\nimport { strikethroughKeymap } from '../mark'\nimport { tableKeymap } from '../node'\n\n/// @internal\nexport const keymap: MilkdownPlugin[] = [\n  strikethroughKeymap,\n  tableKeymap,\n].flat()\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin } from '@milkdown/ctx'\nimport { insertTableInputRule, wrapInTaskListInputRule } from '../node'\n\n/// @internal\nexport const inputrules: MilkdownPlugin[] = [\n  insertTableInputRule,\n  wrapInTaskListInputRule,\n]\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { browser } from '@milkdown/prose'\nimport type { Node } from '@milkdown/prose/model'\nimport { isInTable } from '@milkdown/prose/tables'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { paragraphSchema } from '@milkdown/preset-commonmark'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to fix the bug of IME composing in table in Safari browser.\n/// original discussion in https://discuss.prosemirror.net/t/ime-composing-problems-on-td-or-th-element-in-safari-browser/4501\nexport const autoInsertZeroSpaceInTablePlugin = $prose(() => {\n  const pluginKey = new PluginKey('MILKDOWN_AUTO_INSERT_ZERO_SPACE')\n\n  const isParagraph = (node: Node) => node.type === paragraphSchema.type()\n\n  const isEmptyParagraph = (node: Node) => isParagraph(node) && node.nodeSize === 2\n\n  return new Plugin({\n    key: pluginKey,\n    props: {\n      handleDOMEvents: {\n        compositionstart(view) {\n          const { state, dispatch } = view\n          const { tr, selection } = state\n          const { $from } = selection\n          if (browser.safari && isInTable(state) && selection.empty && isEmptyParagraph($from.parent))\n            dispatch(tr.insertText('\\u2060', $from.start()))\n\n          return false\n        },\n        compositionend(view) {\n          const { state, dispatch } = view\n          const { tr, selection } = state\n          const { $from } = selection\n\n          if (\n            browser.safari\n              && isInTable(state)\n              && selection.empty\n              && isParagraph($from.parent)\n              && $from.parent.textContent.startsWith('\\u2060')\n          )\n            dispatch(tr.delete($from.start(), $from.start() + 1))\n\n          return false\n        },\n      },\n    },\n  })\n})\n\nwithMeta(autoInsertZeroSpaceInTablePlugin, {\n  displayName: 'Prose<autoInsertZeroSpaceInTablePlugin>',\n  group: 'Prose',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { columnResizing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `columnResizing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const columnResizingPlugin = $prose(() => columnResizing({}))\n\nwithMeta(columnResizingPlugin, {\n  displayName: 'Prose<columnResizingPlugin>',\n  group: 'Prose',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { tableEditing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `tableEditing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const tableEditingPlugin = $prose(() => tableEditing())\n\nwithMeta(tableEditingPlugin, {\n  displayName: 'Prose<tableEditingPlugin>',\n  group: 'Prose',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { $remark } from '@milkdown/utils'\nimport remarkGFM from 'remark-gfm'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the [remark-gfm](https://github.com/remarkjs/remark-gfm).\nexport const remarkGFMPlugin = $remark(() => remarkGFM)\n\nwithMeta(remarkGFMPlugin, {\n  displayName: 'Remark<remarkGFMPlugin>',\n  group: 'Remark',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin } from '@milkdown/ctx'\nimport { autoInsertZeroSpaceInTablePlugin, columnResizingPlugin, remarkGFMPlugin, tableEditingPlugin } from '../plugin'\n\n/// @internal\nexport const plugins: MilkdownPlugin[] = [\n  autoInsertZeroSpaceInTablePlugin,\n  columnResizingPlugin,\n  tableEditingPlugin,\n  remarkGFMPlugin,\n]\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin } from '@milkdown/ctx'\nimport { strikethroughAttr, strikethroughSchema } from '../mark'\nimport { extendListItemSchemaForTask, footnoteDefinitionSchema, footnoteReferenceSchema, tableCellSchema, tableHeaderSchema, tableRowSchema, tableSchema } from '../node'\n\n/// @internal\nexport const schema: MilkdownPlugin[] = [\n  extendListItemSchemaForTask,\n\n  tableSchema,\n  tableRowSchema,\n  tableHeaderSchema,\n  tableCellSchema,\n\n  footnoteDefinitionSchema,\n  footnoteReferenceSchema,\n\n  strikethroughAttr,\n  strikethroughSchema,\n].flat()\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { toggleStrikethroughCommand } from '../mark'\nimport { addColAfterCommand, addColBeforeCommand, addRowAfterCommand, addRowBeforeCommand, breakTableCommand, deleteSelectedCellsCommand, goToNextTableCellCommand, goToPrevTableCellCommand, insertTableCommand, moveColCommand, moveRowCommand, selectColCommand, selectRowCommand, selectTableCommand, setAlignCommand } from '../node'\n\n/// @internal\nexport const commands = [\n  goToNextTableCellCommand,\n  goToPrevTableCellCommand,\n  breakTableCommand,\n  insertTableCommand,\n  moveRowCommand,\n  moveColCommand,\n  selectRowCommand,\n  selectColCommand,\n  selectTableCommand,\n  deleteSelectedCellsCommand,\n  addRowBeforeCommand,\n  addRowAfterCommand,\n  addColBeforeCommand,\n  addColAfterCommand,\n  setAlignCommand,\n\n  toggleStrikethroughCommand,\n]\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { commands, inputrules, keymap, plugins, schema } from './composed'\n\nexport * from './node'\nexport * from './mark'\nexport * from './composed'\n\n/// The GFM preset, includes all the plugins.\nexport const gfm = [schema, inputrules, keymap, plugins, commands].flat()\n"],"names":["withMeta","plugin","meta","strikethroughAttr","$markAttr","strikethroughSchema","$markSchema","ctx","value","mark","node","state","markType","toggleStrikethroughCommand","$command","toggleMarkdownMark","strikethroughKeymap","$useKeymap","commands","commandsCtx","createTable","rowsCount","colsCount","cells","tableCellSchema","headerCells","tableHeaderSchema","rows","_","i","tableRowSchema","tableSchema","findTable","selection","findParentNode","getCellsInCol","columnIndex","table","map","TableMap","pos","start","x","getCellsInRow","rowIndex","getAllCellsInTable","nodePos","selectTable","tr","$firstCell","last","$lastCell","cloneTr","CellSelection","addRowWithAlignment","tableStart","row","rowPos","acc","col","headerCol","selectLine","type","index","isRowSelection","lastCell","createCellSelection","firstCell","selectRow","selectCol","transpose","array","column","convertArrayOfRowsToTableNode","tableNode","arrayOfNodes","rowsPM","rowCells","colIndex","cellPos","cell","newCell","convertTableNodeToArrayOfRows","seen","rect","moveRowInArrayOfRows","indexesOrigin","indexesTarget","directionOverride","direction","rowsExtracted","positionOffset","target","moveTableColumn","moveTableRow","getSelectionRangeInColumn","startIndex","endIndex","maybeEndIndex","indexes","maybeCells","firstSelectedColumnCells","firstRowCells","$anchor","headCell","columnCells","j","$head","getSelectionRangeInRow","firstSelectedRowCells","firstColumnCells","moveCol","origin","select","indexesOriginColumn","indexesTargetColumn","newTable","_tr","moveRow","indexesOriginRow","indexesTargetRow","originalSchema","tableNodes","dom","attrs","$nodeSchema","align","children","firstLine","_a","insertTableInputRule","$inputRule","InputRule","match","end","$start","_b","TextSelection","goToPrevTableCellCommand","goToNextCell","goToNextTableCellCommand","breakTableCommand","dispatch","isInTable","paragraphSchema","Selection","insertTableCommand","from","sel","moveRowCommand","to","moveColCommand","selectRowCommand","selectColCommand","selectTableCommand","deleteSelectedCellsCommand","isRow","isCol","deleteTable","deleteColumn","deleteRow","addColBeforeCommand","addColumnBefore","addColAfterCommand","addColumnAfter","addRowBeforeCommand","selectedRect","addRowAfterCommand","setAlignCommand","alignment","setCellAttr","tableKeymap","id","markdownId","footnoteDefinitionSchema","expectDomTypeError","label","footnoteReferenceSchema","extendListItemSchemaForTask","listItemSchema","prev","baseSchema","checked","listType","spread","wrapInTaskListInputRule","depth","finPos","keymap","inputrules","autoInsertZeroSpaceInTablePlugin","$prose","pluginKey","PluginKey","isParagraph","isEmptyParagraph","Plugin","view","$from","browser","columnResizingPlugin","columnResizing","tableEditingPlugin","tableEditing","remarkGFMPlugin","$remark","remarkGFM","plugins","schema","gfm"],"mappings":"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"}