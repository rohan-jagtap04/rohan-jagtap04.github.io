import { expectDomTypeError as O } from "@milkdown/exception";
import { paragraphSchema as Q, listItemSchema as Ie } from "@milkdown/preset-commonmark";
import { InputRule as Y } from "@milkdown/prose/inputrules";
import { $markAttr as $e, $markSchema as _e, $command as h, $useKeymap as ee, $nodeSchema as k, $inputRule as te, $prose as B, $remark as Pe } from "@milkdown/utils";
import { commandsCtx as M } from "@milkdown/core";
import { TextSelection as Ee, Selection as oe, PluginKey as De, Plugin as Oe } from "@milkdown/prose/state";
import { TableMap as g, CellSelection as y, tableNodes as Be, goToNextCell as ne, isInTable as N, deleteTable as Ke, deleteColumn as He, deleteRow as Le, addColumnBefore as Fe, addColumnAfter as We, selectedRect as le, setCellAttr as ze, columnResizing as Ge, tableEditing as je } from "@milkdown/prose/tables";
import { toggleMarkdownMark as Ze, findParentNode as Ve, cloneTr as A, browser as V } from "@milkdown/prose";
import Ue from "remark-gfm";
const d = (e, t) => (Object.assign(e, {
  meta: {
    package: "@milkdown/preset-gfm",
    ...t
  }
}), e), K = $e("strike_through");
d(K, {
  displayName: "Attr<strikethrough>",
  group: "Strikethrough"
});
const x = _e("strike_through", (e) => ({
  parseDOM: [
    { tag: "del" },
    { style: "text-decoration", getAttrs: (t) => t === "line-through" }
  ],
  toDOM: (t) => ["del", e.get(K.key)(t)],
  parseMarkdown: {
    match: (t) => t.type === "delete",
    runner: (t, n, o) => {
      t.openMark(o), t.next(n.children), t.closeMark(o);
    }
  },
  toMarkdown: {
    match: (t) => t.type.name === "strike_through",
    runner: (t, n) => {
      t.withMark(n, "delete");
    }
  }
}));
d(x.mark, {
  displayName: "MarkSchema<strikethrough>",
  group: "Strikethrough"
});
d(x.ctx, {
  displayName: "MarkSchemaCtx<strikethrough>",
  group: "Strikethrough"
});
const H = h("ToggleStrikeThrough", () => () => {
  const e = x.type();
  return Ze(e, "~~");
});
d(H, {
  displayName: "Command<ToggleStrikethrough>",
  group: "Strikethrough"
});
const L = ee("strikeThroughKeymap", {
  ToggleStrikethrough: {
    shortcuts: "Mod-Alt-x",
    command: (e) => {
      const t = e.get(M);
      return () => t.call(H.key);
    }
  }
});
d(L.ctx, {
  displayName: "KeymapCtx<strikethrough>",
  group: "Strikethrough"
});
d(L.shortcuts, {
  displayName: "Keymap<strikethrough>",
  group: "Strikethrough"
});
const re = (e = 3, t = 3) => {
  const n = Array(t).fill(0).map(() => R.type().createAndFill()), o = Array(t).fill(0).map(() => I.type().createAndFill()), l = Array(e).fill(0).map((r, a) => S.type().create(null, a === 0 ? o : n));
  return T.type().create(null, l);
}, w = (e) => Ve((t) => t.type.spec.tableRole === "table")(e), b = (e, t) => {
  const n = w(t);
  if (!n)
    return;
  const o = g.get(n.node);
  if (!(e < 0 || e >= o.width))
    return o.cellsInRect({ left: e, right: e + 1, top: 0, bottom: o.height }).map((l) => {
      const r = n.node.nodeAt(l);
      if (!r)
        return;
      const a = l + n.start;
      return {
        pos: a,
        start: a + 1,
        node: r
      };
    }).filter((l) => l != null);
}, C = (e, t) => {
  const n = w(t);
  if (!n)
    return;
  const o = g.get(n.node);
  if (!(e < 0 || e >= o.height))
    return o.cellsInRect({ left: 0, right: o.width, top: e, bottom: e + 1 }).map((l) => {
      const r = n.node.nodeAt(l);
      if (!r)
        return;
      const a = l + n.start;
      return {
        pos: a,
        start: a + 1,
        node: r
      };
    }).filter((l) => l != null);
}, Xe = (e) => {
  const t = w(e);
  if (!t)
    return;
  const n = g.get(t.node);
  return n.cellsInRect({
    left: 0,
    right: n.width,
    top: 0,
    bottom: n.height
  }).map((l) => {
    const r = t.node.nodeAt(l), a = l + t.start;
    return { pos: a, start: a + 1, node: r };
  });
}, qe = (e) => {
  const t = Xe(e.selection);
  if (t && t[0]) {
    const n = e.doc.resolve(t[0].pos), o = t[t.length - 1];
    if (o) {
      const l = e.doc.resolve(o.pos);
      return A(e.setSelection(new y(l, n)));
    }
  }
  return e;
};
function ae(e, { map: t, tableStart: n, table: o }, l) {
  const r = Array(l).fill(0).reduce((i, c, m) => i + o.child(m).nodeSize, n), a = Array(t.width).fill(0).map((i, c) => {
    const m = o.nodeAt(t.map[c]);
    return R.type().createAndFill({ alignment: m == null ? void 0 : m.attrs.alignment });
  });
  return e.insert(r, S.type().create(null, a)), e;
}
const se = (e) => (t) => (n) => {
  const o = w(n.selection), l = e === "row";
  if (o) {
    const r = g.get(o.node);
    if (t >= 0 && t < (l ? r.height : r.width)) {
      const a = r.positionAt(
        l ? t : r.height - 1,
        l ? r.width - 1 : t,
        o.node
      ), i = n.doc.resolve(o.start + a), c = l ? y.rowSelection : y.colSelection, m = r.positionAt(l ? t : 0, l ? 0 : t, o.node), s = n.doc.resolve(o.start + m);
      return A(n.setSelection(c(i, s)));
    }
  }
  return n;
}, Je = se("row"), Qe = se("col"), U = (e) => e[0].map((t, n) => e.map((o) => o[n])), ce = (e, t) => {
  const n = [], o = g.get(e);
  for (let r = 0; r < o.height; r++) {
    const a = e.child(r), i = [];
    for (let c = 0; c < o.width; c++) {
      if (!t[r][c])
        continue;
      const m = o.map[r * o.width + c], s = t[r][c], p = e.nodeAt(m).type.createChecked(
        Object.assign({}, s.attrs),
        s.content,
        s.marks
      );
      i.push(p);
    }
    n.push(a.type.createChecked(a.attrs, i, a.marks));
  }
  return e.type.createChecked(
    e.attrs,
    n,
    e.marks
  );
}, ie = (e) => {
  const t = g.get(e), n = [];
  for (let o = 0; o < t.height; o++) {
    const l = [], r = {};
    for (let a = 0; a < t.width; a++) {
      const i = t.map[o * t.width + a], c = e.nodeAt(i), m = t.findCell(i);
      if (r[i] || m.top !== o) {
        l.push(null);
        continue;
      }
      r[i] = !0, l.push(c);
    }
    n.push(l);
  }
  return n;
}, de = (e, t, n, o) => {
  const l = t[0] > n[0] ? -1 : 1, r = e.splice(t[0], t.length), a = r.length % 2 === 0 ? 1 : 0;
  let i;
  return o === -1 && l === 1 ? i = n[0] - 1 : o === 1 && l === -1 ? i = n[n.length - 1] - a + 1 : i = l === -1 ? n[0] : n[n.length - 1] - a, e.splice(i, 0, ...r), e;
}, Ye = (e, t, n, o) => {
  let l = U(ie(e.node));
  return l = de(l, t, n, o), l = U(l), ce(e.node, l);
}, et = (e, t, n, o) => {
  let l = ie(e.node);
  return l = de(l, t, n, o), ce(e.node, l);
}, X = (e, t) => {
  let n = e, o = e;
  for (let s = e; s >= 0; s--) {
    const u = b(s, t.selection);
    u && u.forEach((p) => {
      const f = p.node.attrs.colspan + s - 1;
      f >= n && (n = s), f > o && (o = f);
    });
  }
  for (let s = e; s <= o; s++) {
    const u = b(s, t.selection);
    u && u.forEach((p) => {
      const f = p.node.attrs.colspan + s - 1;
      p.node.attrs.colspan > 1 && f > o && (o = f);
    });
  }
  const l = [];
  for (let s = n; s <= o; s++) {
    const u = b(s, t.selection);
    u && u.length && l.push(s);
  }
  n = l[0], o = l[l.length - 1];
  const r = b(n, t.selection), a = C(0, t.selection), i = t.doc.resolve(
    r[r.length - 1].pos
  );
  let c;
  for (let s = o; s >= n; s--) {
    const u = b(s, t.selection);
    if (u && u.length) {
      for (let p = a.length - 1; p >= 0; p--)
        if (a[p].pos === u[0].pos) {
          c = u[0];
          break;
        }
      if (c)
        break;
    }
  }
  const m = t.doc.resolve(c.pos);
  return { $anchor: i, $head: m, indexes: l };
}, q = (e, t) => {
  let n = e, o = e;
  for (let s = e; s >= 0; s--)
    C(s, t.selection).forEach((p) => {
      const f = p.node.attrs.rowspan + s - 1;
      f >= n && (n = s), f > o && (o = f);
    });
  for (let s = e; s <= o; s++)
    C(s, t.selection).forEach((p) => {
      const f = p.node.attrs.rowspan + s - 1;
      p.node.attrs.rowspan > 1 && f > o && (o = f);
    });
  const l = [];
  for (let s = n; s <= o; s++) {
    const u = C(s, t.selection);
    u && u.length && l.push(s);
  }
  n = l[0], o = l[l.length - 1];
  const r = C(n, t.selection), a = b(0, t.selection), i = t.doc.resolve(r[r.length - 1].pos);
  let c;
  for (let s = o; s >= n; s--) {
    const u = C(s, t.selection);
    if (u && u.length) {
      for (let p = a.length - 1; p >= 0; p--)
        if (a[p].pos === u[0].pos) {
          c = u[0];
          break;
        }
      if (c)
        break;
    }
  }
  const m = t.doc.resolve(c.pos);
  return { $anchor: i, $head: m, indexes: l };
};
function tt(e, t, n, o = !0) {
  const l = w(e.selection);
  if (!l)
    return e;
  const { indexes: r } = X(t, e), { indexes: a } = X(n, e);
  if (r.includes(n))
    return e;
  const i = Ye(
    l,
    r,
    a,
    0
  ), c = A(e).replaceWith(
    l.pos,
    l.pos + l.node.nodeSize,
    i
  );
  if (!o)
    return c;
  const m = g.get(i), s = l.start, u = n, p = m.positionAt(m.height - 1, u, i), f = c.doc.resolve(s + p), $ = y.colSelection, _ = m.positionAt(0, u, i), P = c.doc.resolve(s + _);
  return c.setSelection($(f, P));
}
function ot(e, t, n, o = !0) {
  const l = w(e.selection);
  if (!l)
    return e;
  const { indexes: r } = q(t, e), { indexes: a } = q(n, e);
  if (r.includes(n))
    return e;
  const i = et(
    l,
    r,
    a,
    0
  ), c = A(e).replaceWith(
    l.pos,
    l.pos + l.node.nodeSize,
    i
  );
  if (!o)
    return c;
  const m = g.get(i), s = l.start, u = n, p = m.positionAt(u, m.width - 1, i), f = c.doc.resolve(s + p), $ = y.rowSelection, _ = m.positionAt(u, 0, i), P = c.doc.resolve(s + _);
  return c.setSelection($(f, P));
}
const v = Be({
  tableGroup: "block",
  cellContent: "paragraph",
  cellAttributes: {
    alignment: {
      default: "left",
      getFromDOM: (e) => e.style.textAlign || "left",
      setDOMAttr: (e, t) => {
        t.style = `text-align: ${e || "left"}`;
      }
    }
  }
}), T = k("table", () => ({
  ...v.table,
  parseMarkdown: {
    match: (e) => e.type === "table",
    runner: (e, t, n) => {
      const o = t.align, l = t.children.map((r, a) => ({
        ...r,
        align: o,
        isHeader: a === 0
      }));
      e.openNode(n), e.next(l), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "table",
    runner: (e, t) => {
      var l;
      const n = (l = t.content.firstChild) == null ? void 0 : l.content;
      if (!n)
        return;
      const o = [];
      n.forEach((r) => {
        o.push(r.attrs.alignment);
      }), e.openNode("table", void 0, { align: o }), e.next(t.content), e.closeNode();
    }
  }
}));
d(T.node, {
  displayName: "NodeSchema<table>",
  group: "Table"
});
d(T.ctx, {
  displayName: "NodeSchemaCtx<table>",
  group: "Table"
});
const S = k("table_row", () => ({
  ...v.table_row,
  parseMarkdown: {
    match: (e) => e.type === "tableRow",
    runner: (e, t, n) => {
      const o = t.align, l = t.children.map((r, a) => ({
        ...r,
        align: o[a],
        isHeader: t.isHeader
      }));
      e.openNode(n), e.next(l), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "table_row",
    runner: (e, t) => {
      e.openNode("tableRow"), e.next(t.content), e.closeNode();
    }
  }
}));
d(S.node, {
  displayName: "NodeSchema<tableRow>",
  group: "Table"
});
d(S.ctx, {
  displayName: "NodeSchemaCtx<tableRow>",
  group: "Table"
});
const R = k("table_cell", () => ({
  ...v.table_cell,
  parseMarkdown: {
    match: (e) => e.type === "tableCell" && !e.isHeader,
    runner: (e, t, n) => {
      const o = t.align;
      e.openNode(n, { alignment: o }).openNode(e.schema.nodes.paragraph).next(t.children).closeNode().closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "table_cell",
    runner: (e, t) => {
      e.openNode("tableCell").next(t.content).closeNode();
    }
  }
}));
d(R.node, {
  displayName: "NodeSchema<tableCell>",
  group: "Table"
});
d(R.ctx, {
  displayName: "NodeSchemaCtx<tableCell>",
  group: "Table"
});
const I = k("table_header", () => ({
  ...v.table_header,
  parseMarkdown: {
    match: (e) => e.type === "tableCell" && !!e.isHeader,
    runner: (e, t, n) => {
      const o = t.align;
      e.openNode(n, { alignment: o }), e.openNode(e.schema.nodes.paragraph), e.next(t.children), e.closeNode(), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "table_header",
    runner: (e, t) => {
      e.openNode("tableCell"), e.next(t.content), e.closeNode();
    }
  }
}));
d(I.node, {
  displayName: "NodeSchema<tableHeader>",
  group: "Table"
});
d(I.ctx, {
  displayName: "NodeSchemaCtx<tableHeader>",
  group: "Table"
});
const me = te(() => new Y(
  /^\|(?<col>\d+)[xX](?<row>\d+)\|\s$/,
  (e, t, n, o) => {
    var i, c;
    const l = e.doc.resolve(n);
    if (!l.node(-1).canReplaceWith(l.index(-1), l.indexAfter(-1), T.type()))
      return null;
    const r = re(
      Number((i = t.groups) == null ? void 0 : i.row),
      Number((c = t.groups) == null ? void 0 : c.col)
    ), a = e.tr.replaceRangeWith(n, o, r).scrollIntoView();
    return a.setSelection(Ee.create(a.doc, n + 3));
  }
));
d(me, {
  displayName: "InputRule<insertTableInputRule>",
  group: "Table"
});
const F = h("GoToPrevTableCell", () => () => ne(-1));
d(F, {
  displayName: "Command<goToPrevTableCellCommand>",
  group: "Table"
});
const W = h("GoToNextTableCell", () => () => ne(1));
d(W, {
  displayName: "Command<goToNextTableCellCommand>",
  group: "Table"
});
const z = h("BreakTable", () => () => (e, t) => {
  if (!N(e))
    return !1;
  const { $head: n } = e.selection, o = n.after(), l = e.tr.replaceWith(o, o, Q.type().createAndFill());
  return l.setSelection(oe.near(l.doc.resolve(o), 1)).scrollIntoView(), t == null || t(l), !0;
});
d(z, {
  displayName: "Command<breakTableCommand>",
  group: "Table"
});
const ue = h("InsertTable", () => ({ row: e, col: t } = {}) => (n, o) => {
  const { selection: l, tr: r } = n, { from: a } = l, i = re(e, t), c = r.replaceSelectionWith(i), m = oe.findFrom(c.doc.resolve(a), 1, !0);
  return m && (o == null || o(c.setSelection(m))), !0;
});
d(ue, {
  displayName: "Command<insertTableCommand>",
  group: "Table"
});
const pe = h("MoveRow", () => ({ from: e, to: t } = {}) => (n, o) => {
  const { tr: l } = n;
  return !!(o == null ? void 0 : o(ot(l, e ?? 0, t ?? 0, !0)));
});
d(pe, {
  displayName: "Command<moveRowCommand>",
  group: "Table"
});
const fe = h("MoveCol", () => ({ from: e, to: t } = {}) => (n, o) => {
  const { tr: l } = n;
  return !!(o == null ? void 0 : o(tt(l, e ?? 0, t ?? 0, !0)));
});
d(fe, {
  displayName: "Command<moveColCommand>",
  group: "Table"
});
const he = h("SelectRow", () => (e = 0) => (t, n) => {
  const { tr: o } = t;
  return !!(n == null ? void 0 : n(Je(e)(o)));
});
d(he, {
  displayName: "Command<selectRowCommand>",
  group: "Table"
});
const ge = h("SelectCol", () => (e = 0) => (t, n) => {
  const { tr: o } = t;
  return !!(n == null ? void 0 : n(Qe(e)(o)));
});
d(ge, {
  displayName: "Command<selectColCommand>",
  group: "Table"
});
const be = h("SelectTable", () => () => (e, t) => {
  const { tr: n } = e;
  return !!(t == null ? void 0 : t(qe(n)));
});
d(be, {
  displayName: "Command<selectTableCommand>",
  group: "Table"
});
const Ce = h("DeleteSelectedCells", () => () => (e, t) => {
  const { selection: n } = e;
  if (!(n instanceof y))
    return !1;
  const o = n.isRowSelection(), l = n.isColSelection();
  return o && l ? Ke(e, t) : l ? He(e, t) : Le(e, t);
});
d(Ce, {
  displayName: "Command<deleteSelectedCellsCommand>",
  group: "Table"
});
const ye = h("AddColBefore", () => () => Fe);
d(ye, {
  displayName: "Command<addColBeforeCommand>",
  group: "Table"
});
const ke = h("AddColAfter", () => () => We);
d(ke, {
  displayName: "Command<addColAfterCommand>",
  group: "Table"
});
const we = h("AddRowBefore", () => () => (e, t) => {
  if (!N(e))
    return !1;
  if (t) {
    const n = le(e);
    t(ae(e.tr, n, n.top));
  }
  return !0;
});
d(we, {
  displayName: "Command<addRowBeforeCommand>",
  group: "Table"
});
const Ne = h("AddRowAfter", () => () => (e, t) => {
  if (!N(e))
    return !1;
  if (t) {
    const n = le(e);
    t(ae(e.tr, n, n.bottom));
  }
  return !0;
});
d(Ne, {
  displayName: "Command<addRowAfterCommand>",
  group: "Table"
});
const Te = h("SetAlign", () => (e = "left") => ze("alignment", e));
d(Te, {
  displayName: "Command<setAlignCommand>",
  group: "Table"
});
const G = ee("tableKeymap", {
  NextCell: {
    shortcuts: ["Mod-]", "Tab"],
    command: (e) => {
      const t = e.get(M);
      return () => t.call(W.key);
    }
  },
  PrevCell: {
    shortcuts: ["Mod-[", "Shift-Tab"],
    command: (e) => {
      const t = e.get(M);
      return () => t.call(F.key);
    }
  },
  ExitTable: {
    shortcuts: ["Mod-Enter"],
    command: (e) => {
      const t = e.get(M);
      return () => t.call(z.key);
    }
  }
});
d(G.ctx, {
  displayName: "KeymapCtx<table>",
  group: "Table"
});
d(G.shortcuts, {
  displayName: "Keymap<table>",
  group: "Table"
});
const E = "footnote_definition", J = "footnoteDefinition", j = k("footnote_definition", () => ({
  group: "block",
  content: "block+",
  defining: !0,
  attrs: {
    label: {
      default: ""
    }
  },
  parseDOM: [
    {
      tag: `dl[data-type="${E}"]`,
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw O(e);
        return {
          label: e.dataset.label
        };
      },
      contentElement: "dd"
    }
  ],
  toDOM: (e) => {
    const t = e.attrs.label;
    return [
      "dl",
      {
        // TODO: add a prosemirror plugin to sync label on change
        "data-label": t,
        "data-type": E
      },
      ["dt", t],
      ["dd", 0]
    ];
  },
  parseMarkdown: {
    match: ({ type: e }) => e === J,
    runner: (e, t, n) => {
      e.openNode(n, {
        label: t.label
      }).next(t.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === E,
    runner: (e, t) => {
      e.openNode(J, void 0, {
        label: t.attrs.label,
        identifier: t.attrs.label
      }).next(t.content).closeNode();
    }
  }
}));
d(j.ctx, {
  displayName: "NodeSchemaCtx<footnodeDef>",
  group: "footnote"
});
d(j.node, {
  displayName: "NodeSchema<footnodeDef>",
  group: "footnote"
});
const D = "footnote_reference", Z = k("footnote_reference", () => ({
  group: "inline",
  inline: !0,
  atom: !0,
  attrs: {
    label: {
      default: ""
    }
  },
  parseDOM: [
    {
      tag: `sup[data-type="${D}"]`,
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw O(e);
        return {
          label: e.dataset.label
        };
      }
    }
  ],
  toDOM: (e) => {
    const t = e.attrs.label;
    return [
      "sup",
      {
        // TODO: add a prosemirror plugin to sync label on change
        "data-label": t,
        "data-type": D
      },
      t
    ];
  },
  parseMarkdown: {
    match: ({ type: e }) => e === "footnoteReference",
    runner: (e, t, n) => {
      e.addNode(n, {
        label: t.label
      });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === D,
    runner: (e, t) => {
      e.addNode("footnoteReference", void 0, void 0, {
        label: t.attrs.label,
        identifier: t.attrs.label
      });
    }
  }
}));
d(Z.ctx, {
  displayName: "NodeSchemaCtx<footnodeRef>",
  group: "footnote"
});
d(Z.node, {
  displayName: "NodeSchema<footnodeRef>",
  group: "footnote"
});
const Se = Ie.extendSchema((e) => (t) => {
  const n = e(t);
  return {
    ...n,
    attrs: {
      ...n.attrs,
      checked: {
        default: null
      }
    },
    parseDOM: [
      {
        tag: 'li[data-item-type="task"]',
        getAttrs: (o) => {
          if (!(o instanceof HTMLElement))
            throw O(o);
          return {
            label: o.dataset.label,
            listType: o.dataset["list-type"],
            spread: o.dataset.spread,
            checked: o.dataset.checked ? o.dataset.checked === "true" : null
          };
        }
      },
      ...(n == null ? void 0 : n.parseDOM) || []
    ],
    toDOM: (o) => n.toDOM && o.attrs.checked == null ? n.toDOM(o) : [
      "li",
      {
        "data-item-type": "task",
        "data-label": o.attrs.label,
        "data-list-type": o.attrs.listType,
        "data-spread": o.attrs.spread,
        "data-checked": o.attrs.checked
      },
      0
    ],
    parseMarkdown: {
      match: ({ type: o }) => o === "listItem",
      runner: (o, l, r) => {
        if (l.checked == null) {
          n.parseMarkdown.runner(o, l, r);
          return;
        }
        const a = l.label != null ? `${l.label}.` : "•", i = l.checked != null ? !!l.checked : null, c = l.label != null ? "ordered" : "bullet", m = l.spread != null ? `${l.spread}` : "true";
        o.openNode(r, { label: a, listType: c, spread: m, checked: i }), o.next(l.children), o.closeNode();
      }
    },
    toMarkdown: {
      match: (o) => o.type.name === "list_item",
      runner: (o, l) => {
        if (l.attrs.checked == null) {
          n.toMarkdown.runner(o, l);
          return;
        }
        const r = l.attrs.label, a = l.attrs.listType, i = l.attrs.spread === "true", c = l.attrs.checked;
        o.openNode("listItem", void 0, { label: r, listType: a, spread: i, checked: c }), o.next(l.content), o.closeNode();
      }
    }
  };
});
d(Se, {
  displayName: "NodeSchema<listItem>",
  group: "ListItem"
});
const Re = te(() => new Y(/^\[(?<checked>\s|x)\]\s$/, (e, t, n, o) => {
  var s;
  const l = e.doc.resolve(n);
  let r = 0, a = l.node(r);
  for (; a && a.type.name !== "list_item"; )
    r--, a = l.node(r);
  if (!a || a.attrs.checked != null)
    return null;
  const i = ((s = t.groups) == null ? void 0 : s.checked) === "x", c = l.before(r), m = e.tr;
  return m.deleteRange(n, o).setNodeMarkup(c, void 0, { ...a.attrs, checked: i }), m;
}));
d(Re, {
  displayName: "InputRule<wrapInTaskListInputRule>",
  group: "ListItem"
});
const nt = [
  L,
  G
].flat(), lt = [
  me,
  Re
], Me = B(() => {
  const e = new De("MILKDOWN_AUTO_INSERT_ZERO_SPACE"), t = (o) => o.type === Q.type(), n = (o) => t(o) && o.nodeSize === 2;
  return new Oe({
    key: e,
    props: {
      handleDOMEvents: {
        compositionstart(o) {
          const { state: l, dispatch: r } = o, { tr: a, selection: i } = l, { $from: c } = i;
          return V.safari && N(l) && i.empty && n(c.parent) && r(a.insertText("⁠", c.start())), !1;
        },
        compositionend(o) {
          const { state: l, dispatch: r } = o, { tr: a, selection: i } = l, { $from: c } = i;
          return V.safari && N(l) && i.empty && t(c.parent) && c.parent.textContent.startsWith("⁠") && r(a.delete(c.start(), c.start() + 1)), !1;
        }
      }
    }
  });
});
d(Me, {
  displayName: "Prose<autoInsertZeroSpaceInTablePlugin>",
  group: "Prose"
});
const Ae = B(() => Ge({}));
d(Ae, {
  displayName: "Prose<columnResizingPlugin>",
  group: "Prose"
});
const xe = B(() => je());
d(xe, {
  displayName: "Prose<tableEditingPlugin>",
  group: "Prose"
});
const ve = Pe(() => Ue);
d(ve, {
  displayName: "Remark<remarkGFMPlugin>",
  group: "Remark"
});
const rt = [
  Me,
  Ae,
  xe,
  ve
], at = [
  Se,
  T,
  S,
  I,
  R,
  j,
  Z,
  K,
  x
].flat(), st = [
  W,
  F,
  z,
  ue,
  pe,
  fe,
  he,
  ge,
  be,
  Ce,
  we,
  Ne,
  ye,
  ke,
  Te,
  H
], bt = [at, lt, nt, rt, st].flat();
export {
  ke as addColAfterCommand,
  ye as addColBeforeCommand,
  Ne as addRowAfterCommand,
  we as addRowBeforeCommand,
  ae as addRowWithAlignment,
  z as breakTableCommand,
  st as commands,
  re as createTable,
  Ce as deleteSelectedCellsCommand,
  Se as extendListItemSchemaForTask,
  w as findTable,
  j as footnoteDefinitionSchema,
  Z as footnoteReferenceSchema,
  Xe as getAllCellsInTable,
  b as getCellsInCol,
  C as getCellsInRow,
  bt as gfm,
  W as goToNextTableCellCommand,
  F as goToPrevTableCellCommand,
  lt as inputrules,
  ue as insertTableCommand,
  me as insertTableInputRule,
  nt as keymap,
  tt as moveCol,
  fe as moveColCommand,
  ot as moveRow,
  pe as moveRowCommand,
  rt as plugins,
  at as schema,
  Qe as selectCol,
  ge as selectColCommand,
  se as selectLine,
  Je as selectRow,
  he as selectRowCommand,
  qe as selectTable,
  be as selectTableCommand,
  Te as setAlignCommand,
  K as strikethroughAttr,
  L as strikethroughKeymap,
  x as strikethroughSchema,
  R as tableCellSchema,
  I as tableHeaderSchema,
  G as tableKeymap,
  S as tableRowSchema,
  T as tableSchema,
  H as toggleStrikethroughCommand,
  Re as wrapInTaskListInputRule
};
//# sourceMappingURL=index.es.js.map
