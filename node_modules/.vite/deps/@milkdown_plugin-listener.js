import {
  $,
  H,
  I,
  M2 as M,
  Plugin,
  PluginKey,
  ne,
  te
} from "./chunk-PGYOUZVG.js";
import "./chunk-OH6XO3AQ.js";
import "./chunk-EUBN2JYL.js";
import "./chunk-XYELZ2OI.js";
import "./chunk-FHNZSWKF.js";
import "./chunk-C3ENBVE7.js";
import "./chunk-X4UWMFBO.js";
import "./chunk-3Y3KLNDE.js";
import "./chunk-UBFJWHA5.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AC2VUBZ6.js";

// node_modules/.pnpm/lodash.debounce@4.0.8/node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/.pnpm/lodash.debounce@4.0.8/node_modules/lodash.debounce/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = debounce;
  }
});

// node_modules/.pnpm/@milkdown+plugin-listener@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+prose@7.2._xqr4jnnwidqyjqao44kvztr6ru/node_modules/@milkdown/plugin-listener/lib/index.es.js
var import_lodash = __toESM(require_lodash());
var u = class {
  constructor() {
    this.beforeMountedListeners = [], this.mountedListeners = [], this.updatedListeners = [], this.markdownUpdatedListeners = [], this.blurListeners = [], this.focusListeners = [], this.destroyListeners = [], this.beforeMount = (t) => (this.beforeMountedListeners.push(t), this), this.mounted = (t) => (this.mountedListeners.push(t), this), this.updated = (t) => (this.updatedListeners.push(t), this);
  }
  /// A getter to get all [subscribers](#interface-subscribers). You should not use this method directly.
  get listeners() {
    return {
      beforeMount: this.beforeMountedListeners,
      mounted: this.mountedListeners,
      updated: this.updatedListeners,
      markdownUpdated: this.markdownUpdatedListeners,
      blur: this.blurListeners,
      focus: this.focusListeners,
      destroy: this.destroyListeners
    };
  }
  /// Subscribe to the markdownUpdated event.
  /// This event will be triggered after the editor state is updated and **the document is changed**.
  /// The second parameter is the current markdown and the third parameter is the previous markdown.
  markdownUpdated(t) {
    return this.markdownUpdatedListeners.push(t), this;
  }
  /// Subscribe to the blur event.
  /// This event will be triggered when the editor is blurred.
  blur(t) {
    return this.blurListeners.push(t), this;
  }
  /// Subscribe to the focus event.
  /// This event will be triggered when the editor is focused.
  focus(t) {
    return this.focusListeners.push(t), this;
  }
  /// Subscribe to the destroy event.
  /// This event will be triggered before the editor is destroyed.
  destroy(t) {
    return this.destroyListeners.push(t), this;
  }
};
var a = H(new u(), "listener");
var E = new PluginKey("MILKDOWN_LISTENER");
var M2 = (e) => (e.inject(a, new u()), async () => {
  await e.wait(I);
  const t = e.get(a), { listeners: r } = t;
  r.beforeMount.forEach((s) => s(e)), await e.wait($);
  const h = e.get(te);
  let n = null, d = null;
  const l = new Plugin({
    key: E,
    view: () => ({
      destroy: () => {
        r.destroy.forEach((s) => s(e));
      }
    }),
    props: {
      handleDOMEvents: {
        focus: () => (r.focus.forEach((s) => s(e)), false),
        blur: () => (r.blur.forEach((s) => s(e)), false)
      }
    },
    state: {
      init: () => {
      },
      apply: (s) => !s.docChanged || s.getMeta("addToHistory") === false ? void 0 : (0, import_lodash.default)(() => {
        const { doc: i } = s;
        if (r.updated.length > 0 && (n == null || !n.eq(i)) && r.updated.forEach((o) => {
          o(e, i, n);
        }), r.markdownUpdated.length > 0 && (n == null || !n.eq(i))) {
          const o = h(i);
          r.markdownUpdated.forEach((p) => {
            p(e, o, d);
          }), d = o;
        }
        n = i;
      }, 200)()
    }
  });
  e.update(M, (s) => s.concat(l)), await e.wait(ne), r.mounted.forEach((s) => s(e));
});
M2.meta = {
  package: "@milkdown/plugin-listener",
  displayName: "Listener"
};
export {
  u as ListenerManager,
  E as key,
  M2 as listener,
  a as listenerCtx
};
//# sourceMappingURL=@milkdown_plugin-listener.js.map
