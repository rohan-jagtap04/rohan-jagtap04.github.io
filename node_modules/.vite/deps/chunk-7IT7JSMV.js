import {
  H,
  I,
  M,
  M2,
  P,
  R,
  X,
  Z,
  jt,
  keymap,
  me,
  pe,
  x,
  ye
} from "./chunk-PGYOUZVG.js";

// node_modules/.pnpm/nanoid@4.0.2/node_modules/nanoid/index.browser.js
var random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
var customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  let step = -~(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let j = step;
      while (j--) {
        id += alphabet[bytes[j] & mask] || "";
        if (id.length === size)
          return id;
      }
    }
  };
};
var customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);

// node_modules/.pnpm/@milkdown+utils@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+prose@7.2.3_@milkdown+transformer@7.2.3/node_modules/@milkdown/utils/lib/index.es.js
var G = customAlphabet("abcedfghicklmn", 10);
var ne = (t, s) => {
  const n = jt(t), r = (e) => async () => {
    r.key = n, await e.wait(P);
    const a = s(e);
    return e.get(me).create(n, a), r.run = (o) => e.get(me).call(t, o), () => {
      e.get(me).remove(n);
    };
  };
  return r;
};
var ae = (t) => {
  const s = (n) => async () => {
    await n.wait(P);
    const r = t(n);
    return n.update(pe, (e) => [...e, r]), s.inputRule = r, () => {
      n.update(pe, (e) => e.filter((a) => a !== r));
    };
  };
  return s;
};
var J = (t, s) => {
  let n;
  const r = (e) => async () => {
    const a = s(e);
    if (e.update(Z, (o) => [...o.filter((i) => i[0] !== t), [t, a]]), r.id = t, r.schema = a, await e.wait(P), n = e.get(R).marks[t], !n)
      throw x(t);
    return () => {
      e.update(Z, (o) => o.filter(([i]) => i !== t));
    };
  };
  return r.type = () => n, r;
};
var Q = (t, s) => {
  let n;
  const r = (e) => async () => {
    const a = s(e);
    if (e.update(X, (o) => [...o.filter((i) => i[0] !== t), [t, a]]), r.id = t, r.schema = a, await e.wait(P), n = e.get(R).nodes[t], !n)
      throw M(t);
    return () => {
      e.update(X, (o) => o.filter(([i]) => i !== t));
    };
  };
  return r.type = () => n, r;
};
var ce = (t) => {
  let s;
  const n = (r) => async () => (await r.wait(P), s = t(r), r.update(M2, (e) => [...e, s]), () => {
    r.update(M2, (e) => e.filter((a) => a !== s));
  });
  return n.plugin = () => s, n.key = () => s.spec.key, n;
};
var me2 = (t) => {
  const s = (n) => async () => {
    await n.wait(I);
    const r = t(n);
    return n.update(ye, (e) => [...e, r]), s.plugin = r, () => {
      n.update(ye, (e) => e.filter((a) => a !== r));
    };
  };
  return s;
};
var W = (t) => {
  const s = (n) => async () => {
    await n.wait(P);
    const r = t(n), e = keymap(r);
    return n.update(M2, (a) => [...a, e]), s.keymap = r, () => {
      n.update(M2, (a) => a.filter((o) => o !== e));
    };
  };
  return s;
};
var S = (t, s) => {
  const n = H(t, s), r = (e) => (e.inject(n), () => () => {
    e.remove(n);
  });
  return r.key = n, r;
};
var we2 = (t, s) => {
  const n = S(s, t), r = Q(t, (a) => a.get(n.key)(a)), e = [n, r];
  return e.id = r.id, e.node = r, e.type = r.type, e.schema = r.schema, e.ctx = n, e.key = n.key, e.extendSchema = (a) => (o) => () => {
    const i = o.get(n.key), u = a(i)(o);
    o.update(X, (c) => [...c.filter((d) => d[0] !== t), [t, u]]), e.schema = u;
  }, e;
};
var ge = (t, s) => {
  const n = S(s, t), r = J(t, (a) => a.get(n.key)(a)), e = [n, r];
  return e.id = r.id, e.mark = r, e.type = r.type, e.schema = r.schema, e.ctx = n, e.key = n.key, e.extendSchema = (a) => (o) => () => {
    const i = o.get(n.key), u = a(i)(o);
    o.update(Z, (c) => [...c.filter((d) => d[0] !== t), [t, u]]), e.schema = u;
  }, e;
};
var fe2 = (t, s) => {
  const n = Object.fromEntries(Object.entries(s).map(([o, { shortcuts: i }]) => [o, i])), r = S(n, `${t}Keymap`), e = W((o) => {
    const i = o.get(r.key), m = Object.entries(s).flatMap(([u, { command: c }]) => [i[u]].flat().map((V) => [V, c(o)]));
    return Object.fromEntries(m);
  }), a = [r, e];
  return a.ctx = r, a.shortcuts = e, a.key = r.key, a.keymap = e.keymap, a;
};
var he = (t, s = () => ({})) => S(s, `${t}Attr`);
var ke = (t, s = () => ({})) => S(s, `${t}Attr`);
var Ee = (...t) => {
  const s = t.length;
  let n = s;
  for (; n--; )
    if (typeof t[n] != "function")
      throw new TypeError("Expected a function");
  return (...r) => {
    let e = 0, a = s ? t[e](...r) : r[0];
    for (; ++e < s; )
      a = t[e](a);
    return a;
  };
};

export {
  ne,
  ae,
  Q,
  ce,
  me2 as me,
  S,
  we2 as we,
  ge,
  fe2 as fe,
  he,
  ke,
  Ee
};
//# sourceMappingURL=chunk-7IT7JSMV.js.map
