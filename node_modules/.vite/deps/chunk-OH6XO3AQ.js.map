{
  "version": 3,
  "sources": ["../../.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js", "../../.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-bullet.js", "../../.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js", "../../.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/list-item.js", "../../.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/association.js", "../../.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js", "../../.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/container-flow.js", "../../.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js"],
  "sourcesContent": ["/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {patternCompile} from '../util/pattern-compile.js'\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'tab'\n\n  // To do: remove in a major.\n  // @ts-expect-error: deprecated.\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n", "/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n", "/**\n * @typedef {import('../types.js').AssociationId} AssociationId\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references don’t work in this\n * matching: `&copy;` does not match `©`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we’re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n", "/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n", "/**\n * @typedef {import('../types.js').FlowContent} FlowContent\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\n/**\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {Node} left\n * @param {Node} right\n * @param {Parent} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n", "/**\n * @typedef {import('../types.js').IndentLines} IndentLines\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n"],
  "mappings": ";;;;;;;;AAQA,WAAW,OAAO;AAQX,SAAS,WAAW,MAAM,GAAG,OAAO;AACzC,MAAI,QAAQ,KAAK,SAAS;AAC1B,MAAI,WAAW;AACf,MAAI,QAAQ;AAKZ,SAAO,IAAI,OAAO,aAAa,WAAW,UAAU,EAAE,KAAK,KAAK,GAAG;AACjE,gBAAY;AAAA,EACd;AAIA,MACE,WAAW,KAAK,KAAK,MACnB,WAAW,KAAK,KAAK,KAAK,WAAW,KAAK,KAAK,KAAM,QAAQ,KAAK,KAAK,IACzE;AACA,YAAQ,MAAM,QAAQ;AAAA,EACxB;AASA,SAAO,EAAE,QAAQ,MAAM,OAAO,QAAQ;AACpC,UAAM,UAAU,MAAM,OAAO,KAAK;AAClC,UAAM,aAAa,eAAe,OAAO;AAEzC,QAAI;AAKJ,QAAI,CAAC,QAAQ;AAAS;AAEtB,WAAQ,QAAQ,WAAW,KAAK,KAAK,GAAI;AACvC,UAAI,WAAW,MAAM;AAGrB,UACE,MAAM,WAAW,QAAQ,MAAM,MAC/B,MAAM,WAAW,WAAW,CAAC,MAAM,IACnC;AACA;AAAA,MACF;AAEA,cAAQ,MAAM,MAAM,GAAG,QAAQ,IAAI,MAAM,MAAM,MAAM,MAAM,QAAQ,CAAC;AAAA,IACtE;AAAA,EACF;AAEA,SAAO,WAAW,QAAQ;AAC5B;AAKA,SAAS,iBAAiB;AACxB,SAAO;AACT;;;ACrEO,SAAS,YAAY,OAAO;AACjC,QAAM,SAAS,MAAM,QAAQ,UAAU;AAEvC,MAAI,WAAW,OAAO,WAAW,OAAO,WAAW,KAAK;AACtD,UAAM,IAAI;AAAA,MACR,kCACE,SACA;AAAA,IACJ;AAAA,EACF;AAEA,SAAO;AACT;;;ACZO,SAAS,oBAAoB,OAAO;AACzC,QAAM,QAAQ,MAAM,QAAQ,kBAAkB;AAI9C,MAAI,UAAU,KAAK,UAAU,KAAK;AAChC,WAAO;AAAA,EACT;AAEA,MAAI,UAAU,SAAS,UAAU,SAAS,UAAU,SAAS;AAC3D,UAAM,IAAI;AAAA,MACR,kCACE,QACA;AAAA,IACJ;AAAA,EACF;AAEA,SAAO;AACT;;;ACTO,SAAS,SAAS,MAAM,QAAQ,OAAO,MAAM;AAClD,QAAM,iBAAiB,oBAAoB,KAAK;AAChD,MAAI,SAAS,MAAM,iBAAiB,YAAY,KAAK;AAGrD,MAAI,UAAU,OAAO,SAAS,UAAU,OAAO,SAAS;AACtD,cACG,OAAO,OAAO,UAAU,YAAY,OAAO,QAAQ,KAChD,OAAO,QACP,MACH,MAAM,QAAQ,wBAAwB,QACnC,IACA,OAAO,SAAS,QAAQ,IAAI,KAChC;AAAA,EACJ;AAEA,MAAI,OAAO,OAAO,SAAS;AAE3B,MACE,mBAAmB,SAClB,mBAAmB,YAChB,UAAU,OAAO,SAAS,UAAU,OAAO,UAAW,KAAK,SAC/D;AACA,WAAO,KAAK,KAAK,OAAO,CAAC,IAAI;AAAA,EAC/B;AAEA,QAAM,UAAU,MAAM,cAAc,IAAI;AACxC,UAAQ,KAAK,SAAS,IAAI,OAAO,OAAO,OAAO,MAAM,CAAC;AACtD,UAAQ,MAAM,IAAI;AAClB,QAAM,OAAO,MAAM,MAAM,UAAU;AACnC,QAAM,QAAQ,MAAM;AAAA,IAClB,MAAM,cAAc,MAAM,QAAQ,QAAQ,CAAC;AAAA,IAC3C;AAAA,EACF;AACA,OAAK;AAEL,SAAO;AAGP,WAAS,IAAI,MAAM,OAAO,OAAO;AAC/B,QAAI,OAAO;AACT,cAAQ,QAAQ,KAAK,IAAI,OAAO,IAAI,KAAK;AAAA,IAC3C;AAEA,YAAQ,QAAQ,SAAS,SAAS,IAAI,OAAO,OAAO,OAAO,MAAM,KAAK;AAAA,EACxE;AACF;;;ACtCO,SAAS,YAAY,MAAM;AAChC,MAAI,KAAK,SAAS,CAAC,KAAK,YAAY;AAClC,WAAO,KAAK,SAAS;AAAA,EACvB;AAEA,SAAO,aAAa,KAAK,UAAU;AACrC;;;ACVO,SAAS,kBAAkB,QAAQ,OAAO,MAAM;AACrD,QAAM,aAAa,MAAM;AACzB,QAAM,WAAW,OAAO,YAAY,CAAC;AAErC,QAAM,UAAU,CAAC;AACjB,MAAI,QAAQ;AACZ,MAAI,SAAS,KAAK;AAElB,aAAW,KAAK,EAAE;AAClB,MAAI,UAAU,MAAM,cAAc,IAAI;AAEtC,SAAO,EAAE,QAAQ,SAAS,QAAQ;AAChC,UAAM,QAAQ,SAAS,KAAK;AAE5B,QAAI;AAEJ,eAAW,WAAW,SAAS,CAAC,IAAI;AAEpC,QAAI,QAAQ,IAAI,SAAS,QAAQ;AAG/B,UAAI,SAAS,MAAM,OAAO,SAAS,SAAS,QAAQ,CAAC,EAAE,IAAI;AAG3D,UAAI,UAAU,OAAO;AAAM,iBAAS,OAAO;AAC3C,cAAQ,SACJ,OAAO,SAAS,QAAQ,CAAC,GAAG,QAAQ,OAAO;AAAA,QACzC,QAAQ;AAAA,QACR,OAAO;AAAA,QACP,GAAG,QAAQ,QAAQ;AAAA,MACrB,CAAC,EAAE,OAAO,CAAC,IACX;AAAA,IACN,OAAO;AACL,cAAQ,KAAK;AAAA,IACf;AAQA,QACE,QAAQ,SAAS,MAChB,WAAW,QAAQ,WAAW,SAC/B,MAAM,SAAS,QACf;AACA,cAAQ,QAAQ,SAAS,CAAC,IAAI,QAAQ,QAAQ,SAAS,CAAC,EAAE;AAAA,QACxD;AAAA,QACA;AAAA,MACF;AACA,eAAS;AAGT,gBAAU,MAAM,cAAc,IAAI;AAClC,cAAQ,KAAK,QAAQ,KAAK,EAAE,CAAC;AAAA,IAC/B;AAEA,YAAQ;AAAA,MACN,QAAQ;AAAA,QACN,MAAM,OAAO,OAAO,QAAQ,OAAO;AAAA,UACjC,GAAG,QAAQ,QAAQ;AAAA,UACnB;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAEA,aAAS,QAAQ,QAAQ,SAAS,CAAC,EAAE,MAAM,EAAE;AAAA,EAC/C;AAEA,aAAW,IAAI;AAEf,SAAO,QAAQ,KAAK,EAAE;AACxB;;;AC9EO,SAAS,cAAc,QAAQ,OAAO,MAAM;AACjD,QAAM,aAAa,MAAM;AACzB,QAAM,WAAW,OAAO,YAAY,CAAC;AACrC,QAAM,UAAU,MAAM,cAAc,IAAI;AAExC,QAAM,UAAU,CAAC;AACjB,MAAI,QAAQ;AAEZ,aAAW,KAAK,EAAE;AAElB,SAAO,EAAE,QAAQ,SAAS,QAAQ;AAChC,UAAM,QAAQ,SAAS,KAAK;AAE5B,eAAW,WAAW,SAAS,CAAC,IAAI;AAEpC,YAAQ;AAAA,MACN,QAAQ;AAAA,QACN,MAAM,OAAO,OAAO,QAAQ,OAAO;AAAA,UACjC,QAAQ;AAAA,UACR,OAAO;AAAA,UACP,GAAG,QAAQ,QAAQ;AAAA,QACrB,CAAC;AAAA,MACH;AAAA,IACF;AAEA,QAAI,MAAM,SAAS,QAAQ;AACzB,YAAM,iBAAiB;AAAA,IACzB;AAEA,QAAI,QAAQ,SAAS,SAAS,GAAG;AAC/B,cAAQ;AAAA,QACN,QAAQ,KAAK,QAAQ,OAAO,SAAS,QAAQ,CAAC,GAAG,QAAQ,KAAK,CAAC;AAAA,MACjE;AAAA,IACF;AAAA,EACF;AAEA,aAAW,IAAI;AAEf,SAAO,QAAQ,KAAK,EAAE;AACxB;AASA,SAAS,QAAQ,MAAM,OAAO,QAAQ,OAAO;AAC3C,MAAI,QAAQ,MAAM,KAAK;AAEvB,SAAO,SAAS;AACd,UAAM,SAAS,MAAM,KAAK,KAAK,EAAE,MAAM,OAAO,QAAQ,KAAK;AAE3D,QAAI,WAAW,QAAQ,WAAW,GAAG;AACnC;AAAA,IACF;AAEA,QAAI,OAAO,WAAW,UAAU;AAC9B,aAAO,KAAK,OAAO,IAAI,MAAM;AAAA,IAC/B;AAEA,QAAI,WAAW,OAAO;AACpB,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;;;AClFA,IAAM,MAAM;AAKL,SAAS,YAAY,OAAO,KAAK;AAEtC,QAAM,SAAS,CAAC;AAChB,MAAI,QAAQ;AACZ,MAAI,OAAO;AAEX,MAAI;AAEJ,SAAQ,QAAQ,IAAI,KAAK,KAAK,GAAI;AAChC,QAAI,MAAM,MAAM,OAAO,MAAM,KAAK,CAAC;AACnC,WAAO,KAAK,MAAM,CAAC,CAAC;AACpB,YAAQ,MAAM,QAAQ,MAAM,CAAC,EAAE;AAC/B;AAAA,EACF;AAEA,MAAI,MAAM,MAAM,KAAK,CAAC;AAEtB,SAAO,OAAO,KAAK,EAAE;AAKrB,WAAS,IAAIA,QAAO;AAClB,WAAO,KAAK,IAAIA,QAAO,MAAM,CAACA,MAAK,CAAC;AAAA,EACtC;AACF;",
  "names": ["value"]
}
