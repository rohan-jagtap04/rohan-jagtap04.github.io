{"version":3,"file":"index.es.js","sources":["../src/composable/utils.ts","../src/composable/$command.ts","../src/composable/$inputRule.ts","../src/composable/$mark.ts","../src/composable/$node.ts","../src/composable/$prose.ts","../src/composable/$remark.ts","../src/composable/$shortcut.ts","../src/composable/$view.ts","../src/composable/$ctx.ts","../src/composable/composed/$node-schema.ts","../src/composable/composed/$mark-schema.ts","../src/composable/composed/$user-keymap.ts","../src/composable/composed/$attr.ts","../src/macro/call-command.ts","../src/macro/force-update.ts","../src/macro/get-html.ts","../src/macro/get-markdown.ts","../src/macro/insert.ts","../src/macro/outline.ts","../src/macro/replace-all.ts","../src/macro/set-attr.ts","../src/pipe.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nimport type { Cleanup, Ctx, MilkdownPlugin, SliceType, TimerType } from '@milkdown/ctx'\nimport { createTimer } from '@milkdown/ctx'\nimport { customAlphabet } from 'nanoid'\n\n/// @internal\nexport const nanoid = customAlphabet('abcedfghicklmn', 10)\n\n/// @internal\nexport type WithTimer<T> = T & { timer: TimerType }\n\n/// @internal\nexport const addTimer = <T extends MilkdownPlugin, PluginWithTimer extends T = WithTimer<T>>(\n  runner: (ctx: Ctx, plugin: PluginWithTimer, done: () => void) => Promise<void | Cleanup>,\n  injectTo: SliceType<TimerType[], string>,\n  timerName?: string,\n): PluginWithTimer => {\n  const timer = createTimer(timerName || nanoid())\n  let doneCalled = false\n\n  const plugin: MilkdownPlugin = (ctx) => {\n    ctx.record(timer)\n    ctx.update(injectTo, x => x.concat(timer))\n\n    return async () => {\n      const done = () => {\n        ctx.done(timer)\n        doneCalled = true\n      }\n\n      const cleanup = await runner(ctx, <PluginWithTimer>plugin, done)\n\n      if (!doneCalled)\n        ctx.done(timer)\n\n      return () => {\n        ctx.update(injectTo, x => x.filter(y => y !== timer))\n        ctx.clearTimer(timer)\n        cleanup?.()\n      }\n    }\n  };\n  (<T & { timer: TimerType }>plugin).timer = timer\n\n  return <PluginWithTimer>plugin\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Cmd, CmdKey } from '@milkdown/core'\nimport type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport { SchemaReady, commandsCtx, commandsTimerCtx, createCmdKey } from '@milkdown/core'\n\nimport { addTimer } from './utils'\n\n/// @internal\nexport type $Command<T> = MilkdownPlugin & {\n  run: (payload?: T) => boolean\n  key: CmdKey<T>\n}\n\n/// Create a command plugin. The command will be registered in the `commandsCtx` and can be called by other parts of the editor.\n/// It takes a key and a factory function. The factory function will be called when the plugin is created.\n/// The factory should return a function that will be called when the command is executed.\n/// The function should receive at **most one parameter**, which is the payload of the command.\n/// And the payload should always be **optional**.\n///\n/// ```ts\n/// import { setBlockType } from '@milkdown/prose/commands'\n///\n/// const commandPlugin = $command('SetAsHeading', (ctx) => {\n///   return (level = 1) => setBlockType(headingSchema.type(), { level });\n/// });\n/// ```\n///\n/// Additional property:\n/// - `key`: The key of the command.\n/// - `run`: The function to run the command.\n///\n/// You can use `callCommand` in `editor.action` to call the command.\n///\n/// ```ts\n/// import { callCommand } from '@milkdown/utils';\n/// const editor = Editor.make().use(/* some plugins */).use(commandPlugin).create();\n///\n/// editor.action(callCommand(commandPlugin.key, 3));\n/// ```\nexport const $command = <T, K extends string>(key: K, cmd: (ctx: Ctx) => Cmd<T>): $Command<T> => {\n  const cmdKey = createCmdKey<T>(key)\n\n  const plugin: MilkdownPlugin = ctx => async () => {\n    (<$Command<T>>plugin).key = cmdKey\n    await ctx.wait(SchemaReady)\n    const command = cmd(ctx)\n    ctx.get(commandsCtx).create(cmdKey, command);\n    (<$Command<T>>plugin).run = (payload?: T) => ctx.get(commandsCtx).call(key, payload)\n\n    return () => {\n      ctx.get(commandsCtx).remove(cmdKey)\n    }\n  }\n\n  return <$Command<T>>plugin\n}\n\n/// The async version for `$command`. You can use `await` in the factory when creating the command.\n/// ```ts\n/// const commandPlugin = $commandASync('LoadRemoteDoc', (ctx) => {\n///   return async (url = 'my-remote-api') => {\n///     const doc = await LoadRemoteDoc(url);\n///     return addDoc(doc);\n///   }\n/// });\n/// ```\n///\n/// Additional property:\n/// - `key`: The key of the command.\n/// - `run`: The function to run the command.\n/// - `timer`: The timer which will be resolved when the command is ready.\nexport const $commandAsync = <T, K extends string>(key: K, cmd: (ctx: Ctx) => Promise<Cmd<T>>, timerName?: string) => {\n  const cmdKey = createCmdKey<T>(key)\n  return addTimer<$Command<T>>(\n    async (ctx, plugin) => {\n      await ctx.wait(SchemaReady)\n      const command = await cmd(ctx)\n      ctx.get(commandsCtx).create(cmdKey, command);\n      (<$Command<T>>plugin).run = (payload?: T) => ctx.get(commandsCtx).call(key, payload);\n      (<$Command<T>>plugin).key = cmdKey\n      return () => {\n        ctx.get(commandsCtx).remove(cmdKey)\n      }\n    },\n    commandsTimerCtx,\n    timerName,\n  )\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport { SchemaReady, editorStateTimerCtx, inputRulesCtx } from '@milkdown/core'\nimport type { InputRule } from '@milkdown/prose/inputrules'\n\nimport { addTimer } from './utils'\n\n/// @internal\nexport type $InputRule = MilkdownPlugin & {\n  inputRule: InputRule\n}\n\n/// Create an input rule plugin.\n/// It takes a factory function which returns a [prosemirror input rule](https://prosemirror.net/docs/ref/#inputrules.InputRule).\n///\n/// Additional property:\n/// - `inputRule`: The prosemirror input rule created.\nexport const $inputRule = (inputRule: (ctx: Ctx) => InputRule): $InputRule => {\n  const plugin: MilkdownPlugin = ctx => async () => {\n    await ctx.wait(SchemaReady)\n    const ir = inputRule(ctx)\n    ctx.update(inputRulesCtx, irs => [...irs, ir]);\n    (<$InputRule>plugin).inputRule = ir\n\n    return () => {\n      ctx.update(inputRulesCtx, irs => irs.filter(x => x !== ir))\n    }\n  }\n\n  return <$InputRule>plugin\n}\n\n/// The async version for `$inputRule`. You can use `await` in the factory when creating the input rule.\n///\n/// Additional property:\n/// - `inputRule`: The prosemirror input rule created.\n/// - `timer`: The timer which will be resolved when the input rule is ready.\nexport const $inputRuleAsync = (inputRule: (ctx: Ctx) => Promise<InputRule>, timerName?: string) => {\n  return addTimer<$InputRule>(\n    async (ctx, plugin) => {\n      await ctx.wait(SchemaReady)\n      const ir = await inputRule(ctx)\n      ctx.update(inputRulesCtx, irs => [...irs, ir])\n      plugin.inputRule = ir\n      return () => {\n        ctx.update(inputRulesCtx, irs => irs.filter(x => x !== ir))\n      }\n    },\n    editorStateTimerCtx,\n    timerName,\n  )\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type {\n  Ctx,\n  MilkdownPlugin,\n} from '@milkdown/ctx'\nimport type { MarkSchema } from '@milkdown/transformer'\nimport {\n  SchemaReady,\n  marksCtx,\n  schemaCtx,\n  schemaTimerCtx,\n} from '@milkdown/core'\nimport { missingMarkInSchema } from '@milkdown/exception'\nimport type { MarkType } from '@milkdown/prose/model'\n\nimport { addTimer } from './utils'\n\n/// @internal\nexport type $Mark = MilkdownPlugin & {\n  id: string\n  schema: MarkSchema\n  type: () => MarkType\n}\n\n/// Create a mark plugin.\n/// It takes a mark id and a factory function.\n/// The factory should return a function that returns a [mark schema](/transformer#interface-markschema).\n///\n/// Additional property:\n/// - `id`: The id of the mark.\n/// - `schema`: The mark schema created.\n/// - `type`: A function that will return the [prosemirror mark type](https://prosemirror.net/docs/ref/#model.MarkType).\nexport const $mark = (id: string, schema: (ctx: Ctx) => MarkSchema): $Mark => {\n  let markType: MarkType | undefined\n  const plugin: MilkdownPlugin = ctx => async () => {\n    const markSchema = schema(ctx)\n    ctx.update(marksCtx, ns => [...ns.filter(n => n[0] !== id), [id, markSchema] as [string, MarkSchema]]);\n\n    (<$Mark>plugin).id = id;\n    (<$Mark>plugin).schema = markSchema\n\n    await ctx.wait(SchemaReady)\n\n    markType = ctx.get(schemaCtx).marks[id]\n    if (!markType)\n      throw missingMarkInSchema(id)\n\n    return () => {\n      ctx.update(marksCtx, ns => ns.filter(([x]) => x !== id))\n    }\n  }\n  (<$Mark>plugin).type = () => markType!\n\n  return <$Mark>plugin\n}\n\n/// The async version for `$mark`. You can use `await` in the factory when creating the mark schema.\n///\n/// Additional property:\n/// - `id`: The id of the mark.\n/// - `schema`: The mark schema created.\n/// - `type`: A function that will return the [prosemirror mark type](https://prosemirror.net/docs/ref/#model.MarkType).\n/// - `timer`: The timer which will be resolved when the mark schema is ready.\nexport const $markAsync = (id: string, schema: (ctx: Ctx) => Promise<MarkSchema>, timerName?: string) => {\n  let markType: MarkType | undefined\n  const plugin = addTimer<$Mark>(\n    async (ctx, plugin, done) => {\n      const markSchema = await schema(ctx)\n      ctx.update(marksCtx, ns => [...ns.filter(n => n[0] !== id), [id, markSchema] as [string, MarkSchema]])\n\n      plugin.id = id\n      plugin.schema = markSchema\n      done()\n\n      await ctx.wait(SchemaReady)\n\n      const markType = ctx.get(schemaCtx).marks[id]\n      if (!markType)\n        throw missingMarkInSchema(id)\n\n      return () => {\n        ctx.update(marksCtx, ns => ns.filter(([x]) => x !== id))\n      }\n    },\n    schemaTimerCtx,\n    timerName,\n  )\n  plugin.type = () => markType!\n\n  return plugin\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type {\n  Ctx,\n  MilkdownPlugin,\n} from '@milkdown/ctx'\nimport {\n  SchemaReady,\n  nodesCtx,\n  schemaCtx,\n  schemaTimerCtx,\n} from '@milkdown/core'\nimport { missingNodeInSchema } from '@milkdown/exception'\nimport type { NodeType } from '@milkdown/prose/model'\n\nimport type { NodeSchema } from '@milkdown/transformer'\nimport { addTimer } from './utils'\n\n/// @internal\nexport type $Node = MilkdownPlugin & {\n  id: string\n  schema: NodeSchema\n  type: () => NodeType\n}\n\n/// Create a node plugin.\n/// It takes a node id and a factory function.\n/// The factory should return a function that returns a [node schema](/transformer#interface-nodeschema).\n///\n/// Additional property:\n/// - `id`: The id of the node.\n/// - `schema`: The node schema created.\n/// - `type`: A function that will return the [prosemirror node type](https://prosemirror.net/docs/ref/#model.NodeType).\nexport const $node = (id: string, schema: (ctx: Ctx) => NodeSchema): $Node => {\n  let nodeType: NodeType | undefined\n  const plugin: MilkdownPlugin = ctx => async () => {\n    const nodeSchema = schema(ctx)\n    ctx.update(nodesCtx, ns => [...ns.filter(n => n[0] !== id), [id, nodeSchema] as [string, NodeSchema]]);\n\n    (<$Node>plugin).id = id;\n    (<$Node>plugin).schema = nodeSchema\n\n    await ctx.wait(SchemaReady)\n\n    nodeType = ctx.get(schemaCtx).nodes[id]\n    if (!nodeType)\n      throw missingNodeInSchema(id)\n\n    return () => {\n      ctx.update(nodesCtx, ns => ns.filter(([x]) => x !== id))\n    }\n  }\n  (<$Node>plugin).type = () => nodeType!\n\n  return <$Node>plugin\n}\n\n/// The async version for `$node`. You can use `await` in the factory when creating the node schema.\n///\n/// Additional property:\n/// - `id`: The id of the node.\n/// - `schema`: The node schema created.\n/// - `type`: A function that will return the [prosemirror node type](https://prosemirror.net/docs/ref/#model.NodeType).\n/// - `timer`: The timer which will be resolved when the node schema is ready.\nexport const $nodeAsync = (id: string, schema: (ctx: Ctx) => Promise<NodeSchema>, timerName?: string) => {\n  let nodeType: NodeType | undefined\n  const plugin = addTimer<$Node>(\n    async (ctx, plugin, done) => {\n      const nodeSchema = await schema(ctx)\n      ctx.update(nodesCtx, ns => [...ns.filter(n => n[0] !== id), [id, nodeSchema] as [string, NodeSchema]])\n\n      plugin.id = id\n      plugin.schema = nodeSchema\n      done()\n\n      await ctx.wait(SchemaReady)\n\n      nodeType = ctx.get(schemaCtx).nodes[id]\n      if (!nodeType)\n        throw missingNodeInSchema(id)\n\n      return () => {\n        ctx.update(nodesCtx, ns => ns.filter(([x]) => x !== id))\n      }\n    },\n    schemaTimerCtx,\n    timerName,\n  )\n  plugin.type = () => nodeType!\n\n  return plugin\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport { SchemaReady, editorStateTimerCtx, prosePluginsCtx } from '@milkdown/core'\nimport type { Plugin, PluginKey } from '@milkdown/prose/state'\n\nimport { addTimer } from './utils'\n\n/// @internal\nexport type $Prose = MilkdownPlugin & {\n  plugin: () => Plugin\n  key: () => PluginKey | undefined\n}\n\n/// Create a milkdown wrapper for [prosemirror plugin](https://prosemirror.net/docs/ref/#state.Plugin).\n/// It takes a factory function which returns a [prosemirror plugin](https://prosemirror.net/docs/ref/#state.Plugin).\n///\n/// Additional property:\n/// - `plugin`: The prosemirror plugin created.\n/// - `key`: The [prosemirror plugin key](https://prosemirror.net/docs/ref/#state.PluginKey) of the plugin.\nexport const $prose = (prose: (ctx: Ctx) => Plugin): $Prose => {\n  let prosePlugin: Plugin | undefined\n  const plugin: MilkdownPlugin = ctx => async () => {\n    await ctx.wait(SchemaReady)\n    prosePlugin = prose(ctx)\n    ctx.update(prosePluginsCtx, ps => [...ps, prosePlugin!])\n\n    return () => {\n      ctx.update(prosePluginsCtx, ps => ps.filter(x => x !== prosePlugin))\n    }\n  }\n  (<$Prose>plugin).plugin = () => prosePlugin!;\n  (<$Prose>plugin).key = () => prosePlugin!.spec.key\n\n  return <$Prose>plugin\n}\n\n/// The async version for `$prose`. You can use `await` in the factory when creating the plugin.\n///\n/// Additional property:\n/// - `plugin`: The prosemirror plugin created.\n/// - `key`: The [prosemirror plugin key](https://prosemirror.net/docs/ref/#state.PluginKey) of the plugin.\n/// - `timer`: The timer which will be resolved when the plugin is ready.\nexport const $proseAsync = (prose: (ctx: Ctx) => Promise<Plugin>, timerName?: string) => {\n  let prosePlugin: Plugin | undefined\n  const plugin = addTimer<$Prose>(\n    async (ctx) => {\n      await ctx.wait(SchemaReady)\n      prosePlugin = await prose(ctx)\n      ctx.update(prosePluginsCtx, ps => [...ps, prosePlugin!])\n\n      return () => {\n        ctx.update(prosePluginsCtx, ps => ps.filter(x => x !== prosePlugin))\n      }\n    },\n    editorStateTimerCtx,\n    timerName,\n  )\n\n  plugin.plugin = () => prosePlugin!\n  plugin.key = () => prosePlugin!.spec.key\n\n  return plugin\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport { InitReady, remarkPluginsCtx, schemaTimerCtx } from '@milkdown/core'\n\nimport type { RemarkPlugin } from '@milkdown/transformer'\nimport { addTimer } from './utils'\n\n/// @internal\nexport type $Remark = MilkdownPlugin & {\n  plugin: RemarkPlugin\n}\n\n/// Create a milkdown wrapper for [remark plugin](https://github.com/remarkjs/remark/blob/main/doc/plugins.md).\n/// It takes a factory function which returns a [remark plugin](https://github.com/remarkjs/remark/blob/main/doc/plugins.md).\n///\n/// Additional property:\n/// - `plugin`: The remark plugin created.\nexport const $remark = (remark: (ctx: Ctx) => RemarkPlugin): $Remark => {\n  const plugin: MilkdownPlugin = ctx => async () => {\n    await ctx.wait(InitReady)\n    const re = remark(ctx)\n    ctx.update(remarkPluginsCtx, rp => [...rp, re]);\n    (<$Remark>plugin).plugin = re\n\n    return () => {\n      ctx.update(remarkPluginsCtx, rp => rp.filter(x => x !== re))\n    }\n  }\n\n  return <$Remark>plugin\n}\n\n/// The async version for `$remark`. You can use `await` in the factory when creating the remark plugin.\n///\n/// Additional property:\n/// - `plugin`: The remark plugin created.\n/// - `timer`: The timer which will be resolved when the remark plugin is ready.\nexport const $remarkAsync = (remark: (ctx: Ctx) => Promise<RemarkPlugin>, timerName?: string) =>\n  addTimer<$Remark>(\n    async (ctx, plugin) => {\n      await ctx.wait(InitReady)\n      const re = await remark(ctx)\n      ctx.update(remarkPluginsCtx, rp => [...rp, re])\n      plugin.plugin = re\n\n      return () => {\n        ctx.update(remarkPluginsCtx, rp => rp.filter(x => x !== re))\n      }\n    },\n    schemaTimerCtx,\n    timerName,\n  )\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport { SchemaReady, editorStateTimerCtx, prosePluginsCtx } from '@milkdown/core'\nimport { keymap } from '@milkdown/prose/keymap'\nimport type { Command } from '@milkdown/prose/state'\n\nimport { addTimer } from './utils'\n\n/// @internal\nexport type Keymap = Record<string, Command>\n\n/// @internal\nexport type $Shortcut = MilkdownPlugin & {\n  keymap: Keymap\n}\n\n/// Create a shortcut for the editor.\n/// It takes a factory function which returns a [prosemirror keymap](https://prosemirror.net/docs/ref/#keymap).\n///\n/// Additional property:\n/// - `keymap`: The prosemirror keymap created.\nexport const $shortcut = (shortcut: (ctx: Ctx) => Keymap): $Shortcut => {\n  const plugin: MilkdownPlugin = ctx => async () => {\n    await ctx.wait(SchemaReady)\n    const k = shortcut(ctx)\n    const keymapPlugin = keymap(k)\n    ctx.update(prosePluginsCtx, ps => [...ps, keymapPlugin]);\n    (<$Shortcut>plugin).keymap = k\n\n    return () => {\n      ctx.update(prosePluginsCtx, ps => ps.filter(x => x !== keymapPlugin))\n    }\n  }\n\n  return <$Shortcut>plugin\n}\n\n/// The async version for `$shortcut`. You can use `await` in the factory when creating the keymap.\n///\n/// Additional property:\n/// - `keymap`: The prosemirror keymap created.\n/// - `timer`: The timer which will be resolved when the plugin is ready.\nexport const $shortcutAsync = (shortcut: (ctx: Ctx) => Promise<Keymap>, timerName?: string) =>\n  addTimer<$Shortcut>(\n    async (ctx, plugin) => {\n      await ctx.wait(SchemaReady)\n      const k = await shortcut(ctx)\n      const keymapPlugin = keymap(k)\n      ctx.update(prosePluginsCtx, ps => [...ps, keymapPlugin])\n      plugin.keymap = k\n\n      return () => {\n        ctx.update(prosePluginsCtx, ps => ps.filter(x => x !== keymapPlugin))\n      }\n    },\n    editorStateTimerCtx,\n    timerName,\n  )\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport { SchemaReady, editorViewTimerCtx, markViewCtx, nodeViewCtx } from '@milkdown/core'\nimport { NodeType } from '@milkdown/prose/model'\nimport type { MarkViewConstructor, NodeViewConstructor } from '@milkdown/prose/view'\n\nimport { addTimer } from './utils'\nimport type { $Mark, $Node } from '.'\n\n/// @internal\nexport type $View<T extends $Node | $Mark, V extends NodeViewConstructor | MarkViewConstructor> = MilkdownPlugin & {\n  view: V\n  type: T\n}\n\n/// @internal\nexport type GetConstructor<T extends $Node | $Mark> = T extends $Node\n  ? NodeViewConstructor\n  : T extends $Mark\n    ? MarkViewConstructor\n    : NodeViewConstructor | MarkViewConstructor\n\n/// Create a [prosemirror node/mark view](https://prosemirror.net/docs/ref/#view.NodeView) plugin.\n/// It takes two arguments\n/// - `type`: The node/mark plugin that needs to add a view.\n/// - `view`: The factory that creates the view. It should return a function that returns a [node/mark view constructor](https://prosemirror.net/docs/ref/#view.NodeView).\n///\n/// Additional property:\n/// - `view`: The view created.\n/// - `type`: The node/mark plugin that needs to add a view.\nexport const $view = <\n  T extends $Node | $Mark,\n  V extends NodeViewConstructor | MarkViewConstructor = GetConstructor<T>,\n>(type: T, view: (ctx: Ctx) => V): $View<T, V> => {\n  const plugin: MilkdownPlugin = ctx => async () => {\n    await ctx.wait(SchemaReady)\n    const v = view(ctx)\n    if (type.type() instanceof NodeType)\n      ctx.update(nodeViewCtx, ps => [...ps, [type.id, v] as [string, NodeViewConstructor]])\n    else\n      ctx.update(markViewCtx, ps => [...ps, [type.id, v] as [string, MarkViewConstructor]]);\n\n    (<$View<T, V>>plugin).view = v;\n    (<$View<T, V>>plugin).type = type\n\n    return () => {\n      if (type.type() instanceof NodeType)\n        ctx.update(nodeViewCtx, ps => ps.filter(x => x[0] !== type.id))\n      else\n        ctx.update(markViewCtx, ps => ps.filter(x => x[0] !== type.id))\n    }\n  }\n\n  return <$View<T, V>>plugin\n}\n\n/// The async version for `$view`. You can use `await` in the factory when creating the view.\n///\n/// Additional property:\n/// - `view`: The view created.\n/// - `type`: The node/mark plugin that needs to add a view.\n/// - `timer`: The timer which will be resolved when the view is ready.\nexport const $viewAsync = <\n  T extends $Node | $Mark,\n  V extends NodeViewConstructor | MarkViewConstructor = GetConstructor<T>,\n>(type: T, view: (ctx: Ctx) => Promise<V>, timerName?: string) =>\n    addTimer<$View<T, V>>(\n      async (ctx, plugin) => {\n        await ctx.wait(SchemaReady)\n        const v = await view(ctx)\n        if (type.type() instanceof NodeType)\n          ctx.update(nodeViewCtx, ps => [...ps, [type.id, v] as [string, NodeViewConstructor]])\n        else\n          ctx.update(markViewCtx, ps => [...ps, [type.id, v] as [string, MarkViewConstructor]])\n\n        plugin.view = v\n        plugin.type = type\n\n        return () => {\n          if (type.type() instanceof NodeType)\n            ctx.update(nodeViewCtx, ps => ps.filter(x => x[0] !== type.id))\n          else\n            ctx.update(markViewCtx, ps => ps.filter(x => x[0] !== type.id))\n        }\n      },\n      editorViewTimerCtx,\n      timerName,\n    )\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin, SliceType } from '@milkdown/ctx'\nimport { createSlice } from '@milkdown/ctx'\n\n/// @internal\nexport type $Ctx<T, N extends string> = MilkdownPlugin & {\n  key: SliceType<T, N>\n}\n\n/// Create a slice plugin. The plugin will be registered in the `ctx` and can be accessed by other parts of the editor.\n/// ```ts\n/// const counterCtx = $ctx(0, 'counter');\n/// ```\n///\n/// Additional property:\n/// - `key`: The key of the slice.\nexport const $ctx = <T, N extends string>(value: T, name: N): $Ctx<T, N> => {\n  const slice = createSlice(value, name)\n  const plugin: $Ctx<T, N> = (ctx) => {\n    ctx.inject(slice)\n    return () => {\n      return () => {\n        ctx.remove(slice)\n      }\n    }\n  }\n\n  plugin.key = slice\n\n  return plugin\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport { nodesCtx } from '@milkdown/core'\nimport type { NodeSchema } from '@milkdown/transformer'\nimport type { $Ctx } from '../$ctx'\nimport { $ctx } from '../$ctx'\nimport type { $Node } from '../$node'\nimport { $node } from '../$node'\n\n/// @internal\nexport type GetNodeSchema = (ctx: Ctx) => NodeSchema\n\n/// @internal\nexport type $NodeSchema<T extends string> = [\n  schemaCtx: $Ctx<GetNodeSchema, T>,\n  schema: $Node,\n] & {\n  id: $Node['id']\n  type: $Node['type']\n  node: $Node\n  ctx: $Ctx<GetNodeSchema, T>\n  schema: NodeSchema\n  key: $Ctx<GetNodeSchema, T>['key']\n  extendSchema: (handler: (prev: GetNodeSchema) => GetNodeSchema) => MilkdownPlugin\n}\n\n/// Create a plugin for node schema.\n/// The first parameter is the id of the node schema.\n/// The second parameter is the function that returns the node schema.\n///\n/// The function will return a plugin with additional properties:\n/// - `id`: The id of the node schema.\n/// - `type`: A function witch will return the type of the node schema.\n/// - `ctx`: The context of the node schema.\n/// - `node`: The node schema plugin.\n/// - `schema`: The node schema.\n/// - `key`: The key of slice which contains the node schema factory.\n/// - `extendSchema`: A function witch will return a plugin that can extend the node schema.\nexport const $nodeSchema = <T extends string>(id: T, schema: GetNodeSchema): $NodeSchema<T> => {\n  const schemaCtx = $ctx(schema, id)\n\n  const nodeSchema = $node(id, (ctx) => {\n    const userSchema = ctx.get(schemaCtx.key)\n    return userSchema(ctx)\n  })\n\n  const result = [schemaCtx, nodeSchema] as $NodeSchema<T>\n  result.id = nodeSchema.id\n  result.node = nodeSchema\n  result.type = nodeSchema.type\n  result.schema = nodeSchema.schema\n  result.ctx = schemaCtx\n  result.key = schemaCtx.key\n  result.extendSchema = (handler): MilkdownPlugin => {\n    return ctx => () => {\n      const prev = ctx.get(schemaCtx.key)\n      const next = handler(prev)\n      const nodeSchema = next(ctx)\n      ctx.update(nodesCtx, ns => [...ns.filter(n => n[0] !== id), [id, nodeSchema] as [string, NodeSchema]])\n      result.schema = nodeSchema\n    }\n  }\n\n  return result\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport { marksCtx } from '@milkdown/core'\nimport type { MarkSchema } from '@milkdown/transformer'\nimport type { $Ctx } from '../$ctx'\nimport { $ctx } from '../$ctx'\nimport type { $Mark } from '../$mark'\nimport { $mark } from '../$mark'\n\n/// @internal\nexport type GetMarkSchema = (ctx: Ctx) => MarkSchema\n\n/// @internal\nexport type $MarkSchema<T extends string> = [\n  schemaCtx: $Ctx<GetMarkSchema, T>,\n  schema: $Mark,\n] & {\n  id: $Mark['id']\n  type: $Mark['type']\n  mark: $Mark\n  ctx: $Ctx<GetMarkSchema, T>\n  schema: MarkSchema\n  key: $Ctx<GetMarkSchema, T>['key']\n  extendSchema: (handler: (prev: GetMarkSchema) => GetMarkSchema) => MilkdownPlugin\n}\n\n/// Create a plugin for mark schema.\n/// The first parameter is the id of the mark schema.\n/// The second parameter is the function that returns the mark schema.\n///\n/// The function will return a plugin with additional properties:\n/// - `id`: The id of the mark schema.\n/// - `type`: A function witch will return the type of the mark schema.\n/// - `ctx`: The context of the mark schema.\n/// - `mark`: The mark schema plugin.\n/// - `schema`: The mark schema.\n/// - `key`: The key of slice which contains the mark schema factory.\n/// - `extendSchema`: A function witch will return a plugin that can extend the mark schema.\nexport const $markSchema = <T extends string>(id: T, schema: GetMarkSchema): $MarkSchema<T> => {\n  const schemaCtx = $ctx(schema, id)\n\n  const markSchema = $mark(id, (ctx) => {\n    const userSchema = ctx.get(schemaCtx.key)\n    return userSchema(ctx)\n  })\n\n  const result = [schemaCtx, markSchema] as $MarkSchema<T>\n  result.id = markSchema.id\n  result.mark = markSchema\n  result.type = markSchema.type\n  result.schema = markSchema.schema\n  result.ctx = schemaCtx\n  result.key = schemaCtx.key\n  result.extendSchema = (handler): MilkdownPlugin => {\n    return ctx => () => {\n      const prev = ctx.get(schemaCtx.key)\n      const next = handler(prev)\n      const markSchema = next(ctx)\n      ctx.update(marksCtx, ms => [...ms.filter(m => m[0] !== id), [id, markSchema] as [string, MarkSchema]])\n      result.schema = markSchema\n    }\n  }\n\n  return result\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx, SliceType } from '@milkdown/ctx'\nimport type { Command } from '@milkdown/prose/state'\nimport type { $Ctx } from '../$ctx'\nimport { $ctx } from '../$ctx'\nimport type { $Shortcut, Keymap } from '../$shortcut'\nimport { $shortcut } from '../$shortcut'\n\n/// @internal\nexport type KeymapConfig<K extends string> = Record<K, string | string[]>\n\n/// @internal\nexport type KeymapItem = {\n  shortcuts: string | string[]\n  command: (ctx: Ctx) => Command\n}\n\n/// @internal\nexport type UserKeymapConfig<Key extends string> = Record<Key, KeymapItem>\n\n/// @internal\nexport type $UserKeymap<N extends string, Key extends string> = [$Ctx<KeymapConfig<Key>, `${N}Keymap`>, $Shortcut] & {\n  key: SliceType<KeymapConfig<Key>, `${N}Keymap`>\n  keymap: Keymap\n  ctx: $Ctx<KeymapConfig<Key>, `${N}Keymap`>\n  shortcuts: $Shortcut\n}\n\n/// Create a keymap which can be customized by user.\n/// It takes two arguments:\n/// - `name`: The name of the keymap.\n/// - `userKeymap`: The keymap config which contains the shortcuts and the command.\nexport const $useKeymap = <N extends string, Key extends string>(name: N, userKeymap: UserKeymapConfig<Key>) => {\n  const key = Object.fromEntries(Object.entries<KeymapItem>(userKeymap).map(([key, { shortcuts }]) => {\n    return [key, shortcuts]\n  })) as Record<Key, string | string[]>\n\n  const keymapDef = $ctx<KeymapConfig<Key>, `${N}Keymap`>(key, `${name}Keymap`)\n\n  const shortcuts = $shortcut((ctx) => {\n    const keys = ctx.get(keymapDef.key)\n\n    const keymapTuple = Object.entries<KeymapItem>(userKeymap).flatMap(([key, { command }]) => {\n      const targetKeys: string[] = [keys[key as Key]].flat()\n\n      return targetKeys.map(targetKey => [targetKey, command(ctx)] as const)\n    })\n\n    return Object.fromEntries(keymapTuple)\n  })\n\n  const result = [keymapDef, shortcuts] as $UserKeymap<N, Key>\n  result.ctx = keymapDef\n  result.shortcuts = shortcuts\n  result.key = keymapDef.key\n  result.keymap = shortcuts.keymap\n\n  return result\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Mark, Node } from '@milkdown/prose/model'\nimport type { $Ctx } from '../$ctx'\nimport { $ctx } from '../$ctx'\n\n/// @internal\nexport type $NodeAttr = $Ctx<(node: Node) => Record<string, any>, `${string}Attr`>\n\n/// Create a slice which contains the attributes for node schema.\nexport const $nodeAttr = (name: string, value: (node: Node) => Record<string, any> = () => ({})): $NodeAttr => $ctx(value, `${name}Attr`)\n\n/// @internal\nexport type $MarkAttr = $Ctx<(node: Mark) => Record<string, any>, `${string}Attr`>\n\n/// Create a slice which contains the attributes for mark schema.\nexport const $markAttr = (name: string, value: (mark: Mark) => Record<string, any> = () => ({})): $MarkAttr => $ctx(value, `${name}Attr`)\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { CmdKey } from '@milkdown/core'\nimport { commandsCtx } from '@milkdown/core'\nimport type { Ctx } from '@milkdown/ctx'\n\ntype InferParams<T> = T extends CmdKey<infer U> ? U : never\n\n/// Call a command. You can pass the command key and the payload to the macro.\nexport function callCommand<T extends CmdKey<any>>(slice: string, payload?: InferParams<T>): (ctx: Ctx) => boolean\nexport function callCommand<T>(slice: CmdKey<T>, payload?: T): (ctx: Ctx) => boolean\nexport function callCommand(slice: string | CmdKey<any>, payload?: any): (ctx: Ctx) => boolean\nexport function callCommand(slice: string | CmdKey<any>, payload?: any): (ctx: Ctx) => boolean {\n  return (ctx: Ctx) => {\n    return ctx.get(commandsCtx).call(slice, payload)\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/ctx'\nimport { editorViewCtx } from '@milkdown/core'\n\n/// Force update the editor.\nexport const forceUpdate\n  = () =>\n    (ctx: Ctx): void => {\n      const view = ctx.get(editorViewCtx)\n      const { tr } = view.state\n\n      const nextTr = Object.assign(Object.create(tr), tr).setTime(Date.now())\n      return view.dispatch(nextTr)\n    }\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/ctx'\nimport { editorViewCtx, schemaCtx } from '@milkdown/core'\nimport { DOMSerializer } from '@milkdown/prose/model'\n\n/// Get content of the editor as HTML string.\nexport const getHTML\n  = () =>\n    (ctx: Ctx): string => {\n      const div = document.createElement('div')\n      const schema = ctx.get(schemaCtx)\n      const view = ctx.get(editorViewCtx)\n      const fragment = DOMSerializer.fromSchema(schema).serializeFragment(view.state.doc.content)\n\n      div.appendChild(fragment)\n\n      return div.innerHTML\n    }\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/ctx'\nimport { editorViewCtx, serializerCtx } from '@milkdown/core'\n\n/// Get content of the editor as markdown string.\nexport const getMarkdown\n  = () =>\n    (ctx: Ctx): string => {\n      const view = ctx.get(editorViewCtx)\n      const serializer = ctx.get(serializerCtx)\n\n      return serializer(view.state.doc)\n    }\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/ctx'\nimport { editorViewCtx, parserCtx } from '@milkdown/core'\nimport { Slice } from '@milkdown/prose/model'\n\n/// Insert markdown string into the editor.\nexport const insert = (markdown: string) => (ctx: Ctx) => {\n  const view = ctx.get(editorViewCtx)\n  const parser = ctx.get(parserCtx)\n  const doc = parser(markdown)\n  if (!doc)\n    return\n\n  const contentSlice = view.state.selection.content()\n  return view.dispatch(\n    view.state.tr\n      .replaceSelection(new Slice(doc.content, contentSlice.openStart, contentSlice.openEnd))\n      .scrollIntoView(),\n  )\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/ctx'\nimport { editorViewCtx } from '@milkdown/core'\n\n/// Get outline of the editor.\nexport const outline\n  = () =>\n    (ctx: Ctx): Array<{ text: string; level: number; id: string }> => {\n      const view = ctx.get(editorViewCtx)\n      const data: { text: string; level: number; id: string }[] = []\n      const doc = view.state.doc\n      doc.descendants((node) => {\n        if (node.type.name === 'heading' && node.attrs.level)\n          data.push({ text: node.textContent, level: node.attrs.level, id: node.attrs.id })\n      })\n      return data\n    }\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/ctx'\nimport {\n  editorStateOptionsCtx,\n  editorViewCtx,\n  parserCtx,\n  prosePluginsCtx,\n  schemaCtx,\n} from '@milkdown/core'\nimport { Slice } from '@milkdown/prose/model'\nimport { EditorState } from '@milkdown/prose/state'\n\n/// Replace all content of the editor with markdown string.\n/// If flush is true, the editor state will be re-created.\nexport const replaceAll\n  = (markdown: string, flush = false) =>\n    (ctx: Ctx): void => {\n      const view = ctx.get(editorViewCtx)\n      const parser = ctx.get(parserCtx)\n      const doc = parser(markdown)\n      if (!doc)\n        return\n\n      if (!flush) {\n        const { state } = view\n        return view.dispatch(state.tr.replace(0, state.doc.content.size, new Slice(doc.content, 0, 0)))\n      }\n\n      const schema = ctx.get(schemaCtx)\n      const options = ctx.get(editorStateOptionsCtx)\n      const plugins = ctx.get(prosePluginsCtx)\n\n      const state = EditorState.create({\n        schema,\n        doc,\n        plugins,\n        ...options,\n      })\n\n      view.updateState(state)\n    }\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx } from '@milkdown/ctx'\nimport { editorViewCtx } from '@milkdown/core'\nimport type { Attrs } from '@milkdown/prose/model'\n\n/// Set the attributes of the node at the given position.\nexport const setAttr = (pos: number, update: (prevAttrs: Attrs) => Attrs) => (ctx: Ctx) => {\n  const view = ctx.get(editorViewCtx)\n  const { tr } = view.state\n  const node = tr.doc.nodeAt(pos)\n  if (!node)\n    return\n  const nextAttr = update(node.attrs)\n  return view.dispatch(tr.setNodeMarkup(pos, undefined, nextAttr))\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\n/// @internal\nexport type Many<T> = T | ReadonlyArray<T>\n\ninterface Pipe {\n  pipe<A extends any[], R1, R2, R3, R4, R5, R6, R7>(\n    f1: (...args: A) => R1,\n    f2: (a: R1) => R2,\n    f3: (a: R2) => R3,\n    f4: (a: R3) => R4,\n    f5: (a: R4) => R5,\n    f6: (a: R5) => R6,\n    f7: (a: R6) => R7,\n  ): (...args: A) => R7\n  pipe<A extends any[], R1, R2, R3, R4, R5, R6, R7>(\n    f1: (...args: A) => R1,\n    f2: (a: R1) => R2,\n    f3: (a: R2) => R3,\n    f4: (a: R3) => R4,\n    f5: (a: R4) => R5,\n    f6: (a: R5) => R6,\n    f7: (a: R6) => R7,\n    ...func: Array<Many<(a: any) => any>>\n  ): (...args: A) => any\n  pipe<A extends any[], R1, R2, R3, R4, R5, R6>(\n    f1: (...args: A) => R1,\n    f2: (a: R1) => R2,\n    f3: (a: R2) => R3,\n    f4: (a: R3) => R4,\n    f5: (a: R4) => R5,\n    f6: (a: R5) => R6,\n  ): (...args: A) => R6\n  pipe<A extends any[], R1, R2, R3, R4, R5>(\n    f1: (...args: A) => R1,\n    f2: (a: R1) => R2,\n    f3: (a: R2) => R3,\n    f4: (a: R3) => R4,\n    f5: (a: R4) => R5,\n  ): (...args: A) => R5\n  pipe<A extends any[], R1, R2, R3, R4>(\n    f1: (...args: A) => R1,\n    f2: (a: R1) => R2,\n    f3: (a: R2) => R3,\n    f4: (a: R3) => R4,\n  ): (...args: A) => R4\n  pipe<A extends any[], R1, R2, R3>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (...args: A) => R3\n  pipe<A extends any[], R1, R2>(f1: (...args: A) => R1, f2: (a: R1) => R2): (...args: A) => R2\n  pipe(...func: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any\n}\n\n/// @internal\nexport const pipe: Pipe['pipe'] = (...funcs: any[]) => {\n  const length = funcs.length\n  let index = length\n  while (index--) {\n    if (typeof funcs[index] !== 'function')\n      throw new TypeError('Expected a function')\n  }\n  return (...args: any[]) => {\n    let index = 0\n    let result = length ? funcs[index](...args) : args[0]\n    while (++index < length)\n      result = funcs[index](result)\n\n    return result\n  }\n}\n"],"names":["nanoid","customAlphabet","addTimer","runner","injectTo","timerName","timer","createTimer","doneCalled","plugin","ctx","x","cleanup","y","$command","key","cmd","cmdKey","createCmdKey","SchemaReady","command","commandsCtx","payload","$commandAsync","commandsTimerCtx","$inputRule","inputRule","ir","inputRulesCtx","irs","$inputRuleAsync","editorStateTimerCtx","$mark","id","schema","markType","markSchema","marksCtx","ns","n","schemaCtx","missingMarkInSchema","$markAsync","done","schemaTimerCtx","$node","nodeType","nodeSchema","nodesCtx","missingNodeInSchema","$nodeAsync","$prose","prose","prosePlugin","prosePluginsCtx","ps","$proseAsync","$remark","remark","InitReady","re","remarkPluginsCtx","rp","$remarkAsync","$shortcut","shortcut","k","keymapPlugin","keymap","$shortcutAsync","$view","type","view","v","NodeType","nodeViewCtx","markViewCtx","$viewAsync","editorViewTimerCtx","$ctx","value","name","slice","createSlice","$nodeSchema","result","handler","prev","$markSchema","ms","m","$useKeymap","userKeymap","shortcuts","keymapDef","keys","keymapTuple","targetKey","$nodeAttr","$markAttr","callCommand","forceUpdate","editorViewCtx","tr","nextTr","getHTML","div","fragment","DOMSerializer","getMarkdown","serializerCtx","insert","markdown","doc","parserCtx","contentSlice","Slice","outline","data","node","replaceAll","flush","state","options","editorStateOptionsCtx","plugins","EditorState","setAttr","pos","update","nextAttr","pipe","funcs","length","index","args"],"mappings":"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"}