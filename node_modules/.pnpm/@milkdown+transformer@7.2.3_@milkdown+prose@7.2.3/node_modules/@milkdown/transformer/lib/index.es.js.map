{"version":3,"file":"index.es.js","sources":["../src/utility/stack.ts","../src/parser/stack-element.ts","../src/parser/state.ts","../src/serializer/stack-element.ts","../src/serializer/state.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nimport { stackOverFlow } from '@milkdown/exception'\n\n/// The element of the stack, which holds an array of nodes.\nexport abstract class StackElement<Node> {\n  /// A method that can `push` a node into the element.\n  abstract push(node: Node, ...rest: Node[]): void\n}\n\n/// The stack that is used to store the elements.\n///\n/// > Generally, you don't need to use this class directly.\n///\n/// When using the stack, users can call `stack.open` to push a new element into the stack.\n/// And use `stack.push` to push a node into the top element.\n/// Then use `stack.close` to close the top element and pop it.\n///\n/// For example: `stack.open(A).push(B).push(C).close()` will generate a structure like `A(B, C)`.\nexport class Stack<Node, Element extends StackElement<Node>> {\n  protected elements: Element[] = []\n\n  /// Get the size of the stack.\n  size = (): number => {\n    return this.elements.length\n  }\n\n  /// Get the top element of the stack.\n  top = (): Element | undefined => {\n    return this.elements.at(-1)\n  }\n\n  /// Push a node into the top element.\n  push = (node: Node): void => {\n    this.top()?.push(node)\n  }\n\n  /// Push a new element.\n  open = (node: Element): void => {\n    this.elements.push(node)\n  }\n\n  /// Close the top element and pop it.\n  close = (): Element => {\n    const el = this.elements.pop()\n    if (!el)\n      throw stackOverFlow()\n\n    return el\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Attrs, Node, NodeType } from '@milkdown/prose/model'\nimport { StackElement } from '../utility'\n\nexport class ParserStackElement extends StackElement<Node> {\n  constructor(public type: NodeType, public content: Node[], public attrs?: Attrs) {\n    super()\n  }\n\n  push(node: Node, ...rest: Node[]) {\n    this.content.push(node, ...rest)\n  }\n\n  pop(): Node | undefined {\n    return this.content.pop()\n  }\n\n  static create(type: NodeType, content: Node[], attrs?: Attrs) {\n    return new ParserStackElement(type, content, attrs)\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Attrs, MarkType, Node, NodeType, Schema } from '@milkdown/prose/model'\nimport { createNodeInParserFail, parserMatchError, stackOverFlow } from '@milkdown/exception'\nimport { Mark } from '@milkdown/prose/model'\nimport type { MarkSchema, MarkdownNode, NodeSchema, RemarkParser } from '../utility'\nimport { Stack } from '../utility'\n\nimport { ParserStackElement } from './stack-element'\nimport type { Parser } from './types'\n\n/// A state machine for parser. Transform remark AST into prosemirror state.\nexport class ParserState extends Stack<Node, ParserStackElement> {\n  /// The schema in current editor.\n  readonly schema: Schema\n\n  /// @internal\n  #marks: readonly Mark[] = Mark.none\n\n  /// Create a parser from schema and remark instance.\n  ///\n  /// ```typescript\n  /// const parser = ParserState.create(schema, remark)\n  /// const prosemirrorNode = parser(SomeMarkdownText)\n  /// ```\n  static create = (schema: Schema, remark: RemarkParser): Parser => {\n    const state = new this(schema)\n    return (text) => {\n      state.run(remark, text)\n      return state.toDoc()\n    }\n  }\n\n  /// @internal\n  protected constructor(schema: Schema) {\n    super()\n    this.schema = schema\n  }\n\n  /// @internal\n  #hasText = (node: Node): node is Node & { text: string } => node.isText\n\n  /// @internal\n  #maybeMerge = (a: Node, b: Node): Node | undefined => {\n    if (this.#hasText(a) && this.#hasText(b) && Mark.sameSet(a.marks, b.marks))\n      return this.schema.text(a.text + b.text, a.marks)\n\n    return undefined\n  }\n\n  /// @internal\n  #matchTarget = (node: MarkdownNode): NodeType | MarkType => {\n    const result = Object.values({ ...this.schema.nodes, ...this.schema.marks })\n      .find((x): x is (NodeType | MarkType) => {\n        const spec = x.spec as NodeSchema | MarkSchema\n        return spec.parseMarkdown.match(node)\n      })\n\n    if (!result)\n      throw parserMatchError(node)\n\n    return result\n  }\n\n  /// @internal\n  #runNode = (node: MarkdownNode) => {\n    const type = this.#matchTarget(node)\n    const spec = type.spec as NodeSchema | MarkSchema\n\n    spec.parseMarkdown.runner(this, node, type as NodeType & MarkType)\n  }\n\n  /// Inject root node for prosemirror state.\n  injectRoot = (node: MarkdownNode, nodeType: NodeType, attrs?: Attrs) => {\n    this.openNode(nodeType, attrs)\n    this.next(node.children)\n\n    return this\n  }\n\n  /// Open a new node, the next operations will\n  /// add nodes into that new node until `closeNode` is called.\n  openNode = (nodeType: NodeType, attrs?: Attrs) => {\n    this.open(ParserStackElement.create(nodeType, [], attrs))\n    return this\n  }\n\n  /// @internal\n  #closeNodeAndPush = (): Node => {\n    this.#marks = Mark.none\n    const element = this.close()\n\n    return this.#addNodeAndPush(element.type, element.attrs, element.content)\n  }\n\n  /// Close the current node and push it into the parent node.\n  closeNode = () => {\n    this.#closeNodeAndPush()\n    return this\n  }\n\n  /// @internal\n  #addNodeAndPush = (nodeType: NodeType, attrs?: Attrs, content?: Node[]): Node => {\n    const node = nodeType.createAndFill(attrs, content, this.#marks)\n    if (!node)\n      throw createNodeInParserFail(nodeType, attrs, content)\n\n    this.push(node)\n\n    return node\n  }\n\n  /// Add a node into current node.\n  addNode = (nodeType: NodeType, attrs?: Attrs, content?: Node[]) => {\n    this.#addNodeAndPush(nodeType, attrs, content)\n    return this\n  }\n\n  /// Open a new mark, the next nodes added will have that mark.\n  openMark = (markType: MarkType, attrs?: Attrs) => {\n    const mark = markType.create(attrs)\n\n    this.#marks = mark.addToSet(this.#marks)\n    return this\n  }\n\n  /// Close a opened mark.\n  closeMark = (markType: MarkType) => {\n    this.#marks = markType.removeFromSet(this.#marks)\n    return this\n  }\n\n  /// Add a text node into current node.\n  addText = (text: string) => {\n    const topElement = this.top()\n    if (!topElement)\n      throw stackOverFlow()\n\n    const prevNode = topElement.pop()\n    const currNode = this.schema.text(text, this.#marks)\n\n    if (!prevNode) {\n      topElement.push(currNode)\n      return this\n    }\n\n    const merged = this.#maybeMerge(prevNode, currNode)\n    if (merged) {\n      topElement.push(merged)\n      return this\n    }\n    topElement.push(prevNode, currNode)\n    return this\n  }\n\n  /// @internal\n  build = (): Node => {\n    let doc: Node | undefined\n\n    do\n      doc = this.#closeNodeAndPush()\n    while (this.size())\n\n    return doc\n  }\n\n  /// Give the node or node list back to the state and\n  /// the state will find a proper runner (by `match` method in parser spec) to handle it.\n  next = (nodes: MarkdownNode | MarkdownNode[] = []) => {\n    [nodes].flat().forEach(node => this.#runNode(node))\n    return this\n  }\n\n  /// Build the current state into a [prosemirror document](https://prosemirror.net/docs/ref/#model.Document_Structure).\n  toDoc = () => this.build()\n\n  /// Transform a markdown string into prosemirror state.\n  run = (remark: RemarkParser, markdown: string) => {\n    const tree = remark.runSync(remark.parse(markdown), markdown) as MarkdownNode\n    this.next(tree)\n\n    return this\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MarkdownNode } from '..'\nimport type { JSONRecord } from '../utility'\nimport { StackElement } from '../utility'\n\nexport class SerializerStackElement extends StackElement<MarkdownNode> {\n  constructor(\n    public type: string,\n    public children?: MarkdownNode[],\n    public value?: string,\n    public props: JSONRecord = {},\n  ) {\n    super()\n  }\n\n  static create = (\n    type: string,\n    children?: MarkdownNode[],\n    value?: string,\n    props: JSONRecord = {},\n  ) => new SerializerStackElement(type, children, value, props)\n\n  push = (node: MarkdownNode, ...rest: MarkdownNode[]) => {\n    if (!this.children)\n      this.children = []\n\n    this.children.push(node, ...rest)\n  }\n\n  pop = (): MarkdownNode | undefined => this.children?.pop()\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { serializerMatchError } from '@milkdown/exception'\nimport type { Fragment, MarkType, Node, NodeType, Schema } from '@milkdown/prose/model'\nimport { Mark } from '@milkdown/prose/model'\n\nimport type { Root } from 'mdast'\nimport type { JSONRecord, MarkSchema, MarkdownNode, NodeSchema, RemarkParser } from '../utility'\nimport { Stack } from '../utility'\nimport { SerializerStackElement } from './stack-element'\nimport type { Serializer } from './types'\n\nconst isFragment = (x: Node | Fragment): x is Fragment => Object.prototype.hasOwnProperty.call(x, 'size')\n\n/// State for serializer.\n/// Transform prosemirror state into remark AST.\nexport class SerializerState extends Stack<MarkdownNode, SerializerStackElement> {\n  /// @internal\n  #marks: readonly Mark[] = Mark.none\n  /// Get the schema of state.\n  readonly schema: Schema\n\n  /// Create a serializer from schema and remark instance.\n  ///\n  /// ```typescript\n  /// const serializer = SerializerState.create(schema, remark)\n  /// const markdown = parser(prosemirrorDoc)\n  /// ```\n  static create = (schema: Schema, remark: RemarkParser): Serializer => {\n    const state = new this(schema)\n    return (content: Node) => {\n      state.run(content)\n      return state.toString(remark)\n    }\n  }\n\n  /// @internal\n  constructor(schema: Schema) {\n    super()\n    this.schema = schema\n  }\n\n  /// @internal\n  #matchTarget = (node: Node | Mark): NodeType | MarkType => {\n    const result = Object.values({ ...this.schema.nodes, ...this.schema.marks })\n      .find((x): x is (NodeType | MarkType) => {\n        const spec = x.spec as NodeSchema | MarkSchema\n        return spec.toMarkdown.match(node as Node & Mark)\n      })\n\n    if (!result)\n      throw serializerMatchError(node.type)\n\n    return result\n  }\n\n  /// @internal\n  #runProseNode = (node: Node) => {\n    const type = this.#matchTarget(node)\n    const spec = type.spec as NodeSchema\n    return spec.toMarkdown.runner(this, node)\n  }\n\n  /// @internal\n  #runProseMark = (mark: Mark, node: Node) => {\n    const type = this.#matchTarget(mark)\n    const spec = type.spec as MarkSchema\n    return spec.toMarkdown.runner(this, mark, node)\n  }\n\n  /// @internal\n  #runNode = (node: Node) => {\n    const { marks } = node\n    const getPriority = (x: Mark) => x.type.spec.priority ?? 50\n    const tmp = [...marks].sort((a, b) => getPriority(a) - getPriority(b))\n    const unPreventNext = tmp.every(mark => !this.#runProseMark(mark, node))\n    if (unPreventNext)\n      this.#runProseNode(node)\n\n    marks.forEach(mark => this.#closeMark(mark))\n  }\n\n  /// @internal\n  #searchType = (child: MarkdownNode, type: string): MarkdownNode => {\n    if (child.type === type)\n      return child\n\n    if (child.children?.length !== 1)\n      return child\n\n    const searchNode = (node: MarkdownNode): MarkdownNode | null => {\n      if (node.type === type)\n        return node\n\n      if (node.children?.length !== 1)\n        return null\n\n      const [firstChild] = node.children\n      if (!firstChild)\n        return null\n\n      return searchNode(firstChild)\n    }\n\n    const target = searchNode(child)\n\n    if (!target)\n      return child\n\n    const tmp = target.children ? [...target.children] : undefined\n    const node = { ...child, children: tmp }\n    node.children = tmp\n    target.children = [node]\n\n    return target\n  }\n\n  /// @internal\n  #maybeMergeChildren = (node: MarkdownNode): MarkdownNode => {\n    const { children } = node\n    if (!children)\n      return node\n\n    node.children = children.reduce((nextChildren, child, index) => {\n      if (index === 0)\n        return [child]\n\n      const last = nextChildren.at(-1)\n      if (last && last.isMark && child.isMark) {\n        child = this.#searchType(child, last.type)\n        const { children: currChildren, ...currRest } = child\n        const { children: prevChildren, ...prevRest } = last\n        if (\n          child.type === last.type\n          && currChildren\n          && prevChildren\n          && JSON.stringify(currRest) === JSON.stringify(prevRest)\n        ) {\n          const next = {\n            ...prevRest,\n            children: [...prevChildren, ...currChildren],\n          }\n          return nextChildren\n            .slice(0, -1)\n            .concat(this.#maybeMergeChildren(next))\n        }\n      }\n      return nextChildren.concat(child)\n    }, [] as MarkdownNode[])\n\n    return node\n  }\n\n  /// @internal\n  #createMarkdownNode = (element: SerializerStackElement) => {\n    const node: MarkdownNode = {\n      ...element.props,\n      type: element.type,\n    }\n\n    if (element.children)\n      node.children = element.children\n\n    if (element.value)\n      node.value = element.value\n\n    return node\n  }\n\n  /// Open a new node, the next operations will\n  /// add nodes into that new node until `closeNode` is called.\n  openNode = (type: string, value?: string, props?: JSONRecord) => {\n    this.open(SerializerStackElement.create(type, undefined, value, props))\n    return this\n  }\n\n  /// @internal\n  #closeNodeAndPush = (): MarkdownNode => {\n    const element = this.close()\n    return this.#addNodeAndPush(element.type, element.children, element.value, element.props)\n  }\n\n  /// Close the current node and push it into the parent node.\n  closeNode = () => {\n    this.#closeNodeAndPush()\n    return this\n  }\n\n  /// @internal\n  #addNodeAndPush = (type: string, children?: MarkdownNode[], value?: string, props?: JSONRecord): MarkdownNode => {\n    const element = SerializerStackElement.create(type, children, value, props)\n    const node: MarkdownNode = this.#maybeMergeChildren(this.#createMarkdownNode(element))\n    this.push(node)\n    return node\n  }\n\n  /// Add a node into current node.\n  addNode = (type: string, children?: MarkdownNode[], value?: string, props?: JSONRecord) => {\n    this.#addNodeAndPush(type, children, value, props)\n    return this\n  }\n\n  /// @internal\n  #openMark = (mark: Mark, type: string, value?: string, props?: JSONRecord) => {\n    const isIn = mark.isInSet(this.#marks)\n\n    if (isIn)\n      return this\n\n    this.#marks = mark.addToSet(this.#marks)\n    return this.openNode(type, value, { ...props, isMark: true })\n  }\n\n  /// @internal\n  #closeMark = (mark: Mark): void => {\n    const isIn = mark.isInSet(this.#marks)\n\n    if (!isIn)\n      return\n\n    this.#marks = mark.type.removeFromSet(this.#marks)\n    this.#closeNodeAndPush()\n  }\n\n  /// Open a new mark, the next nodes added will have that mark.\n  /// The mark will be closed automatically.\n  withMark = (mark: Mark, type: string, value?: string, props?: JSONRecord) => {\n    this.#openMark(mark, type, value, props)\n    return this\n  }\n\n  /// Close a opened mark.\n  /// In most cases you don't need this because\n  /// marks will be closed automatically.\n  closeMark = (mark: Mark) => {\n    this.#closeMark(mark)\n    return this\n  }\n\n  /// @internal\n  build = (): Root => {\n    let doc: Root | null = null\n    do\n      doc = this.#closeNodeAndPush() as Root\n    while (this.size())\n\n    return doc\n  }\n\n  /// Give the node or node list back to the state and\n  /// the state will find a proper runner (by `match` method in serializer spec) to handle it.\n  next = (nodes: Node | Fragment) => {\n    if (isFragment(nodes)) {\n      nodes.forEach((node) => {\n        this.#runNode(node)\n      })\n      return this\n    }\n    this.#runNode(nodes)\n    return this\n  }\n\n  /// Use a remark parser to serialize current AST stored.\n  override toString = (remark: RemarkParser): string => remark.stringify(this.build()) as string\n\n  /// Transform a prosemirror node tree into remark AST.\n  run = (tree: Node) => {\n    this.next(tree)\n\n    return this\n  }\n}\n"],"names":["StackElement","Stack","node","_a","el","stackOverFlow","ParserStackElement","type","content","attrs","rest","_marks","_hasText","_maybeMerge","_matchTarget","_runNode","_closeNodeAndPush","_addNodeAndPush","_ParserState","schema","__privateAdd","Mark","a","b","__privateGet","result","x","parserMatchError","nodeType","__privateSet","element","createNodeInParserFail","markType","mark","text","topElement","prevNode","currNode","merged","doc","nodes","remark","markdown","tree","ParserState","state","_SerializerStackElement","children","value","props","SerializerStackElement","_runProseNode","_runProseMark","_searchType","_maybeMergeChildren","_createMarkdownNode","_openMark","_closeMark","isFragment","_SerializerState","serializerMatchError","marks","getPriority","child","searchNode","firstChild","target","tmp","nextChildren","index","last","currChildren","currRest","prevChildren","prevRest","next","SerializerState"],"mappings":"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"}