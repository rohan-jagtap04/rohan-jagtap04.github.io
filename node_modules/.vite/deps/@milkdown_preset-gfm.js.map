{
  "version": 3,
  "sources": ["../../.pnpm/prosemirror-tables@1.3.4/node_modules/prosemirror-tables/dist/index.js", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/__internal__/with-meta.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/mark/strike-through.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/node/table/utils.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/node/table/index.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/node/footnote/definition.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/node/footnote/reference.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/node/task-list-item.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/composed/keymap.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/composed/inputrules.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/plugin/auto-insert-zero-space-plugin.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/plugin/column-resizing-plugin.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/plugin/table-editing-plugin.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/plugin/remark-gfm-plugin.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/composed/plugins.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/composed/schema.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/composed/commands.ts", "../../.pnpm/@milkdown+preset-gfm@7.2.3_@milkdown+core@7.2.3_@milkdown+ctx@7.2.3_@milkdown+preset-commonma_q5ueicltd3e2j3w4q4dfqf6kam/node_modules/@milkdown/preset-gfm/src/index.ts"],
  "sourcesContent": ["// src/index.ts\nimport { Plugin as Plugin2 } from \"prosemirror-state\";\n\n// src/cellselection.ts\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport {\n  NodeSelection as NodeSelection2,\n  Selection,\n  SelectionRange,\n  TextSelection\n} from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n  let cache = /* @__PURE__ */ new WeakMap();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key)\n        return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize)\n      cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\nvar TableMap = class {\n  constructor(width, height, map, problems) {\n    this.width = width;\n    this.height = height;\n    this.map = map;\n    this.problems = problems;\n  }\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos)\n        continue;\n      const left = i % this.width;\n      const top = i / this.width | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\n        bottom++;\n      }\n      return { left, top, right, bottom };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    const { left, right, top, bottom } = this.findCell(pos);\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width)\n        return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height)\n        return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB)\n    };\n  }\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    const result = [];\n    const seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n        if (seen[pos])\n          continue;\n        seen[pos] = true;\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0; ; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        while (index < rowEndIndex && this.map[index] < rowStart)\n          index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n};\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\")\n    throw new RangeError(\"Not a table node: \" + table.type.name);\n  const width = findWidth(table), height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems = null;\n  const colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++)\n    map[i] = 0;\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0)\n        mapPos++;\n      if (i == rowNode.childCount)\n        break;\n      const cellNode = rowNode.child(i);\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0)\n            map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: \"collision\",\n              row,\n              pos,\n              n: colspan - w\n            });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos)\n      if (map[mapPos++] == 0)\n        missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: \"missing\", row, n: missing });\n    pos++;\n  }\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height)\n      badWidths = true;\n  if (badWidths)\n    findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\nfunction findWidth(table) {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        const prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          const cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row)\n            rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1)\n        hasRowSpan = true;\n    }\n    if (width == -1)\n      width = rowWidth;\n    else if (width != rowWidth)\n      width = Math.max(width, rowWidth);\n  }\n  return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems)\n    map.problems = [];\n  const seen = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos])\n      continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    let updated = null;\n    const attrs = node.attrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: \"colwidth mismatch\",\n        pos,\n        colwidth: updated\n      });\n  }\n}\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth)\n    return attrs.colwidth.slice();\n  const result = [];\n  for (let i = 0; i < attrs.colspan; i++)\n    result.push(0);\n  return result;\n}\n\n// src/util.ts\nimport { PluginKey } from \"prosemirror-state\";\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n  if (typeof dom === \"string\") {\n    return {};\n  }\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s) => Number(s)) : null;\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  const result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n  const attrs = {};\n  if (node.attrs.colspan != 1)\n    attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1)\n    attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter)\n      setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\nfunction tableNodes(options) {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs = {\n    colspan: { default: 1 },\n    rowspan: { default: 1 },\n    colwidth: { default: null }\n  };\n  for (const prop in extraAttrs)\n    cellAttrs[prop] = { default: extraAttrs[prop].default };\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: \"table\" }],\n      toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{ tag: \"tr\" }],\n      toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"td\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"th\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name], role = type.spec.tableRole;\n      if (role)\n        result[role] = type;\n    }\n  }\n  return result;\n}\n\n// src/util.ts\nvar tableEditingKey = new PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == \"row\")\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === \"header_cell\")\n      return $pos.node(d);\n  }\n  return null;\n}\nfunction isInTable(state) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == \"row\")\n      return true;\n  return false;\n}\nfunction selectionCell(state) {\n  const sel = state.selection;\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    const role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos);\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    const role = before.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan - n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0))\n      result.colwidth = null;\n  }\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan + n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++)\n      result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n\n// src/cellselection.ts\nvar CellSelection = class extends Selection {\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween(\n      $anchorCell.pos - tableStart,\n      $headCell.pos - tableStart\n    );\n    const doc = $anchorCell.node(0);\n    const cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map((pos) => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size)\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n  map(doc, mapping) {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return CellSelection.colSelection($anchorCell, $headCell);\n      else\n        return new CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const rect = map.rectBetween(\n      this.$anchorCell.pos - tableStart,\n      this.$headCell.pos - tableStart\n    );\n    const seen = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        const pos = map.map[index];\n        if (seen[pos])\n          continue;\n        seen[pos] = true;\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw RangeError(`No cell with offset ${pos} found`);\n        }\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(\n              attrs,\n              attrs.colspan - extraRight,\n              extraRight\n            );\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw RangeError(\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`\n              );\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs);\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n  replace(tr, content = Slice.empty) {\n    const mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? Slice.empty : content\n      );\n    }\n    const sel = Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1\n    );\n    if (sel)\n      tr.setSelection(sel);\n  }\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n  forEachCell(f) {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const cells = map.cellsInRect(\n      map.rectBetween(\n        this.$anchorCell.pos - tableStart,\n        this.$headCell.pos - tableStart\n      )\n    );\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\n    }\n  }\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0)\n      return false;\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n  }\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0)\n      return false;\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n  eq(other) {\n    return other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[anchorRect.top * map.width]\n        );\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (headRect.top + 1) - 1]\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1]\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n  toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n  static fromJSON(doc, json) {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n};\nCellSelection.prototype.visible = false;\nSelection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))\n      return new CellSelection($anchorCell, $headCell);\n    else\n      return Selection.near($headCell, 1);\n  }\n};\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection))\n    return null;\n  const cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      Decoration.node(pos, pos + node.nodeSize, { class: \"selectedCell\" })\n    );\n  });\n  return DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({ $from, $to }) {\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6)\n    return false;\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth))\n      break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d))\n      break;\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize;\n  let role;\n  if (sel instanceof NodeSelection2 && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize)\n    (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// src/fixtables.ts\nimport { PluginKey as PluginKey2 } from \"prosemirror-state\";\nvar fixTablesKey = new PluginKey2(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n  const oldSize = old.childCount, curSize = cur.childCount;\n  outer:\n    for (let i = 0, j = 0; i < curSize; i++) {\n      const child = cur.child(i);\n      for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n        if (old.child(scan) == child) {\n          j = scan + 1;\n          offset += child.nodeSize;\n          continue outer;\n        }\n      }\n      f(child, offset);\n      if (j < oldSize && old.child(j).sameMarkup(child))\n        changedDescendants(old.child(j), child, offset + 1, f);\n      else\n        child.nodesBetween(0, child.content.size, f, offset + 1);\n      offset += child.nodeSize;\n    }\n}\nfunction fixTables(state, oldState) {\n  let tr;\n  const check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\")\n      tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState)\n    state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n  const map = TableMap.get(table);\n  if (!map.problems)\n    return tr;\n  if (!tr)\n    tr = state.tr;\n  const mustAdd = [];\n  for (let i = 0; i < map.height; i++)\n    mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == \"collision\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      const attrs = cell.attrs;\n      for (let j = 0; j < attrs.rowspan; j++)\n        mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)\n      );\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n\n      });\n    } else if (prob.type == \"colwidth mismatch\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth\n      });\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null)\n        first = i;\n      last = i;\n    }\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role = \"cell\";\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n        if (node)\n          nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n\n// src/input.ts\nimport { Fragment as Fragment3, Slice as Slice3 } from \"prosemirror-model\";\nimport {\n  Selection as Selection2,\n  TextSelection as TextSelection2\n} from \"prosemirror-state\";\nimport { keydownHandler } from \"prosemirror-keymap\";\n\n// src/copypaste.ts\nimport { Fragment as Fragment2, Slice as Slice2 } from \"prosemirror-model\";\nimport { Transform } from \"prosemirror-transform\";\nfunction pastedCells(slice) {\n  if (!slice.size)\n    return null;\n  let { content, openStart, openEnd } = slice;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema, rows = [];\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new Slice2(cells, left, right)\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(\n      openStart || openEnd ? fitSlice(\n        tableNodeTypes(schema).row,\n        new Slice2(content, openStart, openEnd)\n      ).content : content\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n  const widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++)\n    width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length)\n      rows.push(Fragment2.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill();\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(Fragment2.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\nfunction fitSlice(nodeType, slice) {\n  const node = nodeType.createAndFill();\n  const tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\n  if (width != newWidth) {\n    const added = [];\n    const newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row], cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.createChecked(\n            removeColSpan(\n              cell.attrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth\n            ),\n            cell.content\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [], source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            {\n              ...cell.attrs,\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n            },\n            cell.content\n          );\n        cells.push(cell);\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n  return { width, height, rows };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells = [];\n      let add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill());\n      else\n        add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++)\n        cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n      cells.push(\n        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())\n      );\n    }\n    const emptyRow = types.row.create(null, Fragment2.from(cells)), rows = [];\n    for (let i = map.height; i < height; i++)\n      rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height)\n    return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col, pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop\n      });\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill({\n          ...cell.attrs,\n          rowspan: cellTop + cell.attrs.rowspan - top\n        })\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width)\n    return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left, pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft)\n        )\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(\n          removeColSpan(cell.attrs, 0, left - cellLeft)\n        )\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error(\"No table found\");\n  }\n  let map = TableMap.get(table);\n  const { top, left } = rect;\n  const right = left + cells.width, bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error(\"No table found\");\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new Slice2(cells.rows[row - top], 0, 0)\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))\n    )\n  );\n  dispatch(tr);\n}\n\n// src/input.ts\nvar handleKeyDown = keydownHandler({\n  ArrowLeft: arrow(\"horiz\", -1),\n  ArrowRight: arrow(\"horiz\", 1),\n  ArrowUp: arrow(\"vert\", -1),\n  ArrowDown: arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  Backspace: deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  Delete: deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection))\n    return false;\n  if (dispatch)\n    dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view)\n      return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(sel.$headCell, dir)\n      );\n    }\n    if (axis != \"horiz\" && !sel.empty)\n      return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null)\n      return false;\n    if (axis == \"horiz\") {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(state.doc.resolve(sel.head + dir), dir)\n      );\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next)\n        newSel = Selection2.near($next, 1);\n      else if (dir < 0)\n        newSel = Selection2.near(state.doc.resolve($cell.before(-1)), -1);\n      else\n        newSel = Selection2.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view)\n      return false;\n    const sel = state.selection;\n    let cellSel;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null)\n        return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head)\n      return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(cellSel.$anchorCell, $head)\n    );\n  };\n}\nfunction deleteCellSelection(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection))\n    return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new Slice3(baseContent, 0, 0)\n        );\n    });\n    if (tr.docChanged)\n      dispatch(tr);\n  }\n  return true;\n}\nfunction handleTripleClick(view, pos) {\n  const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n  if (!$cell)\n    return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state))\n    return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          Fragment3.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice)\n          )\n        ]\n      };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown(view, startEvent) {\n  var _a;\n  if (startEvent.ctrlKey || startEvent.metaKey)\n    return;\n  const startDOMCell = domInCell(view, startEvent.target);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    return;\n  }\n  function setCellSelection($anchor2, event) {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor2, $head)) {\n      if (starting)\n        $head = $anchor2;\n      else\n        return;\n    }\n    const selection = new CellSelection($anchor2, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting)\n        tr.setMeta(tableEditingKey, $anchor2.pos);\n      view.dispatch(tr);\n    }\n  }\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (tableEditingKey.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n  function move(_event) {\n    const event = _event;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor2;\n    if (anchor != null) {\n      $anchor2 = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      $anchor2 = cellUnderMouse(view, startEvent);\n      if (!$anchor2)\n        return stop();\n    }\n    if ($anchor2)\n      setCellSelection($anchor2, event);\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection2))\n    return null;\n  const { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount))\n      return null;\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      const cellPos = $head.before(d);\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n  return null;\n}\nfunction cellUnderMouse(view, event) {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos)\n    return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// src/columnresizing.ts\nimport { Plugin, PluginKey as PluginKey3 } from \"prosemirror-state\";\nimport {\n  Decoration as Decoration2,\n  DecorationSet as DecorationSet2\n} from \"prosemirror-view\";\n\n// src/tableview.ts\nvar TableView = class {\n  constructor(node, cellMinWidth) {\n    this.node = node;\n    this.cellMinWidth = cellMinWidth;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"tableWrapper\";\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n    updateColumnsOnResize(node, this.colgroup, this.table, cellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n  }\n  update(node) {\n    if (node.type != this.node.type)\n      return false;\n    this.node = node;\n    updateColumnsOnResize(node, this.colgroup, this.table, this.cellMinWidth);\n    return true;\n  }\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n};\nfunction updateColumnsOnResize(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  var _a;\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  if (!row)\n    return;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const { colspan, colwidth } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth)\n        fixedWidth = false;\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth)\n          nextDOM.style.width = cssWidth;\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\n// src/columnresizing.ts\nvar columnResizingPluginKey = new PluginKey3(\n  \"tableColumnResizing\"\n);\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  View = TableView,\n  lastColumnResizable = true\n} = {}) {\n  const plugin = new Plugin({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        plugin.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (node, view) => new View(node, cellMinWidth, view);\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1 ? { class: \"resize-cursor\" } : {};\n      },\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(\n            view,\n            event,\n            handleWidth,\n            cellMinWidth,\n            lastColumnResizable\n          );\n        },\n        mouseleave: (view) => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown2(view, event, cellMinWidth);\n        }\n      },\n      decorations: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\nvar ResizeState = class {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n  apply(tr) {\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null)\n      return new ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== void 0)\n      return new ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n};\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState)\n    return;\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target);\n    let cell = -1;\n    if (target) {\n      const { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, \"left\", handleWidth);\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, \"right\", handleWidth);\n    }\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n      updateHandle(view, cell);\n    }\n  }\n}\nfunction handleMouseLeave(view) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\n    return false;\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, {\n      setDragging: { startX: event.clientX, startWidth: width }\n    })\n  );\n  function finish(event2) {\n    window.removeEventListener(\"mouseup\", finish);\n    window.removeEventListener(\"mousemove\", move);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        draggedWidth(pluginState2.dragging, event2, cellMinWidth)\n      );\n      view.dispatch(\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })\n      );\n    }\n  }\n  function move(event2) {\n    if (!event2.which)\n      return finish(event2);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (!pluginState2)\n      return;\n    if (pluginState2.dragging) {\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n      displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);\n    }\n  }\n  window.addEventListener(\"mouseup\", finish);\n  window.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width)\n    return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth, parts = colspan;\n  if (colwidth) {\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  }\n  return domWidth / parts;\n}\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  return target;\n}\nfunction edgeCell(view, event, side, handleWidth) {\n  const offset = side == \"right\" ? -handleWidth : handleWidth;\n  const found = view.posAtCoords({\n    left: event.clientX + offset,\n    top: event.clientY\n  });\n  if (!found)\n    return -1;\n  const { pos } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell)\n    return -1;\n  if (side == \"right\")\n    return $cell.pos;\n  const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })\n  );\n}\nfunction updateColumnWidth(view, cell, width) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width])\n      continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos).attrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width)\n      continue;\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });\n  }\n  if (tr.docChanged)\n    view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), start = $cell.start(-1);\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n  if (!dom)\n    return;\n  updateColumnsOnResize(\n    table,\n    dom.firstChild,\n    dom,\n    cellMinWidth,\n    col,\n    width\n  );\n}\nfunction zeroes(n) {\n  return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet2.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width - 1;\n    if ((col == map.width || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      const dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      decorations.push(Decoration2.widget(pos, dom));\n    }\n  }\n  return DecorationSet2.create(state.doc, decorations);\n}\n\n// src/commands.ts\nimport { Fragment as Fragment4 } from \"prosemirror-model\";\nimport {\n  TextSelection as TextSelection3\n} from \"prosemirror-state\";\nfunction selectedRect(state) {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect = sel instanceof CellSelection ? map.rectBetween(\n    sel.$anchorCell.pos - tableStart,\n    sel.$headCell.pos - tableStart\n  ) : map.findCell($pos.pos - tableStart);\n  return { ...rect, tableStart, map, table };\n}\nfunction addColumn(tr, { map, tableStart, table }, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs, col - map.colCount(pos))\n      );\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\nfunction removeColumn(tr, { map, table, tableStart }, col) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos);\n    const attrs = cell.attrs;\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(attrs, col - map.colCount(pos))\n      );\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width)\n      return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left)\n        break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  var _a;\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell)\n      return false;\n  return true;\n}\nfunction addRow(tr, { map, tableStart, table }, row) {\n  var _a;\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++)\n    rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n      const node = type == null ? void 0 : type.createAndFill();\n      if (node)\n        cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\nfunction removeRow(tr, { map, table, tableStart }, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++)\n    rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n    if (row > 0 && pos == map.map[index - map.width]) {\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.width && pos == map.map[index + map.width]) {\n      const cell = table.nodeAt(pos);\n      const attrs = cell.attrs;\n      const copy = cell.type.create(\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\n        cell.content\n      );\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state), tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height)\n      return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top)\n        break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction isEmpty(cell) {\n  const c = cell.content;\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\nfunction mergeCells(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)\n    return false;\n  const rect = selectedRect(state), { map } = rect;\n  if (cellsOverlapRectangle(map, rect))\n    return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen = {};\n    let content = Fragment4.empty;\n    let mergedPos;\n    let mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell)\n          continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell))\n            content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(\n        mergedCell.attrs,\n        mergedCell.attrs.colspan,\n        rect.right - rect.left - mergedCell.attrs.colspan\n      ),\n      rowspan: rect.bottom - rect.top\n    });\n    if (content.size) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))\n    );\n    dispatch(tr);\n  }\n  return true;\n}\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    var _a;\n    const sel = state.selection;\n    let cellNode;\n    let cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode)\n        return false;\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos)\n        return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1)\n        baseAttrs = { ...baseAttrs, rowspan: 1 };\n      if (baseAttrs.colspan > 1)\n        baseAttrs = { ...baseAttrs, colspan: 1 };\n      const rect = selectedRect(state), tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth ? {\n            ...baseAttrs,\n            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n          } : baseAttrs\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top)\n          pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top)\n            continue;\n          tr.insert(\n            lastCell = tr.mapping.map(pos + rect.tableStart, 1),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0]\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell ? tr.doc.resolve(lastCell) : void 0\n          )\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value)\n      return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, {\n              ...node.attrs,\n              [name]: value\n            });\n        });\n      else\n        tr.setNodeMarkup($cell.pos, null, {\n          ...$cell.nodeAfter.attrs,\n          [name]: value\n        });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction deprecated_toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const cells = rect.map.cellsInRect(\n        type == \"column\" ? {\n          left: rect.left,\n          top: 0,\n          right: rect.right,\n          bottom: rect.map.height\n        } : type == \"row\" ? {\n          left: 0,\n          top: rect.top,\n          right: rect.map.width,\n          bottom: rect.bottom\n        } : rect\n      );\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos));\n      for (let i = 0; i < cells.length; i++)\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs\n          );\n      if (tr.steps.length == 0)\n        for (let i = 0; i < cells.length; i++)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false };\n  if (options.useDeprecatedLogic)\n    return deprecated_toggleHeader(type);\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\n        \"column\",\n        rect,\n        types\n      );\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      const cellsRect = type == \"column\" ? {\n        left: 0,\n        top: selectionStartsAt,\n        right: 1,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: selectionStartsAt,\n        top: 0,\n        right: rect.map.width,\n        bottom: 1\n      } : rect;\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before)\n      return $cell.pos - before.nodeSize;\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount)\n        return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\nfunction goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null)\n      return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr.setSelection(TextSelection3.between($cell, moveCellForward($cell))).scrollIntoView()\n      );\n    }\n    return true;\n  };\n}\nfunction deleteTable(state, dispatch) {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()\n        );\n      return true;\n    }\n  }\n  return false;\n}\n\n// src/index.ts\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new Plugin2({\n    key: tableEditingKey,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null)\n          return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged)\n          return cur;\n        const { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n      },\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection\n      );\n    }\n  });\n}\nexport {\n  CellBookmark,\n  CellSelection,\n  ResizeState,\n  TableMap,\n  TableView,\n  clipCells as __clipCells,\n  insertCells as __insertCells,\n  pastedCells as __pastedCells,\n  addColSpan,\n  addColumn,\n  addColumnAfter,\n  addColumnBefore,\n  addRow,\n  addRowAfter,\n  addRowBefore,\n  cellAround,\n  colCount,\n  columnIsHeader,\n  columnResizing,\n  columnResizingPluginKey,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  findCell,\n  fixTables,\n  fixTablesKey,\n  goToNextCell,\n  handlePaste,\n  inSameTable,\n  isInTable,\n  mergeCells,\n  moveCellForward,\n  nextCell,\n  pointsAtCell,\n  removeColSpan,\n  removeColumn,\n  removeRow,\n  rowIsHeader,\n  selectedRect,\n  selectionCell,\n  setCellAttr,\n  splitCell,\n  splitCellWithType,\n  tableEditing,\n  tableEditingKey,\n  tableNodeTypes,\n  tableNodes,\n  toggleHeader,\n  toggleHeaderCell,\n  toggleHeaderColumn,\n  toggleHeaderRow,\n  updateColumnsOnResize\n};\n", "/* Copyright 2021, Milkdown by Mirone. */\nimport type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport const withMeta = <T extends MilkdownPlugin>(\n  plugin: T,\n  meta: Partial<Meta> & Pick<Meta, 'displayName'>,\n): T => {\n  Object.assign(plugin, {\n    meta: {\n      package: '@milkdown/preset-gfm',\n      ...meta,\n    },\n  })\n\n  return plugin\n}\n", "/* Copyright 2021, Milkdown by Mirone. */\nimport { commandsCtx } from '@milkdown/core'\nimport { $command, $markAttr, $markSchema, $useKeymap } from '@milkdown/utils'\nimport { toggleMarkdownMark } from '@milkdown/prose'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the strikethrough mark.\nexport const strikethroughAttr = $markAttr('strike_through')\n\nwithMeta(strikethroughAttr, {\n  displayName: 'Attr<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Strikethrough mark schema.\nexport const strikethroughSchema = $markSchema('strike_through', ctx => ({\n  parseDOM: [\n    { tag: 'del' },\n    { style: 'text-decoration', getAttrs: value => (value === 'line-through') as false },\n  ],\n  toDOM: mark => ['del', ctx.get(strikethroughAttr.key)(mark)],\n  parseMarkdown: {\n    match: node => node.type === 'delete',\n    runner: (state, node, markType) => {\n      state.openMark(markType)\n      state.next(node.children)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: mark => mark.type.name === 'strike_through',\n    runner: (state, mark) => {\n      state.withMark(mark, 'delete')\n    },\n  },\n}))\n\nwithMeta(strikethroughSchema.mark, {\n  displayName: 'MarkSchema<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughSchema.ctx, {\n  displayName: 'MarkSchemaCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// A command to toggle the strikethrough mark.\nexport const toggleStrikethroughCommand = $command('ToggleStrikeThrough', () => () => {\n  const markType = strikethroughSchema.type()\n  const mark = '~~'\n  return toggleMarkdownMark(markType, mark)\n})\n\nwithMeta(toggleStrikethroughCommand, {\n  displayName: 'Command<ToggleStrikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Keymap for the strikethrough mark.\n/// - `Mod-Alt-x` - Toggle the strikethrough mark.\nexport const strikethroughKeymap = $useKeymap('strikeThroughKeymap', {\n  ToggleStrikethrough: {\n    shortcuts: 'Mod-Alt-x',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(toggleStrikethroughCommand.key)\n    },\n  },\n})\n\nwithMeta(strikethroughKeymap.ctx, {\n  displayName: 'KeymapCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughKeymap.shortcuts, {\n  displayName: 'Keymap<strikethrough>',\n  group: 'Strikethrough',\n})\n", "/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { ContentNodeWithPos } from '@milkdown/prose'\nimport { cloneTr, findParentNode } from '@milkdown/prose'\nimport type { Node } from '@milkdown/prose/model'\nimport type { Selection, Transaction } from '@milkdown/prose/state'\nimport type { TableRect } from '@milkdown/prose/tables'\nimport { CellSelection, TableMap } from '@milkdown/prose/tables'\n\nimport { tableCellSchema, tableHeaderSchema, tableRowSchema, tableSchema } from '.'\n\n/// @internal\nexport interface CellPos {\n  pos: number\n  start: number\n  node: Node\n}\n\n/// @internal\nexport const createTable = (rowsCount = 3, colsCount = 3): Node => {\n  const cells = Array(colsCount)\n    .fill(0)\n    .map(() => tableCellSchema.type().createAndFill()!)\n\n  const headerCells = Array(colsCount)\n    .fill(0)\n    .map(() => tableHeaderSchema.type().createAndFill()!)\n\n  const rows = Array(rowsCount)\n    .fill(0)\n    .map((_, i) => tableRowSchema.type().create(null, i === 0 ? headerCells : cells))\n\n  return tableSchema.type().create(null, rows)\n}\n\n/// Find the table node with position information for current selection.\nexport const findTable = (selection: Selection) =>\n  findParentNode(node => node.type.spec.tableRole === 'table')(selection)\n\n/// Get cells in a column of a table.\nexport const getCellsInCol = (columnIndex: number, selection: Selection): CellPos[] | undefined => {\n  const table = findTable(selection)\n  if (!table)\n    return undefined\n  const map = TableMap.get(table.node)\n  if (columnIndex < 0 || columnIndex >= map.width)\n    return undefined\n\n  return map\n    .cellsInRect({ left: columnIndex, right: columnIndex + 1, top: 0, bottom: map.height })\n    .map((pos) => {\n      const node = table.node.nodeAt(pos)\n      if (!node)\n        return undefined\n      const start = pos + table.start\n      return {\n        pos: start,\n        start: start + 1,\n        node,\n      }\n    })\n    .filter((x): x is CellPos => x != null)\n}\n\n/// Get cells in a row of a table.\nexport const getCellsInRow = (rowIndex: number, selection: Selection): CellPos[] | undefined => {\n  const table = findTable(selection)\n  if (!table)\n    return undefined\n  const map = TableMap.get(table.node)\n  if (rowIndex < 0 || rowIndex >= map.height)\n    return undefined\n\n  return map\n    .cellsInRect({ left: 0, right: map.width, top: rowIndex, bottom: rowIndex + 1 })\n    .map((pos) => {\n      const node = table.node.nodeAt(pos)\n      if (!node)\n        return undefined\n      const start = pos + table.start\n      return {\n        pos: start,\n        start: start + 1,\n        node,\n      }\n    })\n    .filter((x): x is CellPos => x != null)\n}\n\n/// Get all cells in a table.\nexport const getAllCellsInTable = (selection: Selection) => {\n  const table = findTable(selection)\n  if (!table)\n    return\n\n  const map = TableMap.get(table.node)\n  const cells = map.cellsInRect({\n    left: 0,\n    right: map.width,\n    top: 0,\n    bottom: map.height,\n  })\n  return cells.map((nodePos) => {\n    const node = table.node.nodeAt(nodePos)\n    const pos = nodePos + table.start\n    return { pos, start: pos + 1, node }\n  })\n}\n\n/// Select a possible table in current selection.\nexport const selectTable = (tr: Transaction) => {\n  const cells = getAllCellsInTable(tr.selection)\n  if (cells && cells[0]) {\n    const $firstCell = tr.doc.resolve(cells[0].pos)\n    const last = cells[cells.length - 1]\n    if (last) {\n      const $lastCell = tr.doc.resolve(last.pos)\n      return cloneTr(tr.setSelection(new CellSelection($lastCell, $firstCell)))\n    }\n  }\n  return tr\n}\n\n/// @internal\nexport function addRowWithAlignment(tr: Transaction, { map, tableStart, table }: TableRect, row: number) {\n  const rowPos = Array(row)\n    .fill(0)\n    .reduce((acc, _, i) => {\n      return acc + table.child(i).nodeSize\n    }, tableStart)\n\n  const cells = Array(map.width)\n    .fill(0)\n    .map((_, col) => {\n      const headerCol = table.nodeAt(map.map[col] as number)\n      return tableCellSchema.type().createAndFill({ alignment: headerCol?.attrs.alignment }) as Node\n    })\n\n  tr.insert(rowPos, tableRowSchema.type().create(null, cells))\n  return tr\n}\n\n/// @internal\nexport const selectLine = (type: 'row' | 'col') => (index: number) => (tr: Transaction) => {\n  const table = findTable(tr.selection)\n  const isRowSelection = type === 'row'\n  if (table) {\n    const map = TableMap.get(table.node)\n\n    // Check if the index is valid\n    if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {\n      const lastCell = map.positionAt(\n        isRowSelection ? index : map.height - 1,\n        isRowSelection ? map.width - 1 : index,\n        table.node,\n      )\n      const $lastCell = tr.doc.resolve(table.start + lastCell)\n\n      const createCellSelection = isRowSelection ? CellSelection.rowSelection : CellSelection.colSelection\n\n      const firstCell = map.positionAt(isRowSelection ? index : 0, isRowSelection ? 0 : index, table.node)\n      const $firstCell = tr.doc.resolve(table.start + firstCell)\n      return cloneTr(tr.setSelection(createCellSelection($lastCell, $firstCell) as unknown as Selection))\n    }\n  }\n  return tr\n}\n\n/// If the selection is in a table,\n/// select the {index} row.\nexport const selectRow = selectLine('row')\n\n/// If the selection is in a table,\n/// select the {index} column.\nexport const selectCol = selectLine('col')\n\nconst transpose = <T>(array: T[][]) => {\n  return array[0]!.map((_, i) => {\n    return array.map(column => column[i])\n  }) as T[][]\n}\n\nconst convertArrayOfRowsToTableNode = (tableNode: Node, arrayOfNodes: (Node | null)[][]) => {\n  const rowsPM = []\n  const map = TableMap.get(tableNode)\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const row = tableNode.child(rowIndex)\n    const rowCells = []\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      if (!arrayOfNodes[rowIndex]![colIndex])\n        continue\n\n      const cellPos = map.map[rowIndex * map.width + colIndex]!\n\n      const cell = arrayOfNodes[rowIndex]![colIndex]!\n      const oldCell = tableNode.nodeAt(cellPos)!\n      const newCell = oldCell.type.createChecked(\n        Object.assign({}, cell.attrs),\n        cell.content,\n        cell.marks,\n      )\n      rowCells.push(newCell)\n    }\n\n    rowsPM.push(row.type.createChecked(row.attrs, rowCells, row.marks))\n  }\n\n  const newTable = tableNode.type.createChecked(\n    tableNode.attrs,\n    rowsPM,\n    tableNode.marks,\n  )\n\n  return newTable\n}\n\nconst convertTableNodeToArrayOfRows = (tableNode: Node) => {\n  const map = TableMap.get(tableNode)\n  const rows: (Node | null)[][] = []\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const rowCells: (Node | null)[] = []\n    const seen: Record<number, boolean> = {}\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      const cellPos = map.map[rowIndex * map.width + colIndex]!\n      const cell = tableNode.nodeAt(cellPos)\n      const rect = map.findCell(cellPos)\n      if (seen[cellPos] || rect.top !== rowIndex) {\n        rowCells.push(null)\n        continue\n      }\n      seen[cellPos] = true\n\n      rowCells.push(cell)\n    }\n\n    rows.push(rowCells)\n  }\n\n  return rows\n}\n\nconst moveRowInArrayOfRows = (\n  rows: (Node | null)[][],\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  directionOverride: -1 | 1 | 0,\n) => {\n  const direction = indexesOrigin[0]! > indexesTarget[0]! ? -1 : 1\n\n  const rowsExtracted = rows.splice(indexesOrigin[0]!, indexesOrigin.length)\n  const positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0\n  let target: number\n\n  if (directionOverride === -1 && direction === 1) {\n    target = indexesTarget[0]! - 1\n  }\n  else if (directionOverride === 1 && direction === -1) {\n    target = indexesTarget[indexesTarget.length - 1]! - positionOffset + 1\n  }\n  else {\n    target\n      = direction === -1\n        ? indexesTarget[0]!\n        : indexesTarget[indexesTarget.length - 1]! - positionOffset\n  }\n\n  rows.splice(target, 0, ...rowsExtracted)\n  return rows\n}\n\nconst moveTableColumn = (\n  table: ContentNodeWithPos,\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  direction: -1 | 1 | 0,\n) => {\n  let rows = transpose(convertTableNodeToArrayOfRows(table.node))\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction)\n  rows = transpose(rows)\n\n  return convertArrayOfRowsToTableNode(table.node, rows)\n}\n\nconst moveTableRow = (\n  table: ContentNodeWithPos,\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  direction: -1 | 1 | 0,\n) => {\n  let rows = convertTableNodeToArrayOfRows(table.node)\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction)\n\n  return convertArrayOfRowsToTableNode(table.node, rows)\n}\n\nconst getSelectionRangeInColumn = (columnIndex: number, tr: Transaction) => {\n  let startIndex = columnIndex\n  let endIndex = columnIndex\n\n  // looking for selection start column (startIndex)\n  for (let i = columnIndex; i >= 0; i--) {\n    const cells = getCellsInCol(i, tr.selection)\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1\n        if (maybeEndIndex >= startIndex)\n          startIndex = i\n\n        if (maybeEndIndex > endIndex)\n          endIndex = maybeEndIndex\n      })\n    }\n  }\n  // looking for selection end column (endIndex)\n  for (let i = columnIndex; i <= endIndex; i++) {\n    const cells = getCellsInCol(i, tr.selection)\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1\n        if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex)\n          endIndex = maybeEndIndex\n      })\n    }\n  }\n\n  // filter out columns without cells (where all rows have colspan > 1 in the same column)\n  const indexes = []\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInCol(i, tr.selection)\n    if (maybeCells && maybeCells.length)\n      indexes.push(i)\n  }\n  startIndex = indexes[0]!\n  endIndex = indexes[indexes.length - 1]!\n\n  const firstSelectedColumnCells = getCellsInCol(startIndex, tr.selection)!\n  const firstRowCells = getCellsInRow(0, tr.selection)!\n  const $anchor = tr.doc.resolve(\n    firstSelectedColumnCells[firstSelectedColumnCells.length - 1]!.pos,\n  )\n\n  let headCell: CellPos | undefined\n  for (let i = endIndex; i >= startIndex; i--) {\n    const columnCells = getCellsInCol(i, tr.selection)\n    if (columnCells && columnCells.length) {\n      for (let j = firstRowCells.length - 1; j >= 0; j--) {\n        if (firstRowCells[j]!.pos === columnCells[0]!.pos) {\n          headCell = columnCells[0]\n          break\n        }\n      }\n      if (headCell)\n        break\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell!.pos)\n  return { $anchor, $head, indexes }\n}\n\nconst getSelectionRangeInRow = (rowIndex: number, tr: Transaction) => {\n  let startIndex = rowIndex\n  let endIndex = rowIndex\n  // looking for selection start row (startIndex)\n  for (let i = rowIndex; i >= 0; i--) {\n    const cells = getCellsInRow(i, tr.selection)\n    cells!.forEach((cell) => {\n      const maybeEndIndex = cell.node.attrs.rowspan + i - 1\n      if (maybeEndIndex >= startIndex)\n        startIndex = i\n\n      if (maybeEndIndex > endIndex)\n        endIndex = maybeEndIndex\n    })\n  }\n  // looking for selection end row (endIndex)\n  for (let i = rowIndex; i <= endIndex; i++) {\n    const cells = getCellsInRow(i, tr.selection)\n    cells!.forEach((cell) => {\n      const maybeEndIndex = cell.node.attrs.rowspan + i - 1\n      if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex)\n        endIndex = maybeEndIndex\n    })\n  }\n\n  // filter out rows without cells (where all columns have rowspan > 1 in the same row)\n  const indexes = []\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInRow(i, tr.selection)\n    if (maybeCells && maybeCells.length)\n      indexes.push(i)\n  }\n  startIndex = indexes[0]!\n  endIndex = indexes[indexes.length - 1]!\n\n  const firstSelectedRowCells = getCellsInRow(startIndex, tr.selection)!\n  const firstColumnCells = getCellsInCol(0, tr.selection)!\n  const $anchor = tr.doc.resolve(firstSelectedRowCells[firstSelectedRowCells.length - 1]!.pos)\n\n  let headCell: CellPos | undefined\n  for (let i = endIndex; i >= startIndex; i--) {\n    const rowCells = getCellsInRow(i, tr.selection)\n    if (rowCells && rowCells.length) {\n      for (let j = firstColumnCells.length - 1; j >= 0; j--) {\n        if (firstColumnCells[j]!.pos === rowCells[0]!.pos) {\n          headCell = rowCells[0]!\n          break\n        }\n      }\n      if (headCell)\n        break\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell!.pos)\n  return { $anchor, $head, indexes }\n}\n\n/// If the selection is in a table,\n/// Move the columns at `origin` to `target` in current table.\n/// The `select` is true by default, which means the selection will be set to the moved column.\nexport function moveCol(tr: Transaction, origin: number, target: number, select = true) {\n  const table = findTable(tr.selection)\n  if (!table)\n    return tr\n\n  const { indexes: indexesOriginColumn } = getSelectionRangeInColumn(origin, tr)\n  const { indexes: indexesTargetColumn } = getSelectionRangeInColumn(target, tr)\n\n  if (indexesOriginColumn.includes(target))\n    return tr\n\n  const newTable = moveTableColumn(\n    table,\n    indexesOriginColumn,\n    indexesTargetColumn,\n    0,\n  )\n\n  const _tr = cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable,\n  )\n\n  if (!select)\n    return _tr\n\n  const map = TableMap.get(newTable)\n  const start = table.start\n  const index = target\n  const lastCell = map.positionAt(map.height - 1, index, newTable)\n  const $lastCell = _tr.doc.resolve(start + lastCell)\n\n  const createCellSelection = CellSelection.colSelection\n\n  const firstCell = map.positionAt(0, index, newTable)\n  const $firstCell = _tr.doc.resolve(start + firstCell)\n\n  return _tr.setSelection(createCellSelection($lastCell, $firstCell))\n}\n\n/// If the selection is in a table,\n/// Move the rows at `origin` and `target` in current table.\n/// The `select` is true by default, which means the selection will be set to the moved row.\nexport function moveRow(tr: Transaction, origin: number, target: number, select = true) {\n  const table = findTable(tr.selection)\n  if (!table)\n    return tr\n\n  const { indexes: indexesOriginRow } = getSelectionRangeInRow(origin, tr)\n  const { indexes: indexesTargetRow } = getSelectionRangeInRow(target, tr)\n\n  if (indexesOriginRow.includes(target))\n    return tr\n\n  const newTable = moveTableRow(\n    table,\n    indexesOriginRow,\n    indexesTargetRow,\n    0,\n  )\n\n  const _tr = cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable,\n  )\n\n  if (!select)\n    return _tr\n\n  const map = TableMap.get(newTable)\n  const start = table.start\n  const index = target\n  const lastCell = map.positionAt(index, map.width - 1, newTable)\n  const $lastCell = _tr.doc.resolve(start + lastCell)\n\n  const createCellSelection = CellSelection.rowSelection\n\n  const firstCell = map.positionAt(index, 0, newTable)\n  const $firstCell = _tr.doc.resolve(start + firstCell)\n\n  return _tr.setSelection(createCellSelection($lastCell, $firstCell))\n}\n", "/* Copyright 2021, Milkdown by Mirone. */\nimport type { MarkdownNode } from '@milkdown/transformer'\nimport { commandsCtx } from '@milkdown/core'\nimport { paragraphSchema } from '@milkdown/preset-commonmark'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport type { NodeType } from '@milkdown/prose/model'\nimport { Selection, TextSelection } from '@milkdown/prose/state'\nimport { CellSelection, addColumnAfter, addColumnBefore, deleteColumn, deleteRow, deleteTable, goToNextCell, isInTable, selectedRect, setCellAttr, tableNodes } from '@milkdown/prose/tables'\nimport { $command, $inputRule, $nodeSchema, $useKeymap } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\nimport { addRowWithAlignment, createTable, moveCol, moveRow, selectCol, selectRow, selectTable } from './utils'\n\nconst originalSchema = tableNodes({\n  tableGroup: 'block',\n  cellContent: 'paragraph',\n  cellAttributes: {\n    alignment: {\n      default: 'left',\n      getFromDOM: dom => (dom as HTMLElement).style.textAlign || 'left',\n      setDOMAttr: (value, attrs) => {\n        attrs.style = `text-align: ${value || 'left'}`\n      },\n    },\n  },\n})\n\n/// Schema for table node.\nexport const tableSchema = $nodeSchema('table', () => ({\n  ...originalSchema.table,\n  parseMarkdown: {\n    match: node => node.type === 'table',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align,\n        isHeader: i === 0,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table',\n    runner: (state, node) => {\n      const firstLine = node.content.firstChild?.content\n      if (!firstLine)\n        return\n\n      const align: (string | null)[] = []\n      firstLine.forEach((cell) => {\n        align.push(cell.attrs.alignment)\n      })\n      state.openNode('table', undefined, { align })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableSchema.node, {\n  displayName: 'NodeSchema<table>',\n  group: 'Table',\n})\n\nwithMeta(tableSchema.ctx, {\n  displayName: 'NodeSchemaCtx<table>',\n  group: 'Table',\n})\n\n/// Schema for table row node.\nexport const tableRowSchema = $nodeSchema('table_row', () => ({\n  ...originalSchema.table_row,\n  parseMarkdown: {\n    match: node => node.type === 'tableRow',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align: align[i],\n        isHeader: node.isHeader,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_row',\n    runner: (state, node) => {\n      state.openNode('tableRow')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableRowSchema.node, {\n  displayName: 'NodeSchema<tableRow>',\n  group: 'Table',\n})\n\nwithMeta(tableRowSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableRow>',\n  group: 'Table',\n})\n\n/// Schema for table cell node.\nexport const tableCellSchema = $nodeSchema('table_cell', () => ({\n  ...originalSchema.table_cell,\n  parseMarkdown: {\n    match: node => node.type === 'tableCell' && !node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state\n        .openNode(type, { alignment: align })\n        .openNode(state.schema.nodes.paragraph as NodeType)\n        .next(node.children)\n        .closeNode()\n        .closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_cell',\n    runner: (state, node) => {\n      state.openNode('tableCell').next(node.content).closeNode()\n    },\n  },\n}))\n\nwithMeta(tableCellSchema.node, {\n  displayName: 'NodeSchema<tableCell>',\n  group: 'Table',\n})\n\nwithMeta(tableCellSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableCell>',\n  group: 'Table',\n})\n\n/// Schema for table header node.\nexport const tableHeaderSchema = $nodeSchema('table_header', () => ({\n  ...originalSchema.table_header,\n  parseMarkdown: {\n    match: node => node.type === 'tableCell' && !!node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state.openNode(type, { alignment: align })\n      state.openNode(state.schema.nodes.paragraph as NodeType)\n      state.next(node.children)\n      state.closeNode()\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_header',\n    runner: (state, node) => {\n      state.openNode('tableCell')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableHeaderSchema.node, {\n  displayName: 'NodeSchema<tableHeader>',\n  group: 'Table',\n})\n\nwithMeta(tableHeaderSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableHeader>',\n  group: 'Table',\n})\n\n/// A input rule for creating table.\n/// For example, `|2x2|` will create a 2x2 table.\nexport const insertTableInputRule = $inputRule(() => new InputRule(\n  /^\\|(?<col>\\d+)[xX](?<row>\\d+)\\|\\s$/, (state, match, start, end) => {\n    const $start = state.doc.resolve(start)\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), tableSchema.type()))\n      return null\n\n    const tableNode = createTable(\n      Number(match.groups?.row),\n      Number(match.groups?.col),\n    )\n    const tr = state.tr.replaceRangeWith(start, end, tableNode).scrollIntoView()\n    return tr.setSelection(TextSelection.create(tr.doc, start + 3))\n  },\n))\n\nwithMeta(insertTableInputRule, {\n  displayName: 'InputRule<insertTableInputRule>',\n  group: 'Table',\n})\n\n/// A command for moving cursor to previous cell.\nexport const goToPrevTableCellCommand = $command('GoToPrevTableCell', () => () => goToNextCell(-1))\n\nwithMeta(goToPrevTableCellCommand, {\n  displayName: 'Command<goToPrevTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for moving cursor to next cell.\nexport const goToNextTableCellCommand = $command('GoToNextTableCell', () => () => goToNextCell(1))\n\nwithMeta(goToNextTableCellCommand, {\n  displayName: 'Command<goToNextTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for splitting current table into two tables.\n/// If the selection is at the end of the table,\n/// it will just quit the table and insert a new paragraph node.\nexport const breakTableCommand = $command('BreakTable', () => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n\n  const { $head } = state.selection\n  const pos = $head.after()\n  const tr = state.tr\n    .replaceWith(pos, pos, paragraphSchema.type().createAndFill()!)\n\n  tr.setSelection(Selection.near(tr.doc.resolve(pos), 1)).scrollIntoView()\n  dispatch?.(tr)\n  return true\n})\n\nwithMeta(breakTableCommand, {\n  displayName: 'Command<breakTableCommand>',\n  group: 'Table',\n})\n\n/// A command for inserting a table.\n/// You can specify the number of rows and columns.\n/// By default, it will insert a 3x3 table.\nexport const insertTableCommand = $command('InsertTable', () => ({ row, col }: { row?: number; col?: number } = {}) => (state, dispatch) => {\n  const { selection, tr } = state\n  const { from } = selection\n  const table = createTable(row, col)\n  const _tr = tr.replaceSelectionWith(table)\n  const sel = Selection.findFrom(_tr.doc.resolve(from), 1, true)\n  if (sel)\n    dispatch?.(_tr.setSelection(sel))\n\n  return true\n})\n\nwithMeta(insertTableCommand, {\n  displayName: 'Command<insertTableCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a row in a table.\n/// You should specify the `from` and `to` index.\nexport const moveRowCommand = $command('MoveRow', () => ({ from, to }: { from?: number; to?: number } = {}) => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(moveRow(tr, from ?? 0, to ?? 0, true))\n\n  return Boolean(result)\n})\n\nwithMeta(moveRowCommand, {\n  displayName: 'Command<moveRowCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a column in a table.\n/// You should specify the `from` and `to` index.\nexport const moveColCommand = $command('MoveCol', () => ({ from, to }: { from?: number; to?: number } = {}) => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(moveCol(tr, from ?? 0, to ?? 0, true))\n\n  return Boolean(result)\n})\n\nwithMeta(moveColCommand, {\n  displayName: 'Command<moveColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a row.\nexport const selectRowCommand = $command<number, 'SelectRow'>('SelectRow', () => (index = 0) => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(selectRow(index)(tr))\n\n  return Boolean(result)\n})\n\nwithMeta(selectRowCommand, {\n  displayName: 'Command<selectRowCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a column.\nexport const selectColCommand = $command<number, 'SelectCol'>('SelectCol', () => (index = 0) => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(selectCol(index)(tr))\n\n  return Boolean(result)\n})\n\nwithMeta(selectColCommand, {\n  displayName: 'Command<selectColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a table.\nexport const selectTableCommand = $command('SelectTable', () => () => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(selectTable(tr))\n\n  return Boolean(result)\n})\n\nwithMeta(selectTableCommand, {\n  displayName: 'Command<selectTableCommand>',\n  group: 'Table',\n})\n\n/// A command for deleting selected cells.\n/// If the selection is a row or column, the row or column will be deleted.\n/// If all cells are selected, the table will be deleted.\nexport const deleteSelectedCellsCommand = $command('DeleteSelectedCells', () => () => (state, dispatch) => {\n  const { selection } = state\n  if (!(selection instanceof CellSelection))\n    return false\n\n  const isRow = selection.isRowSelection()\n  const isCol = selection.isColSelection()\n\n  if (isRow && isCol)\n    return deleteTable(state, dispatch)\n\n  if (isCol)\n    return deleteColumn(state, dispatch)\n\n  else\n    return deleteRow(state, dispatch)\n})\n\nwithMeta(deleteSelectedCellsCommand, {\n  displayName: 'Command<deleteSelectedCellsCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column before the current column.\nexport const addColBeforeCommand = $command('AddColBefore', () => () => addColumnBefore)\n\nwithMeta(addColBeforeCommand, {\n  displayName: 'Command<addColBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column after the current column.\nexport const addColAfterCommand = $command('AddColAfter', () => () => addColumnAfter)\n\nwithMeta(addColAfterCommand, {\n  displayName: 'Command<addColAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row before the current row.\nexport const addRowBeforeCommand = $command('AddRowBefore', () => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n  if (dispatch) {\n    const rect = selectedRect(state)\n    dispatch(addRowWithAlignment(state.tr, rect, rect.top))\n  }\n  return true\n})\n\nwithMeta(addRowBeforeCommand, {\n  displayName: 'Command<addRowBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row after the current row.\nexport const addRowAfterCommand = $command('AddRowAfter', () => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n  if (dispatch) {\n    const rect = selectedRect(state)\n    dispatch(addRowWithAlignment(state.tr, rect, rect.bottom))\n  }\n  return true\n})\n\nwithMeta(addRowAfterCommand, {\n  displayName: 'Command<addRowAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for setting alignment property for selected cells.\n/// You can specify the alignment as `left`, `center`, or `right`.\n/// It's `left` by default.\nexport const setAlignCommand = $command<'left' | 'center' | 'right', 'SetAlign'>('SetAlign', () => (alignment = 'left') => setCellAttr('alignment', alignment))\n\nwithMeta(setAlignCommand, {\n  displayName: 'Command<setAlignCommand>',\n  group: 'Table',\n})\n\n/// Keymap for table commands.\n/// - `<Mod-]>`/`<Tab>`: Move to the next cell.\n/// - `<Mod-[>`/`<Shift-Tab>`: Move to the previous cell.\n/// - `<Mod-Enter>`: Exit the table, and break it if possible.\nexport const tableKeymap = $useKeymap('tableKeymap', {\n  NextCell: {\n    shortcuts: ['Mod-]', 'Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToNextTableCellCommand.key)\n    },\n  },\n  PrevCell: {\n    shortcuts: ['Mod-[', 'Shift-Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToPrevTableCellCommand.key)\n    },\n  },\n  ExitTable: {\n    shortcuts: ['Mod-Enter'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(breakTableCommand.key)\n    },\n  },\n})\n\nwithMeta(tableKeymap.ctx, {\n  displayName: 'KeymapCtx<table>',\n  group: 'Table',\n})\n\nwithMeta(tableKeymap.shortcuts, {\n  displayName: 'Keymap<table>',\n  group: 'Table',\n})\n\nexport * from './utils'\n", "/* Copyright 2021, Milkdown by Mirone. */\n\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_definition'\nconst markdownId = 'footnoteDefinition'\n\n/// Footnote definition node schema.\nexport const footnoteDefinitionSchema = $nodeSchema('footnote_definition', () => ({\n  group: 'block',\n  content: 'block+',\n  defining: true,\n  attrs: {\n    label: {\n      default: '',\n    },\n  },\n  parseDOM: [\n    {\n      tag: `dl[data-type=\"${id}\"]`,\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement))\n          throw expectDomTypeError(dom)\n\n        return {\n          label: dom.dataset.label,\n        }\n      },\n      contentElement: 'dd',\n    },\n  ],\n  toDOM: (node) => {\n    const label = node.attrs.label\n\n    return [\n      'dl',\n      {\n        // TODO: add a prosemirror plugin to sync label on change\n        'data-label': label,\n        'data-type': id,\n      },\n      ['dt', label],\n      ['dd', 0],\n    ]\n  },\n  parseMarkdown: {\n    match: ({ type }) => type === markdownId,\n    runner: (state, node, type) => {\n      state\n        .openNode(type, {\n          label: node.label as string,\n        })\n        .next(node.children)\n        .closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === id,\n    runner: (state, node) => {\n      state\n        .openNode(markdownId, undefined, {\n          label: node.attrs.label,\n          identifier: node.attrs.label,\n        })\n        .next(node.content)\n        .closeNode()\n    },\n  },\n}))\n\nwithMeta(footnoteDefinitionSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeDef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteDefinitionSchema.node, {\n  displayName: 'NodeSchema<footnodeDef>',\n  group: 'footnote',\n})\n", "/* Copyright 2021, Milkdown by Mirone. */\n\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_reference'\n\n/// Footnote reference node schema.\nexport const footnoteReferenceSchema = $nodeSchema('footnote_reference', () => ({\n  group: 'inline',\n  inline: true,\n  atom: true,\n  attrs: {\n    label: {\n      default: '',\n    },\n  },\n  parseDOM: [\n    {\n      tag: `sup[data-type=\"${id}\"]`,\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement))\n          throw expectDomTypeError(dom)\n\n        return {\n          label: dom.dataset.label,\n        }\n      },\n    },\n  ],\n  toDOM: (node) => {\n    const label = node.attrs.label\n    return [\n      'sup',\n      {\n        // TODO: add a prosemirror plugin to sync label on change\n        'data-label': label,\n        'data-type': id,\n      },\n      label,\n    ]\n  },\n  parseMarkdown: {\n    match: ({ type }) => type === 'footnoteReference',\n    runner: (state, node, type) => {\n      state.addNode(type, {\n        label: node.label as string,\n      })\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === id,\n    runner: (state, node) => {\n      state.addNode('footnoteReference', undefined, undefined, {\n        label: node.attrs.label,\n        identifier: node.attrs.label,\n      })\n    },\n  },\n}))\n\nwithMeta(footnoteReferenceSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeRef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteReferenceSchema.node, {\n  displayName: 'NodeSchema<footnodeRef>',\n  group: 'footnote',\n})\n", "/* Copyright 2021, Milkdown by Mirone. */\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { listItemSchema } from '@milkdown/preset-commonmark'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { $inputRule } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This schema extends the [list item](/preset-commonmark#list-item) schema and add task list support for it.\nexport const extendListItemSchemaForTask = listItemSchema.extendSchema((prev) => {\n  return (ctx) => {\n    const baseSchema = prev(ctx)\n    return {\n      ...baseSchema,\n      attrs: {\n        ...baseSchema.attrs,\n        checked: {\n          default: null,\n        },\n      },\n      parseDOM: [\n        {\n          tag: 'li[data-item-type=\"task\"]',\n          getAttrs: (dom) => {\n            if (!(dom instanceof HTMLElement))\n              throw expectDomTypeError(dom)\n\n            return {\n              label: dom.dataset.label,\n              listType: dom.dataset['list-type'],\n              spread: dom.dataset.spread,\n              checked: dom.dataset.checked ? dom.dataset.checked === 'true' : null,\n            }\n          },\n        },\n        ...baseSchema?.parseDOM || [],\n      ],\n      toDOM: (node) => {\n        if (baseSchema.toDOM && node.attrs.checked == null)\n          return baseSchema.toDOM(node)\n\n        return [\n          'li',\n          {\n            'data-item-type': 'task',\n            'data-label': node.attrs.label,\n            'data-list-type': node.attrs.listType,\n            'data-spread': node.attrs.spread,\n            'data-checked': node.attrs.checked,\n          },\n          0,\n        ]\n      },\n      parseMarkdown: {\n        match: ({ type }) => type === 'listItem',\n        runner: (state, node, type) => {\n          if (node.checked == null) {\n            baseSchema.parseMarkdown.runner(state, node, type)\n            return\n          }\n\n          const label = node.label != null ? `${node.label}.` : '•'\n          const checked = node.checked != null ? Boolean(node.checked) : null\n          const listType = node.label != null ? 'ordered' : 'bullet'\n          const spread = node.spread != null ? `${node.spread}` : 'true'\n\n          state.openNode(type, { label, listType, spread, checked })\n          state.next(node.children)\n          state.closeNode()\n        },\n      },\n      toMarkdown: {\n        match: node => node.type.name === 'list_item',\n        runner: (state, node) => {\n          if (node.attrs.checked == null) {\n            baseSchema.toMarkdown.runner(state, node)\n            return\n          }\n\n          const label = node.attrs.label\n          const listType = node.attrs.listType\n          const spread = node.attrs.spread === 'true'\n          const checked = node.attrs.checked\n\n          state.openNode('listItem', undefined, { label, listType, spread, checked })\n          state.next(node.content)\n          state.closeNode()\n        },\n      },\n    }\n  }\n})\n\nwithMeta(extendListItemSchemaForTask, {\n  displayName: 'NodeSchema<listItem>',\n  group: 'ListItem',\n})\n\n/// Input rule for wrapping a block in task list node.\n/// Users can type `[ ] ` or `[x] ` to wrap the block in task list node with checked status.\nexport const wrapInTaskListInputRule = $inputRule(() => {\n  return new InputRule(/^\\[(?<checked>\\s|x)\\]\\s$/, (state, match, start, end) => {\n    const pos = state.doc.resolve(start)\n    let depth = 0\n    let node = pos.node(depth)\n    while (node && node.type.name !== 'list_item') {\n      depth--\n      node = pos.node(depth)\n    }\n\n    if (!node || node.attrs.checked != null)\n      return null\n\n    const checked = Boolean(match.groups?.checked === 'x')\n\n    const finPos = pos.before(depth)\n    const tr = state.tr\n\n    tr.deleteRange(start, end)\n      .setNodeMarkup(finPos, undefined, { ...node.attrs, checked })\n\n    return tr\n  })\n})\n\nwithMeta(wrapInTaskListInputRule, {\n  displayName: 'InputRule<wrapInTaskListInputRule>',\n  group: 'ListItem',\n})\n", "/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin } from '@milkdown/ctx'\nimport { strikethroughKeymap } from '../mark'\nimport { tableKeymap } from '../node'\n\n/// @internal\nexport const keymap: MilkdownPlugin[] = [\n  strikethroughKeymap,\n  tableKeymap,\n].flat()\n", "/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin } from '@milkdown/ctx'\nimport { insertTableInputRule, wrapInTaskListInputRule } from '../node'\n\n/// @internal\nexport const inputrules: MilkdownPlugin[] = [\n  insertTableInputRule,\n  wrapInTaskListInputRule,\n]\n", "/* Copyright 2021, Milkdown by Mirone. */\nimport { browser } from '@milkdown/prose'\nimport type { Node } from '@milkdown/prose/model'\nimport { isInTable } from '@milkdown/prose/tables'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { paragraphSchema } from '@milkdown/preset-commonmark'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to fix the bug of IME composing in table in Safari browser.\n/// original discussion in https://discuss.prosemirror.net/t/ime-composing-problems-on-td-or-th-element-in-safari-browser/4501\nexport const autoInsertZeroSpaceInTablePlugin = $prose(() => {\n  const pluginKey = new PluginKey('MILKDOWN_AUTO_INSERT_ZERO_SPACE')\n\n  const isParagraph = (node: Node) => node.type === paragraphSchema.type()\n\n  const isEmptyParagraph = (node: Node) => isParagraph(node) && node.nodeSize === 2\n\n  return new Plugin({\n    key: pluginKey,\n    props: {\n      handleDOMEvents: {\n        compositionstart(view) {\n          const { state, dispatch } = view\n          const { tr, selection } = state\n          const { $from } = selection\n          if (browser.safari && isInTable(state) && selection.empty && isEmptyParagraph($from.parent))\n            dispatch(tr.insertText('\\u2060', $from.start()))\n\n          return false\n        },\n        compositionend(view) {\n          const { state, dispatch } = view\n          const { tr, selection } = state\n          const { $from } = selection\n\n          if (\n            browser.safari\n              && isInTable(state)\n              && selection.empty\n              && isParagraph($from.parent)\n              && $from.parent.textContent.startsWith('\\u2060')\n          )\n            dispatch(tr.delete($from.start(), $from.start() + 1))\n\n          return false\n        },\n      },\n    },\n  })\n})\n\nwithMeta(autoInsertZeroSpaceInTablePlugin, {\n  displayName: 'Prose<autoInsertZeroSpaceInTablePlugin>',\n  group: 'Prose',\n})\n", "/* Copyright 2021, Milkdown by Mirone. */\nimport { columnResizing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `columnResizing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const columnResizingPlugin = $prose(() => columnResizing({}))\n\nwithMeta(columnResizingPlugin, {\n  displayName: 'Prose<columnResizingPlugin>',\n  group: 'Prose',\n})\n", "/* Copyright 2021, Milkdown by Mirone. */\nimport { tableEditing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `tableEditing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const tableEditingPlugin = $prose(() => tableEditing())\n\nwithMeta(tableEditingPlugin, {\n  displayName: 'Prose<tableEditingPlugin>',\n  group: 'Prose',\n})\n", "/* Copyright 2021, Milkdown by Mirone. */\nimport { $remark } from '@milkdown/utils'\nimport remarkGFM from 'remark-gfm'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the [remark-gfm](https://github.com/remarkjs/remark-gfm).\nexport const remarkGFMPlugin = $remark(() => remarkGFM)\n\nwithMeta(remarkGFMPlugin, {\n  displayName: 'Remark<remarkGFMPlugin>',\n  group: 'Remark',\n})\n", "/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin } from '@milkdown/ctx'\nimport { autoInsertZeroSpaceInTablePlugin, columnResizingPlugin, remarkGFMPlugin, tableEditingPlugin } from '../plugin'\n\n/// @internal\nexport const plugins: MilkdownPlugin[] = [\n  autoInsertZeroSpaceInTablePlugin,\n  columnResizingPlugin,\n  tableEditingPlugin,\n  remarkGFMPlugin,\n]\n", "/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin } from '@milkdown/ctx'\nimport { strikethroughAttr, strikethroughSchema } from '../mark'\nimport { extendListItemSchemaForTask, footnoteDefinitionSchema, footnoteReferenceSchema, tableCellSchema, tableHeaderSchema, tableRowSchema, tableSchema } from '../node'\n\n/// @internal\nexport const schema: MilkdownPlugin[] = [\n  extendListItemSchemaForTask,\n\n  tableSchema,\n  tableRowSchema,\n  tableHeaderSchema,\n  tableCellSchema,\n\n  footnoteDefinitionSchema,\n  footnoteReferenceSchema,\n\n  strikethroughAttr,\n  strikethroughSchema,\n].flat()\n", "/* Copyright 2021, Milkdown by Mirone. */\nimport { toggleStrikethroughCommand } from '../mark'\nimport { addColAfterCommand, addColBeforeCommand, addRowAfterCommand, addRowBeforeCommand, breakTableCommand, deleteSelectedCellsCommand, goToNextTableCellCommand, goToPrevTableCellCommand, insertTableCommand, moveColCommand, moveRowCommand, selectColCommand, selectRowCommand, selectTableCommand, setAlignCommand } from '../node'\n\n/// @internal\nexport const commands = [\n  goToNextTableCellCommand,\n  goToPrevTableCellCommand,\n  breakTableCommand,\n  insertTableCommand,\n  moveRowCommand,\n  moveColCommand,\n  selectRowCommand,\n  selectColCommand,\n  selectTableCommand,\n  deleteSelectedCellsCommand,\n  addRowBeforeCommand,\n  addRowAfterCommand,\n  addColBeforeCommand,\n  addColAfterCommand,\n  setAlignCommand,\n\n  toggleStrikethroughCommand,\n]\n", "/* Copyright 2021, Milkdown by Mirone. */\n\nimport { commands, inputrules, keymap, plugins, schema } from './composed'\n\nexport * from './node'\nexport * from './mark'\nexport * from './composed'\n\n/// The GFM preset, includes all the plugins.\nexport const gfm = [schema, inputrules, keymap, plugins, commands].flat()\n"],
  "mappings": "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",
  "names": ["j", "b", "w", "d", "d", "w", "d", "j", "d", "withMeta", "plugin", "meta", "strikethroughAttr", "$markAttr", "strikethroughSchema", "$markSchema", "ctx", "value", "mark", "node", "state", "markType", "toggleStrikethroughCommand", "$command", "toggleMarkdownMark", "strikethroughKeymap", "$useKeymap", "commands", "commandsCtx", "createTable", "rowsCount", "colsCount", "cells", "tableCellSchema", "headerCells", "tableHeaderSchema", "rows", "_", "i", "tableRowSchema", "tableSchema", "findTable", "selection", "findParentNode", "getCellsInCol", "columnIndex", "table", "map", "TableMap", "pos", "start", "x", "getCellsInRow", "rowIndex", "getAllCellsInTable", "nodePos", "selectTable", "tr", "$firstCell", "last", "$lastCell", "cloneTr", "CellSelection", "addRowWithAlignment", "tableStart", "row", "rowPos", "acc", "col", "headerCol", "selectLine", "type", "index", "isRowSelection", "lastCell", "createCellSelection", "firstCell", "selectRow", "selectCol", "transpose", "array", "column", "convertArrayOfRowsToTableNode", "tableNode", "arrayOfNodes", "rowsPM", "rowCells", "colIndex", "cellPos", "cell", "newCell", "convertTableNodeToArrayOfRows", "seen", "rect", "moveRowInArrayOfRows", "indexesOrigin", "indexesTarget", "directionOverride", "direction", "rowsExtracted", "positionOffset", "target", "moveTableColumn", "moveTableRow", "getSelectionRangeInColumn", "startIndex", "endIndex", "maybeEndIndex", "indexes", "maybeCells", "firstSelectedColumnCells", "firstRowCells", "$anchor", "headCell", "columnCells", "j", "$head", "getSelectionRangeInRow", "firstSelectedRowCells", "firstColumnCells", "moveCol", "origin", "select", "indexesOriginColumn", "indexesTargetColumn", "newTable", "_tr", "moveRow", "indexesOriginRow", "indexesTargetRow", "originalSchema", "tableNodes", "dom", "attrs", "$nodeSchema", "align", "children", "firstLine", "_a", "insertTableInputRule", "$inputRule", "InputRule", "match", "end", "$start", "_b", "TextSelection", "goToPrevTableCellCommand", "goToNextCell", "goToNextTableCellCommand", "breakTableCommand", "dispatch", "isInTable", "paragraphSchema", "Selection", "insertTableCommand", "from", "sel", "moveRowCommand", "to", "moveColCommand", "selectRowCommand", "selectColCommand", "selectTableCommand", "deleteSelectedCellsCommand", "isRow", "isCol", "deleteTable", "deleteColumn", "deleteRow", "addColBeforeCommand", "addColumnBefore", "addColAfterCommand", "addColumnAfter", "addRowBeforeCommand", "selectedRect", "addRowAfterCommand", "setAlignCommand", "alignment", "setCellAttr", "tableKeymap", "id", "markdownId", "footnoteDefinitionSchema", "expectDomTypeError", "label", "footnoteReferenceSchema", "extendListItemSchemaForTask", "listItemSchema", "prev", "baseSchema", "checked", "listType", "spread", "wrapInTaskListInputRule", "depth", "finPos", "keymap", "inputrules", "autoInsertZeroSpaceInTablePlugin", "$prose", "pluginKey", "PluginKey", "isParagraph", "isEmptyParagraph", "Plugin", "view", "$from", "browser", "columnResizingPlugin", "columnResizing", "tableEditingPlugin", "tableEditing", "remarkGFMPlugin", "$remark", "remarkGFM", "plugins", "schema", "gfm"]
}
