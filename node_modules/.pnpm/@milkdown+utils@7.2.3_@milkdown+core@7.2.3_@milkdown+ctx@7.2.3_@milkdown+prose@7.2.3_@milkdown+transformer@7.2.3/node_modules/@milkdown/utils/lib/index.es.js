import { createCmdKey as E, commandsTimerCtx as I, SchemaReady as p, commandsCtx as w, editorStateTimerCtx as b, inputRulesCtx as $, schemaTimerCtx as O, marksCtx as h, schemaCtx as f, nodesCtx as k, prosePluginsCtx as l, InitReady as M, remarkPluginsCtx as v, editorViewTimerCtx as D, nodeViewCtx as C, markViewCtx as T, editorViewCtx as g, serializerCtx as N, parserCtx as R, editorStateOptionsCtx as H } from "@milkdown/core";
import { createTimer as L, createSlice as F } from "@milkdown/ctx";
import { customAlphabet as U } from "nanoid";
import { missingMarkInSchema as j, missingNodeInSchema as z } from "@milkdown/exception";
import { keymap as K } from "@milkdown/prose/keymap";
import { NodeType as A, DOMSerializer as q, Slice as P } from "@milkdown/prose/model";
import { EditorState as B } from "@milkdown/prose/state";
const G = U("abcedfghicklmn", 10), y = (t, s, n) => {
  const r = L(n || G());
  let e = !1;
  const a = (o) => (o.record(r), o.update(s, (i) => i.concat(r)), async () => {
    const m = await t(o, a, () => {
      o.done(r), e = !0;
    });
    return e || o.done(r), () => {
      o.update(s, (u) => u.filter((c) => c !== r)), o.clearTimer(r), m == null || m();
    };
  });
  return a.timer = r, a;
}, ne = (t, s) => {
  const n = E(t), r = (e) => async () => {
    r.key = n, await e.wait(p);
    const a = s(e);
    return e.get(w).create(n, a), r.run = (o) => e.get(w).call(t, o), () => {
      e.get(w).remove(n);
    };
  };
  return r;
}, re = (t, s, n) => {
  const r = E(t);
  return y(
    async (e, a) => {
      await e.wait(p);
      const o = await s(e);
      return e.get(w).create(r, o), a.run = (i) => e.get(w).call(t, i), a.key = r, () => {
        e.get(w).remove(r);
      };
    },
    I,
    n
  );
}, ae = (t) => {
  const s = (n) => async () => {
    await n.wait(p);
    const r = t(n);
    return n.update($, (e) => [...e, r]), s.inputRule = r, () => {
      n.update($, (e) => e.filter((a) => a !== r));
    };
  };
  return s;
}, se = (t, s) => y(
  async (n, r) => {
    await n.wait(p);
    const e = await t(n);
    return n.update($, (a) => [...a, e]), r.inputRule = e, () => {
      n.update($, (a) => a.filter((o) => o !== e));
    };
  },
  b,
  s
), J = (t, s) => {
  let n;
  const r = (e) => async () => {
    const a = s(e);
    if (e.update(h, (o) => [...o.filter((i) => i[0] !== t), [t, a]]), r.id = t, r.schema = a, await e.wait(p), n = e.get(f).marks[t], !n)
      throw j(t);
    return () => {
      e.update(h, (o) => o.filter(([i]) => i !== t));
    };
  };
  return r.type = () => n, r;
}, oe = (t, s, n) => {
  let r;
  const e = y(
    async (a, o, i) => {
      const m = await s(a);
      if (a.update(h, (c) => [...c.filter((d) => d[0] !== t), [t, m]]), o.id = t, o.schema = m, i(), await a.wait(p), !a.get(f).marks[t])
        throw j(t);
      return () => {
        a.update(h, (c) => c.filter(([d]) => d !== t));
      };
    },
    O,
    n
  );
  return e.type = () => r, e;
}, Q = (t, s) => {
  let n;
  const r = (e) => async () => {
    const a = s(e);
    if (e.update(k, (o) => [...o.filter((i) => i[0] !== t), [t, a]]), r.id = t, r.schema = a, await e.wait(p), n = e.get(f).nodes[t], !n)
      throw z(t);
    return () => {
      e.update(k, (o) => o.filter(([i]) => i !== t));
    };
  };
  return r.type = () => n, r;
}, ie = (t, s, n) => {
  let r;
  const e = y(
    async (a, o, i) => {
      const m = await s(a);
      if (a.update(k, (u) => [...u.filter((c) => c[0] !== t), [t, m]]), o.id = t, o.schema = m, i(), await a.wait(p), r = a.get(f).nodes[t], !r)
        throw z(t);
      return () => {
        a.update(k, (u) => u.filter(([c]) => c !== t));
      };
    },
    O,
    n
  );
  return e.type = () => r, e;
}, ce = (t) => {
  let s;
  const n = (r) => async () => (await r.wait(p), s = t(r), r.update(l, (e) => [...e, s]), () => {
    r.update(l, (e) => e.filter((a) => a !== s));
  });
  return n.plugin = () => s, n.key = () => s.spec.key, n;
}, ue = (t, s) => {
  let n;
  const r = y(
    async (e) => (await e.wait(p), n = await t(e), e.update(l, (a) => [...a, n]), () => {
      e.update(l, (a) => a.filter((o) => o !== n));
    }),
    b,
    s
  );
  return r.plugin = () => n, r.key = () => n.spec.key, r;
}, me = (t) => {
  const s = (n) => async () => {
    await n.wait(M);
    const r = t(n);
    return n.update(v, (e) => [...e, r]), s.plugin = r, () => {
      n.update(v, (e) => e.filter((a) => a !== r));
    };
  };
  return s;
}, pe = (t, s) => y(
  async (n, r) => {
    await n.wait(M);
    const e = await t(n);
    return n.update(v, (a) => [...a, e]), r.plugin = e, () => {
      n.update(v, (a) => a.filter((o) => o !== e));
    };
  },
  O,
  s
), W = (t) => {
  const s = (n) => async () => {
    await n.wait(p);
    const r = t(n), e = K(r);
    return n.update(l, (a) => [...a, e]), s.keymap = r, () => {
      n.update(l, (a) => a.filter((o) => o !== e));
    };
  };
  return s;
}, le = (t, s) => y(
  async (n, r) => {
    await n.wait(p);
    const e = await t(n), a = K(e);
    return n.update(l, (o) => [...o, a]), r.keymap = e, () => {
      n.update(l, (o) => o.filter((i) => i !== a));
    };
  },
  b,
  s
), de = (t, s) => {
  const n = (r) => async () => {
    await r.wait(p);
    const e = s(r);
    return t.type() instanceof A ? r.update(C, (a) => [...a, [t.id, e]]) : r.update(T, (a) => [...a, [t.id, e]]), n.view = e, n.type = t, () => {
      t.type() instanceof A ? r.update(C, (a) => a.filter((o) => o[0] !== t.id)) : r.update(T, (a) => a.filter((o) => o[0] !== t.id));
    };
  };
  return n;
}, ye = (t, s, n) => y(
  async (r, e) => {
    await r.wait(p);
    const a = await s(r);
    return t.type() instanceof A ? r.update(C, (o) => [...o, [t.id, a]]) : r.update(T, (o) => [...o, [t.id, a]]), e.view = a, e.type = t, () => {
      t.type() instanceof A ? r.update(C, (o) => o.filter((i) => i[0] !== t.id)) : r.update(T, (o) => o.filter((i) => i[0] !== t.id));
    };
  },
  D,
  n
), S = (t, s) => {
  const n = F(t, s), r = (e) => (e.inject(n), () => () => {
    e.remove(n);
  });
  return r.key = n, r;
}, we = (t, s) => {
  const n = S(s, t), r = Q(t, (a) => a.get(n.key)(a)), e = [n, r];
  return e.id = r.id, e.node = r, e.type = r.type, e.schema = r.schema, e.ctx = n, e.key = n.key, e.extendSchema = (a) => (o) => () => {
    const i = o.get(n.key), u = a(i)(o);
    o.update(k, (c) => [...c.filter((d) => d[0] !== t), [t, u]]), e.schema = u;
  }, e;
}, ge = (t, s) => {
  const n = S(s, t), r = J(t, (a) => a.get(n.key)(a)), e = [n, r];
  return e.id = r.id, e.mark = r, e.type = r.type, e.schema = r.schema, e.ctx = n, e.key = n.key, e.extendSchema = (a) => (o) => () => {
    const i = o.get(n.key), u = a(i)(o);
    o.update(h, (c) => [...c.filter((d) => d[0] !== t), [t, u]]), e.schema = u;
  }, e;
}, fe = (t, s) => {
  const n = Object.fromEntries(Object.entries(s).map(([o, { shortcuts: i }]) => [o, i])), r = S(n, `${t}Keymap`), e = W((o) => {
    const i = o.get(r.key), m = Object.entries(s).flatMap(([u, { command: c }]) => [i[u]].flat().map((V) => [V, c(o)]));
    return Object.fromEntries(m);
  }), a = [r, e];
  return a.ctx = r, a.shortcuts = e, a.key = r.key, a.keymap = e.keymap, a;
}, he = (t, s = () => ({})) => S(s, `${t}Attr`), ke = (t, s = () => ({})) => S(s, `${t}Attr`);
function Se(t, s) {
  return (n) => n.get(w).call(t, s);
}
const $e = () => (t) => {
  const s = t.get(g), { tr: n } = s.state, r = Object.assign(Object.create(n), n).setTime(Date.now());
  return s.dispatch(r);
}, ve = () => (t) => {
  const s = document.createElement("div"), n = t.get(f), r = t.get(g), e = q.fromSchema(n).serializeFragment(r.state.doc.content);
  return s.appendChild(e), s.innerHTML;
}, Ce = () => (t) => {
  const s = t.get(g);
  return t.get(N)(s.state.doc);
}, Te = (t) => (s) => {
  const n = s.get(g), e = s.get(R)(t);
  if (!e)
    return;
  const a = n.state.selection.content();
  return n.dispatch(
    n.state.tr.replaceSelection(new P(e.content, a.openStart, a.openEnd)).scrollIntoView()
  );
}, Ae = () => (t) => {
  const s = t.get(g), n = [];
  return s.state.doc.descendants((e) => {
    e.type.name === "heading" && e.attrs.level && n.push({ text: e.textContent, level: e.attrs.level, id: e.attrs.id });
  }), n;
}, be = (t, s = !1) => (n) => {
  const r = n.get(g), a = n.get(R)(t);
  if (!a)
    return;
  if (!s) {
    const { state: c } = r;
    return r.dispatch(c.tr.replace(0, c.doc.content.size, new P(a.content, 0, 0)));
  }
  const o = n.get(f), i = n.get(H), m = n.get(l), u = B.create({
    schema: o,
    doc: a,
    plugins: m,
    ...i
  });
  r.updateState(u);
}, Oe = (t, s) => (n) => {
  const r = n.get(g), { tr: e } = r.state, a = e.doc.nodeAt(t);
  if (!a)
    return;
  const o = s(a.attrs);
  return r.dispatch(e.setNodeMarkup(t, void 0, o));
}, Ee = (...t) => {
  const s = t.length;
  let n = s;
  for (; n--; )
    if (typeof t[n] != "function")
      throw new TypeError("Expected a function");
  return (...r) => {
    let e = 0, a = s ? t[e](...r) : r[0];
    for (; ++e < s; )
      a = t[e](a);
    return a;
  };
};
export {
  ne as $command,
  re as $commandAsync,
  S as $ctx,
  ae as $inputRule,
  se as $inputRuleAsync,
  J as $mark,
  oe as $markAsync,
  ke as $markAttr,
  ge as $markSchema,
  Q as $node,
  ie as $nodeAsync,
  he as $nodeAttr,
  we as $nodeSchema,
  ce as $prose,
  ue as $proseAsync,
  me as $remark,
  pe as $remarkAsync,
  W as $shortcut,
  le as $shortcutAsync,
  fe as $useKeymap,
  de as $view,
  ye as $viewAsync,
  y as addTimer,
  Se as callCommand,
  $e as forceUpdate,
  ve as getHTML,
  Ce as getMarkdown,
  Te as insert,
  G as nanoid,
  Ae as outline,
  Ee as pipe,
  be as replaceAll,
  Oe as setAttr
};
//# sourceMappingURL=index.es.js.map
