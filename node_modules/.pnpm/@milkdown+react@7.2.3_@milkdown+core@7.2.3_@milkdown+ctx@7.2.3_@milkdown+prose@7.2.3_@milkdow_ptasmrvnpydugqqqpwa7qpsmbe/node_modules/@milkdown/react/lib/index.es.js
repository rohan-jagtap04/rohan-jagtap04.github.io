import l, { createContext as g, useContext as a, useRef as u, useEffect as E, useState as f, useMemo as y, useCallback as m, useLayoutEffect as v } from "react";
const i = g({}), I = () => {
  const { dom: t, editor: o, setLoading: e, editorFactory: r } = a(i), d = u(null);
  return E(() => {
    const n = d.current;
    if (!r || !n)
      return;
    t.current = n;
    const s = r(n);
    if (s)
      return e(!0), s.create().then((c) => {
        o.current = c;
      }).finally(() => {
        e(!1);
      }).catch(console.error), () => {
        var c;
        (c = o.current) == null || c.destroy();
      };
  }, [t, o, r, e]), d;
}, C = () => {
  const t = I();
  return /* @__PURE__ */ l.createElement("div", { "data-milkdown-root": !0, ref: t });
}, R = ({ children: t }) => {
  const o = u(void 0), [e, r] = f(void 0), d = u(), [n, s] = f(!0), c = y(() => ({
    loading: n,
    dom: o,
    editor: d,
    setLoading: s,
    editorFactory: e,
    setEditorFactory: r
  }), [n, e]);
  return /* @__PURE__ */ l.createElement(i.Provider, { value: c }, t);
}, k = (t, o = []) => {
  const e = a(i), r = m(t, o);
  return v(() => {
    e.setEditorFactory(() => r);
  }, [e, r]), {
    loading: e.loading,
    get: () => e.editor.current
  };
}, F = () => {
  const t = a(i), o = m(() => t.editor.current, [t.editor]);
  return [t.loading, o];
};
export {
  C as Milkdown,
  R as MilkdownProvider,
  k as useEditor,
  F as useInstance
};
//# sourceMappingURL=index.es.js.map
