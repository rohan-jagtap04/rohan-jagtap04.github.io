import { stackOverFlow as G, parserMatchError as V, createNodeInParserFail as X, serializerMatchError as Y } from "@milkdown/exception";
import { Mark as v } from "@milkdown/prose/model";
class J {
}
class q {
  constructor() {
    this.elements = [], this.size = () => this.elements.length, this.top = () => this.elements.at(-1), this.push = (t) => {
      var e;
      (e = this.top()) == null || e.push(t);
    }, this.open = (t) => {
      this.elements.push(t);
    }, this.close = () => {
      const t = this.elements.pop();
      if (!t)
        throw G();
      return t;
    };
  }
}
class R extends J {
  constructor(t, e, s) {
    super(), this.type = t, this.content = e, this.attrs = s;
  }
  push(t, ...e) {
    this.content.push(t, ...e);
  }
  pop() {
    return this.content.pop();
  }
  static create(t, e, s) {
    return new R(t, e, s);
  }
}
var B = (r, t, e) => {
  if (!t.has(r))
    throw TypeError("Cannot " + e);
}, c = (r, t, e) => (B(r, t, "read from private field"), e ? e.call(r) : t.get(r)), d = (r, t, e) => {
  if (t.has(r))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(r) : t.set(r, e);
}, E = (r, t, e, s) => (B(r, t, "write to private field"), s ? s.call(r, e) : t.set(r, e), e), l, _, P, T, z, y, m;
const H = class extends q {
  /// @internal
  constructor(r) {
    super(), d(this, l, v.none), d(this, _, (t) => t.isText), d(this, P, (t, e) => {
      if (c(this, _).call(this, t) && c(this, _).call(this, e) && v.sameSet(t.marks, e.marks))
        return this.schema.text(t.text + e.text, t.marks);
    }), d(this, T, (t) => {
      const e = Object.values({ ...this.schema.nodes, ...this.schema.marks }).find((s) => s.spec.parseMarkdown.match(t));
      if (!e)
        throw V(t);
      return e;
    }), d(this, z, (t) => {
      const e = c(this, T).call(this, t);
      e.spec.parseMarkdown.runner(this, t, e);
    }), this.injectRoot = (t, e, s) => (this.openNode(e, s), this.next(t.children), this), this.openNode = (t, e) => (this.open(R.create(t, [], e)), this), d(this, y, () => {
      E(this, l, v.none);
      const t = this.close();
      return c(this, m).call(this, t.type, t.attrs, t.content);
    }), this.closeNode = () => (c(this, y).call(this), this), d(this, m, (t, e, s) => {
      const i = t.createAndFill(e, s, c(this, l));
      if (!i)
        throw X(t, e, s);
      return this.push(i), i;
    }), this.addNode = (t, e, s) => (c(this, m).call(this, t, e, s), this), this.openMark = (t, e) => {
      const s = t.create(e);
      return E(this, l, s.addToSet(c(this, l))), this;
    }, this.closeMark = (t) => (E(this, l, t.removeFromSet(c(this, l))), this), this.addText = (t) => {
      const e = this.top();
      if (!e)
        throw G();
      const s = e.pop(), i = this.schema.text(t, c(this, l));
      if (!s)
        return e.push(i), this;
      const a = c(this, P).call(this, s, i);
      return a ? (e.push(a), this) : (e.push(s, i), this);
    }, this.build = () => {
      let t;
      do
        t = c(this, y).call(this);
      while (this.size());
      return t;
    }, this.next = (t = []) => ([t].flat().forEach((e) => c(this, z).call(this, e)), this), this.toDoc = () => this.build(), this.run = (t, e) => {
      const s = t.runSync(t.parse(e), e);
      return this.next(s), this;
    }, this.schema = r;
  }
};
let Z = H;
l = /* @__PURE__ */ new WeakMap();
_ = /* @__PURE__ */ new WeakMap();
P = /* @__PURE__ */ new WeakMap();
T = /* @__PURE__ */ new WeakMap();
z = /* @__PURE__ */ new WeakMap();
y = /* @__PURE__ */ new WeakMap();
m = /* @__PURE__ */ new WeakMap();
Z.create = (r, t) => {
  const e = new H(r);
  return (s) => (e.run(t, s), e.toDoc());
};
const K = class extends J {
  constructor(r, t, e, s = {}) {
    super(), this.type = r, this.children = t, this.value = e, this.props = s, this.push = (i, ...a) => {
      this.children || (this.children = []), this.children.push(i, ...a);
    }, this.pop = () => {
      var i;
      return (i = this.children) == null ? void 0 : i.pop();
    };
  }
};
let $ = K;
$.create = (r, t, e, s = {}) => new K(r, t, e, s);
var L = (r, t, e) => {
  if (!t.has(r))
    throw TypeError("Cannot " + e);
}, n = (r, t, e) => (L(r, t, "read from private field"), e ? e.call(r) : t.get(r)), o = (r, t, e) => {
  if (t.has(r))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(r) : t.set(r, e);
}, D = (r, t, e, s) => (L(r, t, "write to private field"), s ? s.call(r, e) : t.set(r, e), e), p, S, C, A, N, I, W, O, M, x, F, g;
const j = (r) => Object.prototype.hasOwnProperty.call(r, "size"), Q = class extends q {
  /// @internal
  constructor(r) {
    super(), o(this, p, v.none), o(this, S, (t) => {
      const e = Object.values({ ...this.schema.nodes, ...this.schema.marks }).find((s) => s.spec.toMarkdown.match(t));
      if (!e)
        throw Y(t.type);
      return e;
    }), o(this, C, (t) => n(this, S).call(this, t).spec.toMarkdown.runner(this, t)), o(this, A, (t, e) => n(this, S).call(this, t).spec.toMarkdown.runner(this, t, e)), o(this, N, (t) => {
      const { marks: e } = t, s = (h) => h.type.spec.priority ?? 50;
      [...e].sort((h, u) => s(h) - s(u)).every((h) => !n(this, A).call(this, h, t)) && n(this, C).call(this, t), e.forEach((h) => n(this, g).call(this, h));
    }), o(this, I, (t, e) => {
      var u;
      if (t.type === e || ((u = t.children) == null ? void 0 : u.length) !== 1)
        return t;
      const s = (f) => {
        var w;
        if (f.type === e)
          return f;
        if (((w = f.children) == null ? void 0 : w.length) !== 1)
          return null;
        const [k] = f.children;
        return k ? s(k) : null;
      }, i = s(t);
      if (!i)
        return t;
      const a = i.children ? [...i.children] : void 0, h = { ...t, children: a };
      return h.children = a, i.children = [h], i;
    }), o(this, W, (t) => {
      const { children: e } = t;
      return e && (t.children = e.reduce((s, i, a) => {
        if (a === 0)
          return [i];
        const h = s.at(-1);
        if (h && h.isMark && i.isMark) {
          i = n(this, I).call(this, i, h.type);
          const { children: u, ...f } = i, { children: k, ...w } = h;
          if (i.type === h.type && u && k && JSON.stringify(f) === JSON.stringify(w)) {
            const U = {
              ...w,
              children: [...k, ...u]
            };
            return s.slice(0, -1).concat(n(this, W).call(this, U));
          }
        }
        return s.concat(i);
      }, [])), t;
    }), o(this, O, (t) => {
      const e = {
        ...t.props,
        type: t.type
      };
      return t.children && (e.children = t.children), t.value && (e.value = t.value), e;
    }), this.openNode = (t, e, s) => (this.open($.create(t, void 0, e, s)), this), o(this, M, () => {
      const t = this.close();
      return n(this, x).call(this, t.type, t.children, t.value, t.props);
    }), this.closeNode = () => (n(this, M).call(this), this), o(this, x, (t, e, s, i) => {
      const a = $.create(t, e, s, i), h = n(this, W).call(this, n(this, O).call(this, a));
      return this.push(h), h;
    }), this.addNode = (t, e, s, i) => (n(this, x).call(this, t, e, s, i), this), o(this, F, (t, e, s, i) => t.isInSet(n(this, p)) ? this : (D(this, p, t.addToSet(n(this, p))), this.openNode(e, s, { ...i, isMark: !0 }))), o(this, g, (t) => {
      t.isInSet(n(this, p)) && (D(this, p, t.type.removeFromSet(n(this, p))), n(this, M).call(this));
    }), this.withMark = (t, e, s, i) => (n(this, F).call(this, t, e, s, i), this), this.closeMark = (t) => (n(this, g).call(this, t), this), this.build = () => {
      let t = null;
      do
        t = n(this, M).call(this);
      while (this.size());
      return t;
    }, this.next = (t) => j(t) ? (t.forEach((e) => {
      n(this, N).call(this, e);
    }), this) : (n(this, N).call(this, t), this), this.toString = (t) => t.stringify(this.build()), this.run = (t) => (this.next(t), this), this.schema = r;
  }
};
let b = Q;
p = /* @__PURE__ */ new WeakMap();
S = /* @__PURE__ */ new WeakMap();
C = /* @__PURE__ */ new WeakMap();
A = /* @__PURE__ */ new WeakMap();
N = /* @__PURE__ */ new WeakMap();
I = /* @__PURE__ */ new WeakMap();
W = /* @__PURE__ */ new WeakMap();
O = /* @__PURE__ */ new WeakMap();
M = /* @__PURE__ */ new WeakMap();
x = /* @__PURE__ */ new WeakMap();
F = /* @__PURE__ */ new WeakMap();
g = /* @__PURE__ */ new WeakMap();
b.create = (r, t) => {
  const e = new Q(r);
  return (s) => (e.run(s), e.toString(t));
};
export {
  Z as ParserState,
  b as SerializerState,
  q as Stack,
  J as StackElement
};
//# sourceMappingURL=index.es.js.map
