import { PluginKey, Plugin, NodeSelection, AllSelection } from 'prosemirror-state';
import { InputRule } from 'prosemirror-inputrules';
import { expectDomTypeError, missingRootElement, getAtomFromSchemaFail } from '@milkdown/exception';

const nav = typeof navigator != "undefined" ? navigator : null;
const doc = typeof document != "undefined" ? document : null;
const agent = nav && nav.userAgent || "";
const ie_edge = /Edge\/(\d+)/.exec(agent);
const ie_upto10 = /MSIE \d/.exec(agent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
const ie = !!(ie_upto10 || ie_11up || ie_edge);
const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
const gecko = !ie && /gecko\/(\d+)/i.test(agent);
const gecko_version = gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
const _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
const chrome = !!_chrome;
const chrome_version = _chrome ? +_chrome[1] : 0;
const safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
const ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
const mac = ios || (nav ? /Mac/.test(nav.platform) : false);
const android = /Android \d/.test(agent);
const webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;

var browser = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ie: ie,
  ie_version: ie_version,
  gecko: gecko,
  gecko_version: gecko_version,
  chrome: chrome,
  chrome_version: chrome_version,
  safari: safari,
  ios: ios,
  mac: mac,
  android: android,
  webkit: webkit,
  webkit_version: webkit_version
});

function run(view, from, to, text, rules, plugin) {
  if (view.composing)
    return false;
  const state = view.state;
  const $from = state.doc.resolve(from);
  if ($from.parent.type.spec.code)
    return false;
  const textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - 500), $from.parentOffset, void 0, "\uFFFC") + text;
  for (let i = 0; i < rules.length; i++) {
    const match = rules[i].match.exec(textBefore);
    const tr = match && match[0] && rules[i].handler(state, match, from - (match[0].length - text.length), to);
    if (!tr)
      continue;
    view.dispatch(tr.setMeta(plugin, { transform: tr, from, to, text }));
    return true;
  }
  return false;
}
const customInputRulesKey = new PluginKey("MILKDOWN_CUSTOM_INPUTRULES");
const customInputRules = ({ rules }) => {
  const plugin = new Plugin({
    key: customInputRulesKey,
    isInputRules: true,
    state: {
      init() {
        return null;
      },
      apply(tr, prev) {
        const stored = tr.getMeta(this);
        if (stored)
          return stored;
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from, to, text) {
        return run(view, from, to, text, rules, plugin);
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor)
              run(view, $cursor.pos, $cursor.pos, "", rules, plugin);
          });
          return false;
        }
      },
      handleKeyDown(view, event) {
        if (event.key !== "Enter")
          return false;
        const { $cursor } = view.state.selection;
        if ($cursor)
          return run(view, $cursor.pos, $cursor.pos, "\n", rules, plugin);
        return false;
      }
    }
  });
  return plugin;
};

function markRule(regexp, markType) {
  return new InputRule(regexp, (state, match, start, end) => {
    const { tr } = state;
    const matchLength = match.length;
    let markStart = start;
    let markEnd = end;
    if (match[matchLength - 1]) {
      const first = match[0];
      const last = match[matchLength - 1];
      const last1 = match[matchLength - 2];
      const matchStart = start + first.indexOf(last1);
      const matchEnd = matchStart + last1.length - 1;
      const textStart = matchStart + last1.lastIndexOf(last);
      const textEnd = textStart + last.length;
      const excludedMarks = getMarksBetween(start, end, state).filter((item) => item.mark.type.excludes(markType)).filter((item) => item.end > matchStart);
      if (excludedMarks.length)
        return null;
      if (textEnd < matchEnd)
        tr.delete(textEnd, matchEnd);
      if (textStart > matchStart)
        tr.delete(matchStart, textStart);
      markStart = matchStart;
      markEnd = markStart + last.length;
    }
    tr.addMark(markStart, markEnd, markType.create());
    tr.removeStoredMark(markType);
    return tr;
  });
}
function getMarksBetween(start, end, state) {
  let marks = [];
  state.doc.nodesBetween(start, end, (node, pos) => {
    marks = [
      ...marks,
      ...node.marks.map((mark) => ({
        start: pos,
        end: pos + node.nodeSize,
        mark
      }))
    ];
  });
  return marks;
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const calculateNodePosition = (view, target, handler) => {
  const state = view.state;
  const { from } = state.selection;
  const { node } = view.domAtPos(from);
  const element = node instanceof Text ? node.parentElement : node;
  if (!(element instanceof HTMLElement))
    throw expectDomTypeError(element);
  const selectedNodeRect = element.getBoundingClientRect();
  const targetNodeRect = target.getBoundingClientRect();
  const parent = target.parentElement;
  if (!parent)
    throw expectDomTypeError(parent);
  const parentNodeRect = parent.getBoundingClientRect();
  const [top, left] = handler(selectedNodeRect, targetNodeRect, parentNodeRect);
  target.style.top = `${top}px`;
  target.style.left = `${left}px`;
};
const calculateTextPosition = (view, target, handler) => {
  const state = view.state;
  const { from, to } = state.selection;
  const start = view.coordsAtPos(from);
  const end = view.coordsAtPos(to);
  const targetNodeRect = target.getBoundingClientRect();
  const parent = target.parentElement;
  if (!parent)
    throw missingRootElement();
  const parentNodeRect = parent.getBoundingClientRect();
  const [top, left] = handler(start, end, targetNodeRect, parentNodeRect);
  target.style.top = `${top}px`;
  target.style.left = `${left}px`;
};
function minMax(value = 0, min = 0, max = 0) {
  return Math.min(Math.max(value, min), max);
}
function posToDOMRect(view, from, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start = view.coordsAtPos(resolvedFrom);
  const end = view.coordsAtPos(resolvedEnd, -1);
  const top = Math.min(start.top, end.top);
  const bottom = Math.max(start.bottom, end.bottom);
  const left = Math.min(start.left, end.left);
  const right = Math.max(start.right, end.right);
  const width = right - left;
  const height = bottom - top;
  const x = left;
  const y = top;
  const data = {
    top,
    bottom,
    left,
    right,
    width,
    height,
    x,
    y
  };
  return __spreadProps(__spreadValues({}, data), {
    toJSON: () => data
  });
}

const cloneTr = (tr) => {
  return Object.assign(Object.create(tr), tr).setTime(Date.now());
};
const equalNodeType = (nodeType, node) => {
  return Array.isArray(nodeType) && nodeType.includes(node.type) || node.type === nodeType;
};

const flatten = (node, descend = true) => {
  const result = [];
  node.descendants((child, pos) => {
    result.push({ node: child, pos });
    if (!descend)
      return false;
    return void 0;
  });
  return result;
};
const findChildren = (predicate) => (node, descend) => flatten(node, descend).filter((child) => predicate(child.node));
const findChildrenByMark = (node, markType, descend) => findChildren((child) => Boolean(markType.isInSet(child.marks)))(node, descend);

const getNodeFromSchema = (type, schema) => {
  const target = schema.nodes[type];
  if (!target)
    throw getAtomFromSchemaFail("node", type);
  return target;
};
const getMarkFromSchema = (type, schema) => {
  const target = schema.marks[type];
  if (!target)
    throw getAtomFromSchemaFail("mark", type);
  return target;
};

const findParentNodeClosestToPos = (predicate) => ($pos) => {
  for (let i = $pos.depth; i > 0; i--) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
  return void 0;
};
const findParentNode = (predicate) => (selection) => {
  return findParentNodeClosestToPos(predicate)(selection.$from);
};
const findSelectedNodeOfType = (selection, nodeType) => {
  if (!(selection instanceof NodeSelection))
    return;
  const { node, $from } = selection;
  if (equalNodeType(nodeType, node))
    return { node, pos: $from.pos, start: $from.start($from.depth), depth: $from.depth };
  return void 0;
};

const toggleMarkdownMark = (markType, mark) => {
  return (state, dispatch) => {
    var _a;
    const { tr, selection } = state;
    const { from, to, $cursor, ranges } = selection;
    const cursorMarks = (_a = $cursor == null ? void 0 : $cursor.marks()) != null ? _a : [];
    if ($cursor) {
      if (markType.isInSet(state.storedMarks || cursorMarks)) {
        dispatch == null ? void 0 : dispatch(tr.removeStoredMark(markType));
        return true;
      }
      dispatch == null ? void 0 : dispatch(tr.addStoredMark(markType.create()));
      return true;
    }
    let has = false;
    for (let i = 0; !has && i < ranges.length; i++) {
      const { $from, $to } = ranges[i];
      has = state.doc.rangeHasMark($from.pos, $to.pos, markType);
    }
    if (has) {
      for (let i = 0; i < ranges.length; i++) {
        const { $from, $to } = ranges[i];
        tr.removeMark($from.pos, $to.pos, markType);
      }
      dispatch == null ? void 0 : dispatch(tr.scrollIntoView());
      return true;
    }
    if (selection instanceof AllSelection)
      return false;
    dispatch == null ? void 0 : dispatch(tr.insertText(mark, from).insertText(mark, to + mark.length).scrollIntoView());
    return true;
  };
};

export { browser, calculateNodePosition, calculateTextPosition, cloneTr, customInputRules, customInputRulesKey, equalNodeType, findChildren, findChildrenByMark, findParentNode, findParentNodeClosestToPos, findSelectedNodeOfType, flatten, getMarkFromSchema, getNodeFromSchema, markRule, posToDOMRect, toggleMarkdownMark };
//# sourceMappingURL=index.js.map
