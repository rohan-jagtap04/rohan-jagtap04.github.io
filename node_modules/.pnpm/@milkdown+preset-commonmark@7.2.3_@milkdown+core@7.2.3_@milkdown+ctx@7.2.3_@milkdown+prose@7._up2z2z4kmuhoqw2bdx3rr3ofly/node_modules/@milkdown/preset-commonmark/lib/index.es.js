import { $markAttr as j, $markSchema as z, $command as g, $useKeymap as f, $node as Ye, $nodeAttr as N, $nodeSchema as I, $ctx as ee, $inputRule as L, pipe as wt, $prose as H, $remark as $ } from "@milkdown/utils";
import { remarkStringifyOptionsCtx as U, commandsCtx as h, editorViewCtx as Z, serializerCtx as At, parserCtx as vt } from "@milkdown/core";
import { toggleMark as Ht, setBlockType as _, wrapIn as te } from "@milkdown/prose/commands";
import { Fragment as Bt } from "@milkdown/prose/model";
import { expectDomTypeError as S } from "@milkdown/exception";
import { textblockTypeInputRule as Je, wrappingInputRule as re, InputRule as Qe } from "@milkdown/prose/inputrules";
import Tt from "@sindresorhus/slugify";
import { TextSelection as V, Selection as Xe, PluginKey as B, Plugin as T } from "@milkdown/prose/state";
import { toggleMarkdownMark as Ze, findSelectedNodeOfType as Ot } from "@milkdown/prose";
import { sinkListItem as Kt, liftListItem as et, splitListItem as Dt } from "@milkdown/prose/schema-list";
import { ReplaceStep as Rt, AddMarkStep as Pt } from "@milkdown/prose/transform";
import { Decoration as ze, DecorationSet as Ue } from "@milkdown/prose/view";
import { visit as ae } from "unist-util-visit";
import Et from "remark-inline-links";
const tt = (t, e) => {
  var o;
  if (!(e.childCount >= 1 && ((o = e.lastChild) == null ? void 0 : o.type.name) === "hardbreak")) {
    t.next(e.content);
    return;
  }
  const a = [];
  e.content.forEach((s, i, l) => {
    l !== e.childCount - 1 && a.push(s);
  }), t.next(Bt.fromArray(a));
}, n = (t, e) => (Object.assign(t, {
  meta: {
    package: "@milkdown/preset-commonmark",
    ...e
  }
}), t), ne = j("emphasis");
n(ne, {
  displayName: "Attr<emphasis>",
  group: "Emphasis"
});
const Y = z("emphasis", (t) => ({
  attrs: {
    marker: {
      default: t.get(U).emphasis || "*"
    }
  },
  parseDOM: [
    { tag: "i" },
    { tag: "em" },
    { style: "font-style", getAttrs: (e) => e === "italic" }
  ],
  toDOM: (e) => ["em", t.get(ne.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "emphasis",
    runner: (e, r, a) => {
      e.openMark(a, { marker: r.marker }), e.next(r.children), e.closeMark(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "emphasis",
    runner: (e, r) => {
      e.withMark(r, "emphasis", void 0, {
        marker: r.attrs.marker
      });
    }
  }
}));
n(Y.mark, {
  displayName: "MarkSchema<emphasis>",
  group: "Emphasis"
});
n(Y.ctx, {
  displayName: "MarkSchemaCtx<emphasis>",
  group: "Emphasis"
});
const oe = g("ToggleEmphasis", (t) => () => {
  const e = Y.type(), r = t.get(U).emphasis || "*";
  return Ze(e, r);
});
n(oe, {
  displayName: "Command<toggleEmphasisCommand>",
  group: "Emphasis"
});
const se = f("emphasisKeymap", {
  ToggleEmphasis: {
    shortcuts: "Mod-i",
    command: (t) => {
      const e = t.get(h);
      return () => e.call(oe.key);
    }
  }
});
n(se.ctx, {
  displayName: "KeymapCtx<emphasis>",
  group: "Emphasis"
});
n(se.shortcuts, {
  displayName: "Keymap<emphasis>",
  group: "Emphasis"
});
const le = j("strong");
n(le, {
  displayName: "Attr<strong>",
  group: "Strong"
});
const J = z("strong", (t) => ({
  attrs: {
    marker: {
      default: t.get(U).strong || "*"
    }
  },
  parseDOM: [
    { tag: "b" },
    { tag: "strong" },
    { style: "font-style", getAttrs: (e) => e === "bold" }
  ],
  toDOM: (e) => ["strong", t.get(le.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "strong",
    runner: (e, r, a) => {
      e.openMark(a, { marker: r.marker }), e.next(r.children), e.closeMark(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "strong",
    runner: (e, r) => {
      e.withMark(r, "strong", void 0, {
        marker: r.attrs.marker
      });
    }
  }
}));
n(J.mark, {
  displayName: "MarkSchema<strong>",
  group: "Strong"
});
n(J.ctx, {
  displayName: "MarkSchemaCtx<strong>",
  group: "Strong"
});
const ie = g("ToggleStrong", (t) => () => {
  const e = J.type(), r = t.get(U).strong || "*", a = r + r;
  return Ze(e, a);
});
n(ie, {
  displayName: "Command<toggleStrongCommand>",
  group: "Strong"
});
const ce = f("strongKeymap", {
  ToggleBold: {
    shortcuts: ["Mod-b"],
    command: (t) => {
      const e = t.get(h);
      return () => e.call(ie.key);
    }
  }
});
n(ce.ctx, {
  displayName: "KeymapCtx<strong>",
  group: "Strong"
});
n(ce.shortcuts, {
  displayName: "Keymap<strong>",
  group: "Strong"
});
const de = j("inlineCode");
n(de, {
  displayName: "Attr<inlineCode>",
  group: "InlineCode"
});
const b = z("inlineCode", (t) => ({
  priority: 100,
  code: !0,
  inclusive: !1,
  parseDOM: [{ tag: "code" }],
  toDOM: (e) => ["code", t.get(de.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "inlineCode",
    runner: (e, r, a) => {
      e.openMark(a), e.addText(r.value), e.closeMark(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "inlineCode",
    runner: (e, r, a) => {
      e.withMark(r, "inlineCode", a.text || "");
    }
  }
}));
n(b.mark, {
  displayName: "MarkSchema<inlineCode>",
  group: "InlineCode"
});
n(b.ctx, {
  displayName: "MarkSchemaCtx<inlineCode>",
  group: "InlineCode"
});
const me = g("ToggleInlineCode", () => () => (t, e) => {
  const { selection: r, tr: a } = t;
  if (r.empty)
    return !1;
  const { from: o, to: s } = r;
  return t.doc.rangeHasMark(o, s, b.type()) ? (e == null || e(a.removeMark(o, s, b.type())), !0) : (Object.keys(t.schema.marks).filter((c) => c !== b.type.name).map((c) => t.schema.marks[c]).forEach((c) => {
    a.removeMark(o, s, c);
  }), e == null || e(a.addMark(o, s, b.type().create())), !0);
});
n(me, {
  displayName: "Command<toggleInlineCodeCommand>",
  group: "InlineCode"
});
const ue = f("inlineCodeKeymap", {
  ToggleInlineCode: {
    shortcuts: "Mod-e",
    command: (t) => {
      const e = t.get(h);
      return () => e.call(me.key);
    }
  }
});
n(ue.ctx, {
  displayName: "KeymapCtx<inlineCode>",
  group: "InlineCode"
});
n(ue.shortcuts, {
  displayName: "Keymap<inlineCode>",
  group: "InlineCode"
});
const pe = j("link");
n(pe, {
  displayName: "Attr<link>",
  group: "Link"
});
const v = z("link", (t) => ({
  attrs: {
    href: {},
    title: { default: null }
  },
  parseDOM: [
    {
      tag: "a[href]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return { href: e.getAttribute("href"), title: e.getAttribute("title") };
      }
    }
  ],
  toDOM: (e) => ["a", { ...t.get(pe.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: (e) => e.type === "link",
    runner: (e, r, a) => {
      const o = r.url, s = r.title;
      e.openMark(a, { href: o, title: s }), e.next(r.children), e.closeMark(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "link",
    runner: (e, r) => {
      e.withMark(r, "link", void 0, {
        title: r.attrs.title,
        url: r.attrs.href
      });
    }
  }
}));
n(v.mark, {
  displayName: "MarkSchema<link>",
  group: "Link"
});
const rt = g("ToggleLink", () => (t = {}) => Ht(v.type(), t));
n(rt, {
  displayName: "Command<toggleLinkCommand>",
  group: "Link"
});
const at = g("UpdateLink", () => (t = {}) => (e, r) => {
  if (!r)
    return !1;
  let a, o = -1;
  const { selection: s } = e, { from: i, to: l } = s;
  if (e.doc.nodesBetween(i, i === l ? l + 1 : l, (p, k) => {
    if (v.type().isInSet(p.marks))
      return a = p, o = k, !1;
  }), !a)
    return !1;
  const c = a.marks.find(({ type: p }) => p === v.type());
  if (!c)
    return !1;
  const d = o, m = o + a.nodeSize, { tr: u } = e, y = v.type().create({ ...c.attrs, ...t });
  return y ? (r(
    u.removeMark(d, m, c).addMark(d, m, y).setSelection(new V(u.selection.$anchor)).scrollIntoView()
  ), !0) : !1;
});
n(at, {
  displayName: "Command<updateLinkCommand>",
  group: "Link"
});
const nt = Ye("doc", () => ({
  content: "block+",
  parseMarkdown: {
    match: ({ type: t }) => t === "root",
    runner: (t, e, r) => {
      t.injectRoot(e, r);
    }
  },
  toMarkdown: {
    match: (t) => t.type.name === "doc",
    runner: (t, e) => {
      t.openNode("root"), t.next(e.content);
    }
  }
}));
n(nt, {
  displayName: "NodeSchema<doc>",
  group: "Doc"
});
const ge = N("paragraph");
n(ge, {
  displayName: "Attr<paragraph>",
  group: "Paragraph"
});
const w = I("paragraph", (t) => ({
  content: "inline*",
  group: "block",
  parseDOM: [{ tag: "p" }],
  toDOM: (e) => ["p", t.get(ge.key)(e), 0],
  parseMarkdown: {
    match: (e) => e.type === "paragraph",
    runner: (e, r, a) => {
      e.openNode(a), r.children ? e.next(r.children) : e.addText(r.value || ""), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "paragraph",
    runner: (e, r) => {
      e.openNode("paragraph"), tt(e, r), e.closeNode();
    }
  }
}));
n(w.node, {
  displayName: "NodeSchema<paragraph>",
  group: "Paragraph"
});
n(w.ctx, {
  displayName: "NodeSchemaCtx<paragraph>",
  group: "Paragraph"
});
const he = g("TurnIntoText", () => () => _(w.type()));
n(he, {
  displayName: "Command<turnIntoTextCommand>",
  group: "Paragraph"
});
const ye = f("paragraphKeymap", {
  TurnIntoText: {
    shortcuts: "Mod-Alt-0",
    command: (t) => {
      const e = t.get(h);
      return () => e.call(he.key);
    }
  }
});
n(ye.ctx, {
  displayName: "KeymapCtx<paragraph>",
  group: "Paragraph"
});
n(ye.shortcuts, {
  displayName: "Keymap<paragraph>",
  group: "Paragraph"
});
const _t = Array(6).fill(0).map((t, e) => e + 1), $t = (t) => Tt(t.textContent), Q = ee($t, "headingIdGenerator");
n(Q, {
  displayName: "Ctx<HeadingIdGenerator>",
  group: "Heading"
});
const ke = N("heading");
n(ke, {
  displayName: "Attr<heading>",
  group: "Heading"
});
const A = I("heading", (t) => {
  const e = t.get(Q.key);
  return {
    content: "inline*",
    group: "block",
    defining: !0,
    attrs: {
      id: {
        default: ""
      },
      level: {
        default: 1
      }
    },
    parseDOM: _t.map((r) => ({
      tag: `h${r}`,
      getAttrs: (a) => {
        if (!(a instanceof HTMLElement))
          throw S(a);
        return { level: r, id: a.id };
      }
    })),
    toDOM: (r) => [
      `h${r.attrs.level}`,
      {
        ...t.get(ke.key)(r),
        id: r.attrs.id || e(r)
      },
      0
    ],
    parseMarkdown: {
      match: ({ type: r }) => r === "heading",
      runner: (r, a, o) => {
        const s = a.depth;
        r.openNode(o, { level: s }), r.next(a.children), r.closeNode();
      }
    },
    toMarkdown: {
      match: (r) => r.type.name === "heading",
      runner: (r, a) => {
        r.openNode("heading", void 0, { depth: a.attrs.level }), tt(r, a), r.closeNode();
      }
    }
  };
});
n(A.node, {
  displayName: "NodeSchema<heading>",
  group: "Heading"
});
n(A.ctx, {
  displayName: "NodeSchemaCtx<heading>",
  group: "Heading"
});
const ot = L((t) => Je(/^(?<hashes>#+)\s$/, A.type(), (e) => {
  var i, l;
  const r = ((l = (i = e.groups) == null ? void 0 : i.hashes) == null ? void 0 : l.length) || 0, a = t.get(Z), { $from: o } = a.state.selection, s = o.node();
  if (s.type.name === "heading") {
    let c = Number(s.attrs.level) + Number(r);
    return c > 6 && (c = 6), { level: c };
  }
  return { level: r };
}));
n(ot, {
  displayName: "InputRule<wrapInHeadingInputRule>",
  group: "Heading"
});
const M = g("WrapInHeading", () => (t) => (t ?? (t = 1), t < 1 ? _(w.type()) : _(A.type(), { level: t })));
n(M, {
  displayName: "Command<wrapInHeadingCommand>",
  group: "Heading"
});
const fe = g("DowngradeHeading", () => () => (t, e, r) => {
  const { $from: a } = t.selection, o = a.node();
  if (o.type !== A.type() || !t.selection.empty || a.parentOffset !== 0)
    return !1;
  const s = o.attrs.level - 1;
  return s ? (e == null || e(
    t.tr.setNodeMarkup(t.selection.$from.before(), void 0, {
      ...o.attrs,
      level: s
    })
  ), !0) : _(w.type())(t, e, r);
});
n(fe, {
  displayName: "Command<downgradeHeadingCommand>",
  group: "Heading"
});
const Ne = f("headingKeymap", {
  TurnIntoH1: {
    shortcuts: "Mod-Alt-1",
    command: (t) => {
      const e = t.get(h);
      return () => e.call(M.key, 1);
    }
  },
  TurnIntoH2: {
    shortcuts: "Mod-Alt-2",
    command: (t) => {
      const e = t.get(h);
      return () => e.call(M.key, 2);
    }
  },
  TurnIntoH3: {
    shortcuts: "Mod-Alt-3",
    command: (t) => {
      const e = t.get(h);
      return () => e.call(M.key, 3);
    }
  },
  TurnIntoH4: {
    shortcuts: "Mod-Alt-4",
    command: (t) => {
      const e = t.get(h);
      return () => e.call(M.key, 3);
    }
  },
  TurnIntoH5: {
    shortcuts: "Mod-Alt-5",
    command: (t) => {
      const e = t.get(h);
      return () => e.call(M.key, 3);
    }
  },
  TurnIntoH6: {
    shortcuts: "Mod-Alt-6",
    command: (t) => {
      const e = t.get(h);
      return () => e.call(M.key, 3);
    }
  },
  DowngradeHeading: {
    shortcuts: ["Delete", "Backspace"],
    command: (t) => {
      const e = t.get(h);
      return () => e.call(fe.key);
    }
  }
});
n(Ne.ctx, {
  displayName: "KeymapCtx<heading>",
  group: "Heading"
});
n(Ne.shortcuts, {
  displayName: "Keymap<heading>",
  group: "Heading"
});
const Ie = N("blockquote");
n(Ie, {
  displayName: "Attr<blockquote>",
  group: "Blockquote"
});
const q = I("blockquote", (t) => ({
  content: "block+",
  group: "block",
  defining: !0,
  parseDOM: [{ tag: "blockquote" }],
  toDOM: (e) => ["blockquote", t.get(Ie.key)(e), 0],
  parseMarkdown: {
    match: ({ type: e }) => e === "blockquote",
    runner: (e, r, a) => {
      e.openNode(a).next(r.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "blockquote",
    runner: (e, r) => {
      e.openNode("blockquote").next(r.content).closeNode();
    }
  }
}));
n(q.node, {
  displayName: "NodeSchema<blockquote>",
  group: "Blockquote"
});
n(q.ctx, {
  displayName: "NodeSchemaCtx<blockquote>",
  group: "Blockquote"
});
const st = L(() => re(/^\s*>\s$/, q.type()));
n(st, {
  displayName: "InputRule<wrapInBlockquoteInputRule>",
  group: "Blockquote"
});
const Ce = g("WrapInBlockquote", () => () => te(q.type()));
n(Ce, {
  displayName: "Command<wrapInBlockquoteCommand>",
  group: "Blockquote"
});
const Me = f("blockquoteKeymap", {
  WrapInBlockquote: {
    shortcuts: "Mod-Shift-b",
    command: (t) => {
      const e = t.get(h);
      return () => e.call(Ce.key);
    }
  }
});
n(Me.ctx, {
  displayName: "KeymapCtx<blockquote>",
  group: "Blockquote"
});
n(Me.shortcuts, {
  displayName: "Keymap<blockquote>",
  group: "Blockquote"
});
const be = N("codeBlock", () => ({
  pre: {},
  code: {}
}));
n(be, {
  displayName: "Attr<codeBlock>",
  group: "CodeBlock"
});
const W = I("code_block", (t) => ({
  content: "text*",
  group: "block",
  marks: "",
  defining: !0,
  code: !0,
  attrs: {
    language: {
      default: ""
    }
  },
  parseDOM: [
    {
      tag: "pre",
      preserveWhitespace: "full",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return { language: e.dataset.language };
      }
    }
  ],
  toDOM: (e) => {
    const r = t.get(be.key)(e);
    return [
      "pre",
      {
        ...r.pre,
        "data-language": e.attrs.language
      },
      ["code", r.code, 0]
    ];
  },
  parseMarkdown: {
    match: ({ type: e }) => e === "code",
    runner: (e, r, a) => {
      const o = r.lang, s = r.value;
      e.openNode(a, { language: o }), s && e.addText(s), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "code_block",
    runner: (e, r) => {
      var a;
      e.addNode("code", void 0, ((a = r.content.firstChild) == null ? void 0 : a.text) || "", {
        lang: r.attrs.language
      });
    }
  }
}));
n(W.node, {
  displayName: "NodeSchema<codeBlock>",
  group: "CodeBlock"
});
n(W.ctx, {
  displayName: "NodeSchemaCtx<codeBlock>",
  group: "CodeBlock"
});
const lt = L(() => Je(/^```(?<language>[a-z]*)?[\s\n]$/, W.type(), (t) => {
  var e;
  return {
    language: ((e = t.groups) == null ? void 0 : e.language) ?? ""
  };
}));
n(lt, {
  displayName: "InputRule<createCodeBlockInputRule>",
  group: "CodeBlock"
});
const xe = g("CreateCodeBlock", () => (t = "") => _(W.type(), { language: t }));
n(xe, {
  displayName: "Command<createCodeBlockCommand>",
  group: "CodeBlock"
});
const qt = g("UpdateCodeBlockLanguage", () => ({ pos: t, language: e } = { pos: -1, language: "" }) => (r, a) => t >= 0 ? (a == null || a(r.tr.setNodeAttribute(t, "language", e)), !0) : !1);
n(qt, {
  displayName: "Command<updateCodeBlockLanguageCommand>",
  group: "CodeBlock"
});
const Le = f("codeBlockKeymap", {
  CreateCodeBlock: {
    shortcuts: "Mod-Alt-c",
    command: (t) => {
      const e = t.get(h);
      return () => e.call(xe.key);
    }
  }
});
n(Le.ctx, {
  displayName: "KeymapCtx<codeBlock>",
  group: "CodeBlock"
});
n(Le.shortcuts, {
  displayName: "Keymap<codeBlock>",
  group: "CodeBlock"
});
const Se = N("image");
n(Se, {
  displayName: "Attr<image>",
  group: "Image"
});
const O = I("image", (t) => ({
  inline: !0,
  group: "inline",
  selectable: !0,
  draggable: !0,
  marks: "",
  atom: !0,
  defining: !0,
  isolating: !0,
  attrs: {
    src: { default: "" },
    alt: { default: "" },
    title: { default: "" }
  },
  parseDOM: [
    {
      tag: "img[src]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return {
          src: e.getAttribute("src") || "",
          alt: e.getAttribute("alt") || "",
          title: e.getAttribute("title") || e.getAttribute("alt") || ""
        };
      }
    }
  ],
  toDOM: (e) => ["img", { ...t.get(Se.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: ({ type: e }) => e === "image",
    runner: (e, r, a) => {
      const o = r.url, s = r.alt, i = r.title;
      e.addNode(a, {
        src: o,
        alt: s,
        title: i
      });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "image",
    runner: (e, r) => {
      e.addNode("image", void 0, void 0, {
        title: r.attrs.title,
        url: r.attrs.src,
        alt: r.attrs.alt
      });
    }
  }
}));
n(O.node, {
  displayName: "NodeSchema<image>",
  group: "Image"
});
n(O.ctx, {
  displayName: "NodeSchemaCtx<image>",
  group: "Image"
});
const it = g("InsertImage", () => (t = {}) => (e, r) => {
  if (!r)
    return !0;
  const { src: a = "", alt: o = "", title: s = "" } = t, i = O.type().create({ src: a, alt: o, title: s });
  return i && r(e.tr.replaceSelectionWith(i).scrollIntoView()), !0;
});
n(it, {
  displayName: "Command<insertImageCommand>",
  group: "Image"
});
const ct = g("UpdateImage", () => (t = {}) => (e, r) => {
  const a = Ot(e.selection, O.type());
  if (!a)
    return !1;
  const { node: o, pos: s } = a, i = { ...o.attrs }, { src: l, alt: c, title: d } = t;
  return l !== void 0 && (i.src = l), c !== void 0 && (i.alt = c), d !== void 0 && (i.title = d), r == null || r(e.tr.setNodeMarkup(s, void 0, i).scrollIntoView()), !0;
});
n(ct, {
  displayName: "Command<updateImageCommand>",
  group: "Image"
});
const Wt = L(() => new Qe(
  /!\[(?<alt>.*?)]\((?<filename>.*?)\s*(?="|\))"?(?<title>[^"]+)?"?\)/,
  (t, e, r, a) => {
    const [o, s, i = "", l] = e;
    return o ? t.tr.replaceWith(r, a, O.type().create({ src: i, alt: s, title: l })) : null;
  }
));
n(Wt, {
  displayName: "InputRule<insertImageInputRule>",
  group: "Image"
});
const we = N("hardbreak", (t) => ({
  "data-is-inline": t.attrs.isInline
}));
n(we, {
  displayName: "Attr<hardbreak>",
  group: "Hardbreak"
});
const x = I("hardbreak", (t) => ({
  inline: !0,
  group: "inline",
  attrs: {
    isInline: {
      default: !1
    }
  },
  selectable: !1,
  parseDOM: [{ tag: "br" }],
  toDOM: (e) => ["br", t.get(we.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "break",
    runner: (e, r, a) => {
      var o;
      e.addNode(a, { isInline: !!((o = r.data) != null && o.isInline) });
    }
  },
  leafText: () => `
`,
  toMarkdown: {
    match: (e) => e.type.name === "hardbreak",
    runner: (e, r) => {
      r.attrs.isInline ? e.addNode("text", void 0, `
`) : e.addNode("break");
    }
  }
}));
n(x.node, {
  displayName: "NodeSchema<hardbreak>",
  group: "Hardbreak"
});
n(x.ctx, {
  displayName: "NodeSchemaCtx<hardbreak>",
  group: "Hardbreak"
});
const Ae = g("InsertHardbreak", () => () => (t, e) => {
  var o;
  const { selection: r, tr: a } = t;
  if (r.empty) {
    const s = r.$from.node();
    if (s.childCount > 0 && ((o = s.lastChild) == null ? void 0 : o.type.name) === "hardbreak")
      return e == null || e(
        a.replaceRangeWith(r.to - 1, r.to, t.schema.node("paragraph")).setSelection(Xe.near(a.doc.resolve(r.to))).scrollIntoView()
      ), !0;
  }
  return e == null || e(a.setMeta("hardbreak", !0).replaceSelectionWith(x.type().create()).scrollIntoView()), !0;
});
n(Ae, {
  displayName: "Command<insertHardbreakCommand>",
  group: "Hardbreak"
});
const ve = f("hardbreakKeymap", {
  InsertHardbreak: {
    shortcuts: "Shift-Enter",
    command: (t) => {
      const e = t.get(h);
      return () => e.call(Ae.key);
    }
  }
});
n(ve.ctx, {
  displayName: "KeymapCtx<hardbreak>",
  group: "Hardbreak"
});
n(ve.shortcuts, {
  displayName: "Keymap<hardbreak>",
  group: "Hardbreak"
});
const He = N("hr");
n(He, {
  displayName: "Attr<hr>",
  group: "Hr"
});
const F = I("hr", (t) => ({
  group: "block",
  parseDOM: [{ tag: "hr" }],
  toDOM: (e) => ["hr", t.get(He.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "thematicBreak",
    runner: (e, r, a) => {
      e.addNode(a);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "hr",
    runner: (e) => {
      e.addNode("thematicBreak");
    }
  }
}));
n(F.node, {
  displayName: "NodeSchema<hr>",
  group: "Hr"
});
n(F.ctx, {
  displayName: "NodeSchemaCtx<hr>",
  group: "Hr"
});
const dt = L(() => new Qe(
  /^(?:---|___\s|\*\*\*\s)$/,
  (t, e, r, a) => {
    const { tr: o } = t;
    return e[0] && o.replaceWith(r - 1, a, F.type().create()), o;
  }
));
n(dt, {
  displayName: "InputRule<insertHrInputRule>",
  group: "Hr"
});
const mt = g("InsertHr", () => () => (t, e) => {
  if (!e)
    return !0;
  const r = w.node.type().create(), { tr: a, selection: o } = t, { from: s } = o, i = F.type().create();
  if (!i)
    return !0;
  const l = a.replaceSelectionWith(i).insert(s, r), c = Xe.findFrom(l.doc.resolve(s), 1, !0);
  return c && e(l.setSelection(c).scrollIntoView()), !0;
});
n(mt, {
  displayName: "Command<insertHrCommand>",
  group: "Hr"
});
const Be = N("bulletList");
n(Be, {
  displayName: "Attr<bulletList>",
  group: "BulletList"
});
const K = I("bullet_list", (t) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    spread: {
      default: !1
    }
  },
  parseDOM: [
    {
      tag: "ul",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return {
          spread: e.dataset.spread
        };
      }
    }
  ],
  toDOM: (e) => [
    "ul",
    {
      ...t.get(Be.key)(e),
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: r }) => e === "list" && !r,
    runner: (e, r, a) => {
      const o = r.spread != null ? `${r.spread}` : "false";
      e.openNode(a, { spread: o }).next(r.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "bullet_list",
    runner: (e, r) => {
      e.openNode("list", void 0, { ordered: !1, spread: r.attrs.spread === "true" }).next(r.content).closeNode();
    }
  }
}));
n(K.node, {
  displayName: "NodeSchema<bulletList>",
  group: "BulletList"
});
n(K.ctx, {
  displayName: "NodeSchemaCtx<bulletList>",
  group: "BulletList"
});
const ut = L(() => re(/^\s*([-+*])\s$/, K.type()));
n(ut, {
  displayName: "InputRule<wrapInBulletListInputRule>",
  group: "BulletList"
});
const Te = g("WrapInBulletList", () => () => te(K.type()));
n(Te, {
  displayName: "Command<wrapInBulletListCommand>",
  group: "BulletList"
});
const Oe = f("bulletListKeymap", {
  WrapInBulletList: {
    shortcuts: "Mod-Alt-8",
    command: (t) => {
      const e = t.get(h);
      return () => e.call(Te.key);
    }
  }
});
n(Oe.ctx, {
  displayName: "KeymapCtx<bulletListKeymap>",
  group: "BulletList"
});
n(Oe.shortcuts, {
  displayName: "Keymap<bulletListKeymap>",
  group: "BulletList"
});
const Ke = N("orderedList");
n(Ke, {
  displayName: "Attr<orderedList>",
  group: "OrderedList"
});
const D = I("ordered_list", (t) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    order: {
      default: 1
    },
    spread: {
      default: !1
    }
  },
  parseDOM: [
    {
      tag: "ol",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return {
          spread: e.dataset.spread,
          order: e.hasAttribute("start") ? Number(e.getAttribute("start")) : 1
        };
      }
    }
  ],
  toDOM: (e) => [
    "ol",
    {
      ...t.get(Ke.key)(e),
      ...e.attrs.order === 1 ? {} : e.attrs.order,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: r }) => e === "list" && !!r,
    runner: (e, r, a) => {
      const o = r.spread != null ? `${r.spread}` : "true";
      e.openNode(a, { spread: o }).next(r.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "ordered_list",
    runner: (e, r) => {
      e.openNode("list", void 0, { ordered: !0, start: 1, spread: r.attrs.spread === "true" }), e.next(r.content), e.closeNode();
    }
  }
}));
n(D.node, {
  displayName: "NodeSchema<orderedList>",
  group: "OrderedList"
});
n(D.ctx, {
  displayName: "NodeSchemaCtx<orderedList>",
  group: "OrderedList"
});
const pt = L(() => re(
  /^\s*(\d+)\.\s$/,
  D.type(),
  (t) => ({ order: Number(t[1]) }),
  (t, e) => e.childCount + e.attrs.order === Number(t[1])
));
n(pt, {
  displayName: "InputRule<wrapInOrderedListInputRule>",
  group: "OrderedList"
});
const De = g("WrapInOrderedList", () => () => te(D.type()));
n(De, {
  displayName: "Command<wrapInOrderedListCommand>",
  group: "OrderedList"
});
const Re = f("orderedListKeymap", {
  WrapInOrderedList: {
    shortcuts: "Mod-Alt-7",
    command: (t) => {
      const e = t.get(h);
      return () => e.call(De.key);
    }
  }
});
n(Re.ctx, {
  displayName: "KeymapCtx<orderedList>",
  group: "OrderedList"
});
n(Re.shortcuts, {
  displayName: "Keymap<orderedList>",
  group: "OrderedList"
});
const Pe = N("listItem");
n(Pe, {
  displayName: "Attr<listItem>",
  group: "ListItem"
});
const C = I("list_item", (t) => ({
  group: "listItem",
  content: "paragraph block*",
  attrs: {
    label: {
      default: "•"
    },
    listType: {
      default: "bullet"
    },
    spread: {
      default: "true"
    }
  },
  defining: !0,
  parseDOM: [
    {
      tag: "li",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement))
          throw S(e);
        return {
          label: e.dataset.label,
          listType: e.dataset["list-type"],
          spread: e.dataset.spread
        };
      }
    }
  ],
  toDOM: (e) => [
    "li",
    {
      ...t.get(Pe.key)(e),
      "data-label": e.attrs.label,
      "data-list-type": e.attrs.listType,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e }) => e === "listItem",
    runner: (e, r, a) => {
      const o = r.label != null ? `${r.label}.` : "•", s = r.label != null ? "ordered" : "bullet", i = r.spread != null ? `${r.spread}` : "true";
      e.openNode(a, { label: o, listType: s, spread: i }), e.next(r.children), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "list_item",
    runner: (e, r) => {
      e.openNode("listItem", void 0, { spread: r.attrs.spread === "true" }), e.next(r.content), e.closeNode();
    }
  }
}));
n(C.node, {
  displayName: "NodeSchema<listItem>",
  group: "ListItem"
});
n(C.ctx, {
  displayName: "NodeSchemaCtx<listItem>",
  group: "ListItem"
});
const Ee = g("SinkListItem", () => () => Kt(C.type()));
n(Ee, {
  displayName: "Command<sinkListItemCommand>",
  group: "ListItem"
});
const _e = g("SplitListItem", () => () => et(C.type()));
n(_e, {
  displayName: "Command<liftListItemCommand>",
  group: "ListItem"
});
const $e = g("SplitListItem", () => () => Dt(C.type()));
n($e, {
  displayName: "Command<splitListItemCommand>",
  group: "ListItem"
});
const Ft = (t, e, r) => {
  const { selection: a } = t;
  if (!(a instanceof V))
    return !1;
  const { empty: o, $from: s } = a;
  if (!o || s.parentOffset !== 0)
    return !1;
  const i = s.node(-1);
  return i.type !== C.type() || i.firstChild !== s.node() || s.node(-2).childCount > 1 ? !1 : et(C.type())(t, e, r);
}, qe = g("LiftFirstListItem", () => () => Ft);
n(qe, {
  displayName: "Command<liftFirstListItemCommand>",
  group: "ListItem"
});
const We = f("listItemKeymap", {
  NextListItem: {
    shortcuts: "Enter",
    command: (t) => {
      const e = t.get(h);
      return () => e.call($e.key);
    }
  },
  SinkListItem: {
    shortcuts: ["Tab", "Mod-]"],
    command: (t) => {
      const e = t.get(h);
      return () => e.call(Ee.key);
    }
  },
  LiftListItem: {
    shortcuts: ["Shift-Tab", "Mod-["],
    command: (t) => {
      const e = t.get(h);
      return () => e.call(_e.key);
    }
  },
  LiftFirstListItem: {
    shortcuts: ["Backspace", "Delete"],
    command: (t) => {
      const e = t.get(h);
      return () => e.call(qe.key);
    }
  }
});
n(We.ctx, {
  displayName: "KeymapCtx<listItem>",
  group: "ListItem"
});
n(We.shortcuts, {
  displayName: "Keymap<listItem>",
  group: "ListItem"
});
const gt = Ye("text", () => ({
  group: "inline",
  parseMarkdown: {
    match: ({ type: t }) => t === "text",
    runner: (t, e) => {
      t.addText(e.value);
    }
  },
  toMarkdown: {
    match: (t) => t.type.name === "text",
    runner: (t, e) => {
      t.addNode("text", void 0, e.text);
    }
  }
}));
n(gt, {
  displayName: "NodeSchema<text>",
  group: "Text"
});
const Fe = N("html");
n(Fe, {
  displayName: "Attr<html>",
  group: "Html"
});
const Ge = I("html", (t) => ({
  atom: !0,
  group: "inline",
  inline: !0,
  attrs: {
    value: {
      default: ""
    }
  },
  toDOM: (e) => {
    const r = document.createElement("span"), a = {
      ...t.get(Fe.key)(e),
      "data-value": e.attrs.value,
      "data-type": "html"
    };
    return r.textContent = e.attrs.value, ["span", a, e.attrs.value];
  },
  parseDOM: [{
    tag: 'span[data-type="html"]',
    getAttrs: (e) => ({
      value: e.dataset.value ?? ""
    })
  }],
  parseMarkdown: {
    match: ({ type: e }) => e === "html",
    runner: (e, r, a) => {
      e.addNode(a, { value: r.value });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "html",
    runner: (e, r) => {
      e.addNode("html", void 0, r.attrs.value);
    }
  }
}));
n(Ge.node, {
  displayName: "NodeSchema<html>",
  group: "Html"
});
n(Ge.ctx, {
  displayName: "NodeSchemaCtx<html>",
  group: "Html"
});
const Gt = [
  nt,
  ge,
  w,
  Q,
  ke,
  A,
  we,
  x,
  Ie,
  q,
  be,
  W,
  He,
  F,
  Se,
  O,
  Be,
  K,
  Ke,
  D,
  Pe,
  C,
  ne,
  Y,
  le,
  J,
  de,
  b,
  pe,
  v,
  Fe,
  Ge,
  gt
].flat(), Vt = [
  st,
  ut,
  pt,
  lt,
  dt,
  ot
].flat(), jt = [
  he,
  Ce,
  M,
  fe,
  xe,
  Ae,
  mt,
  it,
  ct,
  De,
  Te,
  Ee,
  $e,
  _e,
  qe,
  oe,
  me,
  ie,
  rt,
  at
], zt = [
  Me,
  Le,
  ve,
  Ne,
  We,
  Re,
  Oe,
  ye,
  se,
  ue,
  ce
].flat(), Ut = /\[([^\]]+)]\([^\s\]]+\)/, X = /\[(?<span>((www|https:\/\/|http:\/\/)[^\s\]]+))]\((?<url>[^\s\]]+)\)/, Yt = (t) => new RegExp(`\\\\(?=[^\\w\\s${t}\\\\]|_)`, "g"), Jt = (t) => {
  let e = t, r = e.match(X);
  for (; r && r.groups; ) {
    const { span: a } = r.groups;
    e = e.replace(X, a), r = e.match(X);
  }
  return e;
}, Qt = (t, e, r) => {
  const a = t.split(""), o = a[e];
  return a[e] && a[r] && (a[e] = a[r], a[r] = o), a.join("").toString();
}, Xt = (t) => (e) => e.replace(Yt(t), ""), Zt = (t) => (e) => {
  const r = e.indexOf(t.hole), a = e.charAt(r - 1), o = e.charAt(r + 1), s = /[^\w]|_/;
  return o ? a && s.test(a) && s.test(o) ? t.punctuation : t.char : t.punctuation;
}, er = (t, e, r) => {
  let a = e, o = !1;
  return t.descendants((s) => {
    var i;
    if (o)
      return !1;
    if (!s.textContent.includes(r))
      return a += s.nodeSize, !1;
    if (s.isText) {
      const l = (i = s.text) == null ? void 0 : i.indexOf(r);
      if (l != null && l >= 0)
        return o = !0, a += l, !1;
    }
    return a += 1, !0;
  }), a;
}, tr = {
  placeholderConfig: {
    hole: "∅",
    punctuation: "⁂",
    char: "∴"
  },
  globalNodes: ["footnote_definition"],
  shouldSyncNode: ({ prevNode: t, nextNode: e }) => t.inlineContent && e && t.type === e.type && !t.eq(e),
  movePlaceholder: (t, e) => {
    const r = ["*", "_"];
    let a = e.indexOf(t);
    for (; r.includes(e[a - 1] || "") && r.includes(e[a + 1] || ""); )
      e = Qt(e, a, a + 1), a = a + 1;
    return e;
  }
}, R = ee(tr, "inlineSyncConfig");
n(R, {
  displayName: "Ctx<inlineSyncConfig>",
  group: "Prose"
});
const rr = (t) => t.selection.$from.node(), ar = (t, e, r, a) => {
  const o = t.get(At), s = e.schema.topNodeType.create(void 0, [r, ...a]);
  return o(s);
}, nr = (t, e) => {
  const r = t.get(R.key), a = r.placeholderConfig.hole, [o = "", ...s] = e.split(`

`), i = (m) => r.movePlaceholder(a, m);
  let c = wt(Xt(a), i, Jt)(o);
  const d = Zt(r.placeholderConfig)(c);
  return c = c.replace(a, d), c = [c, ...s].join(`

`), [c, d];
}, or = (t, e) => {
  const a = t.get(vt)(e);
  return a ? a.firstChild : null;
}, sr = (t, e) => {
  const { globalNodes: r } = t.get(R.key), a = [];
  return e.doc.descendants((o) => {
    if (r.includes(o.type.name) || r.includes(o.type))
      return a.push(o), !1;
  }), a;
}, lr = (t) => t.split(`

`)[0] || "", ir = (t) => t.childCount === 1 && t.child(0).type.name === "html", ht = (t, e) => {
  try {
    const r = sr(t, e), a = rr(e), o = ar(t, e, a, r), [s, i] = nr(t, o), l = or(t, s);
    return !l || a.type !== l.type || ir(l) ? null : (l.attrs = { ...a.attrs }, l.descendants((c) => {
      var u;
      const m = c.marks.find((y) => y.type.name === "link");
      m && ((u = c.text) != null && u.includes(i)) && m.attrs.href.includes(i) && (m.attrs.href = m.attrs.href.replace(i, ""));
    }), {
      text: lr(s),
      prevNode: a,
      nextNode: l,
      placeholder: i
    });
  } catch {
    return null;
  }
}, cr = (t, e, r, a, o) => {
  var E;
  const { placeholderConfig: s } = t.get(R.key), i = s.hole;
  let l = r.tr.setMeta(e, !0).insertText(i, r.selection.from);
  const c = r.apply(l), d = ht(t, c);
  if (!d)
    return;
  const m = d.text.slice(0, d.text.indexOf(d.placeholder)), { $from: u } = c.selection, y = u.before(), p = u.after(), k = er(d.nextNode, y, d.placeholder);
  l = l.replaceWith(y, p, d.nextNode).setNodeMarkup(y, void 0, o).delete(k + 1, k + 2), l = l.setSelection(V.near(l.doc.resolve(k + 1))), (Ut.test(m) || ["*", "_", "~"].includes(m.at(-1) || "")) && l.selection instanceof V && (((E = l.selection.$cursor) == null ? void 0 : E.marks()) ?? []).forEach((G) => {
    l = l.removeStoredMark(G.type);
  }), a(l);
}, yt = H((t) => {
  let e = null;
  const r = new B("MILKDOWN_INLINE_SYNC");
  return new T({
    key: r,
    state: {
      init: () => null,
      apply: (a, o, s, i) => {
        var k;
        const l = t.get(Z);
        if (!((k = l.hasFocus) != null && k.call(l)) || !l.editable || !a.docChanged || a.getMeta(r))
          return null;
        const d = ht(t, i);
        if (!d)
          return null;
        e && (cancelAnimationFrame(e), e = null);
        const { prevNode: m, nextNode: u, text: y } = d, { shouldSyncNode: p } = t.get(R.key);
        return p({ prevNode: m, nextNode: u, ctx: t, tr: a, text: y }) && (e = requestAnimationFrame(() => {
          e = null;
          const { dispatch: P, state: E } = t.get(Z);
          cr(t, r, E, P, m.attrs);
        })), null;
      }
    }
  });
});
n(yt, {
  displayName: "Prose<inlineSyncPlugin>",
  group: "Prose"
});
const kt = $(() => () => (t) => {
  ae(t, "list", (e) => {
    if (e.ordered) {
      const r = e.start ?? 1;
      e.children.forEach((a, o) => {
        a.label = o + r;
      });
    }
  });
});
n(kt, {
  displayName: "Remark<remarkAddOrderInListPlugin>",
  group: "Remark"
});
const ft = $(() => () => (t) => {
  const e = /[\t ]*(?:\r?\n|\r)/g;
  ae(t, "text", (r, a, o) => {
    if (!r.value || typeof r.value != "string")
      return;
    const s = [];
    let i = 0;
    e.lastIndex = 0;
    let l = e.exec(r.value);
    for (; l; ) {
      const d = l.index;
      i !== d && s.push({ type: "text", value: r.value.slice(i, d) }), s.push({ type: "break", data: { isInline: !0 } }), i = d + l[0].length, l = e.exec(r.value);
    }
    if (s.length > 0 && o && typeof a == "number")
      return i < r.value.length && s.push({ type: "text", value: r.value.slice(i) }), o.children.splice(a, 1, ...s), a + s.length;
  });
});
n(ft, {
  displayName: "Remark<remarkLineBreak>",
  group: "Remark"
});
const Nt = $(() => Et);
n(Nt, {
  displayName: "Remark<remarkInlineLinkPlugin>",
  group: "Remark"
});
const dr = (t) => !!t.children, mr = (t) => t.type === "html";
function ur(t, e) {
  return r(t, 0, null)[0];
  function r(a, o, s) {
    if (dr(a)) {
      const i = [];
      for (let l = 0, c = a.children.length; l < c; l++) {
        const d = a.children[l];
        if (d) {
          const m = r(d, l, a);
          if (m)
            for (let u = 0, y = m.length; u < y; u++) {
              const p = m[u];
              p && i.push(p);
            }
        }
      }
      a.children = i;
    }
    return e(a, o, s);
  }
}
const It = $(() => () => (t) => {
  ur(t, (e, r, a) => mr(e) ? ((a == null ? void 0 : a.type) === "root" && (e.children = [{ ...e }], delete e.value, e.type = "paragraph"), [e]) : [e]);
});
n(It, {
  displayName: "Remark<remarkHtmlTransformer>",
  group: "Remark"
});
const Ct = $(() => () => (t, e) => {
  const r = (a) => e.value.charAt(a.position.start.offset);
  ae(t, (a) => ["strong", "emphasis"].includes(a.type), (a) => {
    a.marker = r(a);
  });
});
n(Ct, {
  displayName: "Remark<remarkMarker>",
  group: "Remark"
});
const Mt = H(() => {
  let t = !1;
  const e = new B("MILKDOWN_INLINE_NODES_CURSOR"), r = new T({
    key: e,
    state: {
      init() {
        return !1;
      },
      apply(a) {
        if (!a.selection.empty)
          return !1;
        const o = a.selection.$from, s = o.nodeBefore, i = o.nodeAfter;
        return !!(s && i && s.isInline && !s.isText && i.isInline && !i.isText);
      }
    },
    props: {
      handleDOMEvents: {
        compositionend: (a, o) => t ? (t = !1, requestAnimationFrame(() => {
          if (r.getState(a.state)) {
            const i = a.state.selection.from;
            o.preventDefault(), a.dispatch(a.state.tr.insertText(o.data || "", i));
          }
        }), !0) : !1,
        compositionstart: (a) => (r.getState(a.state) && (t = !0), !1),
        beforeinput: (a, o) => {
          if (r.getState(a.state) && o instanceof InputEvent && o.data && !t) {
            const i = a.state.selection.from;
            return o.preventDefault(), a.dispatch(a.state.tr.insertText(o.data || "", i)), !0;
          }
          return !1;
        }
      },
      decorations(a) {
        if (r.getState(a)) {
          const i = a.selection.$from.pos, l = document.createElement("span"), c = ze.widget(i, l, {
            side: -1
          }), d = document.createElement("span"), m = ze.widget(i, d);
          return setTimeout(() => {
            l.contentEditable = "true", d.contentEditable = "true";
          }), Ue.create(a.doc, [c, m]);
        }
        return Ue.empty;
      }
    }
  });
  return r;
});
n(Mt, {
  displayName: "Prose<inlineNodesCursorPlugin>",
  group: "Prose"
});
const bt = H(() => new T({
  key: new B("MILKDOWN_HARDBREAK_MARKS"),
  appendTransaction: (t, e, r) => {
    if (!t.length)
      return;
    const [a] = t;
    if (!a)
      return;
    const [o] = a.steps;
    if (a.getMeta("hardbreak")) {
      if (!(o instanceof Rt))
        return;
      const { from: l } = o;
      return r.tr.setNodeMarkup(l, x.type(), void 0, []);
    }
    if (o instanceof Pt) {
      let l = r.tr;
      const { from: c, to: d } = o;
      return r.doc.nodesBetween(c, d, (m, u) => {
        m.type === x.type() && (l = l.setNodeMarkup(u, x.type(), void 0, []));
      }), l;
    }
  }
}));
n(bt, {
  displayName: "Prose<hardbreakClearMarkPlugin>",
  group: "Prose"
});
const Ve = ee(["table", "code_block"], "hardbreakFilterNodes");
n(Ve, {
  displayName: "Ctx<hardbreakFilterNodes>",
  group: "Prose"
});
const xt = H((t) => {
  const e = t.get(Ve.key);
  return new T({
    key: new B("MILKDOWN_HARDBREAK_FILTER"),
    filterTransaction: (r, a) => {
      const o = r.getMeta("hardbreak"), [s] = r.steps;
      if (o && s) {
        const { from: i } = s, l = a.doc.resolve(i);
        let c = l.depth, d = !0;
        for (; c > 0; )
          e.includes(l.node(c).type.name) && (d = !1), c--;
        return d;
      }
      return !0;
    }
  });
});
n(xt, {
  displayName: "Prose<hardbreakFilterPlugin>",
  group: "Prose"
});
const Lt = H((t) => {
  const e = new B("MILKDOWN_HEADING_ID"), r = (a) => {
    if (a.composing || !a.editable)
      return;
    const o = t.get(Q.key), s = a.state.tr.setMeta("addToHistory", !1);
    let i = !1;
    a.state.doc.descendants((l, c) => {
      if (l.type === A.type()) {
        if (l.textContent.trim().length === 0)
          return;
        const d = l.attrs, m = o(l);
        d.id !== m && (i = !0, s.setMeta(e, !0).setNodeMarkup(c, void 0, {
          ...d,
          id: m
        }));
      }
    }), i && a.dispatch(s);
  };
  return new T({
    key: e,
    view: (a) => (r(a), {
      update: (o) => {
        r(o);
      }
    })
  });
});
n(Lt, {
  displayName: "Prose<syncHeadingIdPlugin>",
  group: "Prose"
});
const St = H(() => {
  const t = (e) => {
    if (e.composing || !e.editable)
      return;
    const r = D.type(), a = K.type(), o = C.type(), s = e.state, i = (d, m) => {
      let u = !1;
      const y = `${m + 1}.`;
      return d.label !== y && (d.label = y, u = !0), u;
    };
    let l = s.tr, c = !1;
    s.doc.descendants((d, m, u, y) => {
      if (d.type === a) {
        const p = d.maybeChild(0);
        (p == null ? void 0 : p.type) === o && p.attrs.listType === "ordered" && (c = !0, l.setNodeMarkup(m, r, { spread: "true" }), d.descendants((k, P, E, je) => {
          if (k.type === o) {
            const G = { ...k.attrs };
            i(G, je) && (l = l.setNodeMarkup(P, void 0, G));
          }
          return !1;
        }));
      } else if (d.type === o && (u == null ? void 0 : u.type) === r) {
        const p = { ...d.attrs };
        let k = !1;
        p.listType !== "ordered" && (p.listType = "ordered", k = !0), (u == null ? void 0 : u.maybeChild(0)) && (k = i(p, y)), k && (l = l.setNodeMarkup(m, void 0, p), c = !0);
      }
    }), c && e.dispatch(l.setMeta("addToHistory", !1));
  };
  return new T({
    key: new B("MILKDOWN_KEEP_LIST_ORDER"),
    view: (e) => (t(e), {
      update: (r) => {
        t(r);
      }
    })
  });
});
n(St, {
  displayName: "Prose<syncListOrderPlugin>",
  group: "Prose"
});
const pr = [
  R,
  yt,
  bt,
  Ve,
  xt,
  Mt,
  kt,
  Nt,
  ft,
  It,
  Ct,
  Lt,
  St
], vr = [Gt, Vt, jt, zt, pr].flat();
export {
  Ie as blockquoteAttr,
  Me as blockquoteKeymap,
  q as blockquoteSchema,
  Be as bulletListAttr,
  Oe as bulletListKeymap,
  K as bulletListSchema,
  be as codeBlockAttr,
  Le as codeBlockKeymap,
  W as codeBlockSchema,
  jt as commands,
  vr as commonmark,
  xe as createCodeBlockCommand,
  lt as createCodeBlockInputRule,
  tr as defaultConfig,
  nt as docSchema,
  fe as downgradeHeadingCommand,
  ne as emphasisAttr,
  se as emphasisKeymap,
  Y as emphasisSchema,
  we as hardbreakAttr,
  bt as hardbreakClearMarkPlugin,
  Ve as hardbreakFilterNodes,
  xt as hardbreakFilterPlugin,
  ve as hardbreakKeymap,
  x as hardbreakSchema,
  ke as headingAttr,
  Q as headingIdGenerator,
  Ne as headingKeymap,
  A as headingSchema,
  He as hrAttr,
  F as hrSchema,
  Fe as htmlAttr,
  Ge as htmlSchema,
  Se as imageAttr,
  O as imageSchema,
  de as inlineCodeAttr,
  ue as inlineCodeKeymap,
  b as inlineCodeSchema,
  Mt as inlineNodesCursorPlugin,
  R as inlineSyncConfig,
  yt as inlineSyncPlugin,
  Vt as inputrules,
  Ae as insertHardbreakCommand,
  mt as insertHrCommand,
  dt as insertHrInputRule,
  it as insertImageCommand,
  Wt as insertImageInputRule,
  zt as keymap,
  qe as liftFirstListItemCommand,
  _e as liftListItemCommand,
  pe as linkAttr,
  v as linkSchema,
  Pe as listItemAttr,
  We as listItemKeymap,
  C as listItemSchema,
  Ke as orderedListAttr,
  Re as orderedListKeymap,
  D as orderedListSchema,
  ge as paragraphAttr,
  ye as paragraphKeymap,
  w as paragraphSchema,
  pr as plugins,
  kt as remarkAddOrderInListPlugin,
  It as remarkHtmlTransformer,
  Nt as remarkInlineLinkPlugin,
  ft as remarkLineBreak,
  Ct as remarkMarker,
  Gt as schema,
  Ee as sinkListItemCommand,
  $e as splitListItemCommand,
  le as strongAttr,
  ce as strongKeymap,
  J as strongSchema,
  Lt as syncHeadingIdPlugin,
  St as syncListOrderPlugin,
  gt as textSchema,
  oe as toggleEmphasisCommand,
  me as toggleInlineCodeCommand,
  rt as toggleLinkCommand,
  ie as toggleStrongCommand,
  he as turnIntoTextCommand,
  qt as updateCodeBlockLanguageCommand,
  ct as updateImageCommand,
  at as updateLinkCommand,
  Ce as wrapInBlockquoteCommand,
  st as wrapInBlockquoteInputRule,
  Te as wrapInBulletListCommand,
  ut as wrapInBulletListInputRule,
  M as wrapInHeadingCommand,
  ot as wrapInHeadingInputRule,
  De as wrapInOrderedListCommand,
  pt as wrapInOrderedListInputRule
};
//# sourceMappingURL=index.es.js.map
