var t = /* @__PURE__ */ ((e) => (e.docTypeError = "docTypeError", e.contextNotFound = "contextNotFound", e.timerNotFound = "timerNotFound", e.ctxCallOutOfScope = "ctxCallOutOfScope", e.createNodeInParserFail = "createNodeInParserFail", e.stackOverFlow = "stackOverFlow", e.parserMatchError = "parserMatchError", e.serializerMatchError = "serializerMatchError", e.getAtomFromSchemaFail = "getAtomFromSchemaFail", e.expectDomTypeError = "expectDomTypeError", e.callCommandBeforeEditorView = "callCommandBeforeEditorView", e.missingRootElement = "missingRootElement", e.missingNodeInSchema = "missingNodeInSchema", e.missingMarkInSchema = "missingMarkInSchema", e.ctxNotBind = "ctxNotBind", e.missingYjsDoc = "missingYjsDoc", e))(t || {});
class n extends Error {
  constructor(o, a) {
    super(a), this.name = "MilkdownError", this.code = o;
  }
}
const l = (e, o) => typeof o == "function" ? "[Function]" : o, i = (e) => JSON.stringify(e, l), d = (e) => new n(t.docTypeError, `Doc type error, unsupported type: ${i(e)}`), p = (e) => new n(t.contextNotFound, `Context "${e}" not found, do you forget to inject it?`), u = (e) => new n(t.timerNotFound, `Timer "${e}" not found, do you forget to record it?`), g = () => new n(t.ctxCallOutOfScope, "Should not call a context out of the plugin."), h = (...e) => {
  const o = e.reduce((a, c) => {
    if (!c)
      return a;
    const s = (r) => Array.isArray(r) ? r.map((m) => s(m)).join(", ") : r.toJSON ? i(r.toJSON()) : r.spec ? i(r.spec) : r.toString();
    return `${a}, ${s(c)}`;
  }, "Create prosemirror node from remark failed in parser");
  return new n(t.createNodeInParserFail, o);
}, f = () => new n(t.stackOverFlow, "Stack over flow, cannot pop on an empty stack."), w = (e) => new n(t.parserMatchError, `Cannot match target parser for node: ${i(e)}.`), F = (e) => new n(t.serializerMatchError, `Cannot match target serializer for node: ${i(e)}.`), N = (e, o) => new n(t.getAtomFromSchemaFail, `Cannot get ${e}: ${o} from schema.`), S = (e) => new n(t.expectDomTypeError, `Expect to be a dom, but get: ${i(e)}.`), y = () => new n(
  t.callCommandBeforeEditorView,
  "You're trying to call a command before editor view initialized, make sure to get commandManager from ctx after editor view has been initialized"
), k = () => new n(
  t.missingRootElement,
  "Missing root element, milkdown cannot find root element of the editor."
), M = (e) => new n(
  t.missingNodeInSchema,
  `Missing node in schema, milkdown cannot find "${e}" in schema.`
), x = (e) => new n(
  t.missingMarkInSchema,
  `Missing mark in schema, milkdown cannot find "${e}" in schema.`
), O = () => new n(t.ctxNotBind, "Context not bind, please make sure the plugin has been initialized."), E = () => new n(t.missingYjsDoc, "Missing yjs doc, please make sure you have bind one.");
export {
  y as callCommandBeforeEditorView,
  p as contextNotFound,
  h as createNodeInParserFail,
  g as ctxCallOutOfScope,
  O as ctxNotBind,
  d as docTypeError,
  S as expectDomTypeError,
  N as getAtomFromSchemaFail,
  x as missingMarkInSchema,
  M as missingNodeInSchema,
  k as missingRootElement,
  E as missingYjsDoc,
  w as parserMatchError,
  F as serializerMatchError,
  f as stackOverFlow,
  u as timerNotFound
};
//# sourceMappingURL=index.es.js.map
