{"version":3,"file":"index.es.js","sources":["../src/__internal__/utils.ts","../src/__internal__/remark-handlers.ts","../src/internal-plugin/config.ts","../src/internal-plugin/init.ts","../src/internal-plugin/schema.ts","../src/internal-plugin/parser.ts","../src/internal-plugin/serializer.ts","../src/internal-plugin/editor-state.ts","../src/internal-plugin/editor-view.ts","../src/internal-plugin/commands.ts","../src/editor/editor.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nimport type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport const withMeta = <T extends MilkdownPlugin>(plugin: T, meta: Partial<Meta> & Pick<Meta, 'displayName'>): T => {\n  plugin.meta = {\n    package: '@milkdown/core',\n    group: 'System',\n    ...meta,\n  }\n\n  return plugin\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Handlers } from 'mdast-util-to-markdown'\n\nexport const remarkHandlers: Partial<Handlers> = {\n  strong: (node, _, state, info) => {\n    const marker = node.marker || state.options.strong || '*'\n    const exit = state.enter('strong')\n    const tracker = state.createTracker(info)\n    let value = tracker.move(marker + marker)\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: marker,\n        ...tracker.current(),\n      }),\n    )\n    value += tracker.move(marker + marker)\n    exit()\n    return value\n  },\n  emphasis: (node, _, state, info) => {\n    const marker = node.marker || state.options.emphasis || '*'\n    const exit = state.enter('emphasis')\n    const tracker = state.createTracker(info)\n    let value = tracker.move(marker)\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: marker,\n        ...tracker.current(),\n      }),\n    )\n    value += tracker.move(marker)\n    exit()\n    return value\n  },\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport { createTimer } from '@milkdown/ctx'\nimport { withMeta } from '../__internal__'\n\n/// @internal\nexport type Config = (ctx: Ctx) => void | Promise<void>\n\n/// The timer which will be resolved when the config plugin is ready.\nexport const ConfigReady = createTimer('ConfigReady')\n\n/// The config plugin.\n/// This plugin will load all user configs.\nexport const config = (configure: Config): MilkdownPlugin => {\n  const plugin: MilkdownPlugin = (ctx) => {\n    ctx.record(ConfigReady)\n\n    return async () => {\n      await configure(ctx)\n      ctx.done(ConfigReady)\n\n      return () => {\n        ctx.clearTimer(ConfigReady)\n      }\n    }\n  }\n\n  withMeta(plugin, {\n    displayName: 'Config',\n  })\n\n  return plugin\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin, SliceType, TimerType } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport type { InputRule } from '@milkdown/prose/inputrules'\nimport type { Plugin } from '@milkdown/prose/state'\nimport type { MarkViewConstructor, NodeViewConstructor } from '@milkdown/prose/view'\nimport type { RemarkParser, RemarkPlugin } from '@milkdown/transformer'\nimport remarkParse from 'remark-parse'\nimport type { Options } from 'remark-stringify'\nimport remarkStringify from 'remark-stringify'\nimport { unified } from 'unified'\n\nimport type { Editor } from '../editor'\nimport { remarkHandlers, withMeta } from '../__internal__'\nimport { ConfigReady } from './config'\n\n/// The timer which will be resolved when the init plugin is ready.\nexport const InitReady = createTimer('InitReady')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[ConfigReady]`.\nexport const initTimerCtx = createSlice([] as TimerType[], 'initTimer')\n\n/// A slice which stores the editor instance.\nexport const editorCtx = createSlice({} as Editor, 'editor')\n\n/// A slice which stores the input rules.\nexport const inputRulesCtx = createSlice([] as InputRule[], 'inputRules')\n\n/// A slice which stores the prosemirror plugins.\nexport const prosePluginsCtx = createSlice([] as Plugin[], 'prosePlugins')\n\n/// A slice which stores the remark plugins.\nexport const remarkPluginsCtx = createSlice([] as RemarkPlugin[], 'remarkPlugins')\n\ntype NodeView = [nodeId: string, view: NodeViewConstructor]\n\n/// A slice which stores the prosemirror node views.\nexport const nodeViewCtx = createSlice([] as NodeView[], 'nodeView')\n\ntype MarkView = [nodeId: string, view: MarkViewConstructor]\n\n/// A slice which stores the prosemirror mark views.\nexport const markViewCtx = createSlice([] as MarkView[], 'markView')\n\n/// A slice which stores the remark instance.\nexport const remarkCtx: SliceType<RemarkParser, 'remark'> = createSlice(unified().use(remarkParse).use(remarkStringify), 'remark')\n\n/// A slice which stores the remark stringify options.\nexport const remarkStringifyOptionsCtx = createSlice({\n  handlers: remarkHandlers,\n} as Options, 'remarkStringifyOptions')\n\n/// The init plugin.\n/// This plugin prepare slices that needed by other plugins. And create a remark instance.\n///\n/// This plugin will wait for the config plugin.\nexport const init = (editor: Editor): MilkdownPlugin => {\n  const plugin: MilkdownPlugin = (ctx) => {\n    ctx.inject(editorCtx, editor)\n      .inject(prosePluginsCtx, [])\n      .inject(remarkPluginsCtx, [])\n      .inject(inputRulesCtx, [])\n      .inject(nodeViewCtx, [])\n      .inject(markViewCtx, [])\n      .inject(remarkStringifyOptionsCtx, {\n        handlers: remarkHandlers,\n      })\n      .inject(remarkCtx, unified().use(remarkParse).use(remarkStringify))\n      .inject(initTimerCtx, [ConfigReady])\n      .record(InitReady)\n\n    return async () => {\n      await ctx.waitTimers(initTimerCtx)\n      const options = ctx.get(remarkStringifyOptionsCtx)\n      ctx.set(remarkCtx, unified().use(remarkParse).use(remarkStringify, options))\n\n      ctx.done(InitReady)\n\n      return () => {\n        ctx.remove(editorCtx)\n          .remove(prosePluginsCtx)\n          .remove(remarkPluginsCtx)\n          .remove(inputRulesCtx)\n          .remove(nodeViewCtx)\n          .remove(markViewCtx)\n          .remove(remarkStringifyOptionsCtx)\n          .remove(remarkCtx)\n          .remove(initTimerCtx)\n          .clearTimer(InitReady)\n      }\n    }\n  }\n  withMeta(plugin, {\n    displayName: 'Init',\n  })\n\n  return plugin\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { Schema } from '@milkdown/prose/model'\nimport type {\n  MarkSchema, NodeSchema, RemarkParser,\n} from '@milkdown/transformer'\n\nimport { withMeta } from '../__internal__'\nimport { InitReady, remarkCtx, remarkPluginsCtx } from '.'\n\n/// The timer which will be resolved when the schema plugin is ready.\nexport const SchemaReady = createTimer('SchemaReady')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[InitReady]`.\nexport const schemaTimerCtx = createSlice([] as TimerType[], 'schemaTimer')\n\n/// A slice which contains the schema.\nexport const schemaCtx = createSlice({} as Schema, 'schema')\n\n/// A slice which stores the nodes spec.\nexport const nodesCtx = createSlice([] as Array<[string, NodeSchema]>, 'nodes')\n\n/// A slice which stores the marks spec.\nexport const marksCtx = createSlice([] as Array<[string, MarkSchema]>, 'marks')\n\nconst extendPriority = <T extends NodeSchema | MarkSchema>(x: T): T => {\n  return {\n    ...x,\n    parseDOM: x.parseDOM?.map(rule => ({ priority: x.priority, ...rule })),\n  }\n}\n\n/// The schema plugin.\n/// This plugin will load all nodes spec and marks spec and create a schema.\n///\n/// This plugin will wait for the init plugin.\nexport const schema: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(schemaCtx, {} as Schema)\n    .inject(nodesCtx, [])\n    .inject(marksCtx, [])\n    .inject(schemaTimerCtx, [InitReady])\n    .record(SchemaReady)\n\n  return async () => {\n    await ctx.waitTimers(schemaTimerCtx)\n\n    const remark = ctx.get(remarkCtx)\n    const remarkPlugins = ctx.get(remarkPluginsCtx)\n\n    const processor = remarkPlugins.reduce((acc: RemarkParser, plug) => acc.use(plug), remark)\n    ctx.set(remarkCtx, processor)\n\n    const nodes = Object.fromEntries(ctx.get(nodesCtx).map(([key, x]) => [key, extendPriority(x)]))\n    const marks = Object.fromEntries(ctx.get(marksCtx).map(([key, x]) => [key, extendPriority(x)]))\n\n    ctx.set(\n      schemaCtx,\n      new Schema({\n        nodes,\n        marks,\n      }),\n    )\n\n    ctx.done(SchemaReady)\n\n    return () => {\n      ctx.remove(schemaCtx).remove(nodesCtx).remove(marksCtx).remove(schemaTimerCtx).clearTimer(SchemaReady)\n    }\n  }\n}\n\nwithMeta(schema, {\n  displayName: 'Schema',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { ctxCallOutOfScope } from '@milkdown/exception'\nimport type { Parser } from '@milkdown/transformer'\nimport { ParserState } from '@milkdown/transformer'\n\nimport { withMeta } from '../__internal__'\nimport { remarkCtx } from './init'\nimport { SchemaReady, schemaCtx } from './schema'\n\n/// The timer which will be resolved when the parser plugin is ready.\nexport const ParserReady = createTimer('ParserReady')\n\nconst outOfScope = (() => {\n  throw ctxCallOutOfScope()\n}) as Parser\n\n/// A slice which contains the parser.\nexport const parserCtx = createSlice(outOfScope, 'parser')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[SchemaReady]`.\nexport const parserTimerCtx = createSlice([] as TimerType[], 'parserTimer')\n\n/// The parser plugin.\n/// This plugin will create a parser.\n///\n/// This plugin will wait for the schema plugin.\nexport const parser: MilkdownPlugin = (ctx) => {\n  ctx.inject(parserCtx, outOfScope).inject(parserTimerCtx, [SchemaReady]).record(ParserReady)\n\n  return async () => {\n    await ctx.waitTimers(parserTimerCtx)\n    const remark = ctx.get(remarkCtx)\n    const schema = ctx.get(schemaCtx)\n\n    ctx.set(parserCtx, ParserState.create(schema, remark))\n    ctx.done(ParserReady)\n    return () => {\n      ctx.remove(parserCtx).remove(parserTimerCtx).clearTimer(ParserReady)\n    }\n  }\n}\n\nwithMeta(parser, {\n  displayName: 'Parser',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport type { Serializer } from '@milkdown/transformer'\nimport { SerializerState } from '@milkdown/transformer'\n\nimport { ctxCallOutOfScope } from '@milkdown/exception'\nimport { withMeta } from '../__internal__'\nimport { remarkCtx } from './init'\nimport { SchemaReady, schemaCtx } from './schema'\n\n/// The timer which will be resolved when the serializer plugin is ready.\nexport const SerializerReady = createTimer('SerializerReady')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[SchemaReady]`.\nexport const serializerTimerCtx = createSlice([] as TimerType[], 'serializerTimer')\n\nconst outOfScope = (() => {\n  throw ctxCallOutOfScope()\n}) as Serializer\n\n/// A slice which contains the serializer.\nexport const serializerCtx = createSlice<Serializer, 'serializer'>(outOfScope, 'serializer')\n\n/// The serializer plugin.\n/// This plugin will create a serializer.\n///\n/// This plugin will wait for the schema plugin.\nexport const serializer: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(serializerCtx, outOfScope)\n    .inject(serializerTimerCtx, [SchemaReady])\n    .record(SerializerReady)\n\n  return async () => {\n    await ctx.waitTimers(serializerTimerCtx)\n    const remark = ctx.get(remarkCtx)\n    const schema = ctx.get(schemaCtx)\n\n    ctx.set(serializerCtx, SerializerState.create(schema, remark))\n    ctx.done(SerializerReady)\n\n    return () => {\n      ctx.remove(serializerCtx).remove(serializerTimerCtx).clearTimer(SerializerReady)\n    }\n  }\n}\n\nwithMeta(serializer, {\n  displayName: 'Serializer',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { docTypeError } from '@milkdown/exception'\nimport { customInputRules as createInputRules } from '@milkdown/prose'\nimport { baseKeymap } from '@milkdown/prose/commands'\nimport { keymap as createKeymap } from '@milkdown/prose/keymap'\nimport type { Schema } from '@milkdown/prose/model'\nimport { DOMParser, Node } from '@milkdown/prose/model'\nimport { EditorState, Plugin, PluginKey } from '@milkdown/prose/state'\nimport type { JSONRecord, Parser } from '@milkdown/transformer'\n\nimport { withMeta } from '../__internal__'\nimport { inputRulesCtx, prosePluginsCtx } from './init'\nimport { ParserReady, parserCtx } from './parser'\nimport { schemaCtx } from './schema'\nimport { SerializerReady } from './serializer'\nimport { CommandsReady } from '.'\n\n/// @internal\nexport type DefaultValue = string | { type: 'html'; dom: HTMLElement } | { type: 'json'; value: JSONRecord }\ntype StateOptions = Parameters<typeof EditorState.create>[0]\ntype StateOptionsOverride = (prev: StateOptions) => StateOptions\n\n/// A slice which contains the default value of the editor.\n/// Can be markdown string, html string or json.\nexport const defaultValueCtx = createSlice('' as DefaultValue, 'defaultValue')\n\n/// A slice which contains the editor state.\nexport const editorStateCtx = createSlice({} as EditorState, 'editorState')\n\n/// A slice which contains the options which is used to create the editor state.\nexport const editorStateOptionsCtx = createSlice<StateOptionsOverride>(x => x, 'stateOptions')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[ParserReady, SerializerReady, CommandsReady]`.\nexport const editorStateTimerCtx = createSlice([] as TimerType[], 'editorStateTimer')\n\n/// The timer which will be resolved when the editor state plugin is ready.\nexport const EditorStateReady = createTimer('EditorStateReady')\n\n/// @internal\nexport const getDoc = (defaultValue: DefaultValue, parser: Parser, schema: Schema) => {\n  if (typeof defaultValue === 'string')\n    return parser(defaultValue)\n\n  if (defaultValue.type === 'html')\n    return DOMParser.fromSchema(schema).parse(defaultValue.dom)\n\n  if (defaultValue.type === 'json')\n    return Node.fromJSON(schema, defaultValue.value)\n\n  throw docTypeError(defaultValue)\n}\n\nconst key = new PluginKey('MILKDOWN_STATE_TRACKER')\n\n/// The editor state plugin.\n/// This plugin will create a prosemirror editor state.\n///\n/// This plugin will wait for the parser plugin, serializer plugin and commands plugin.\nexport const editorState: MilkdownPlugin = (ctx) => {\n  ctx.inject(defaultValueCtx, '')\n    .inject(editorStateCtx, {} as EditorState)\n    .inject(editorStateOptionsCtx, x => x)\n    .inject(editorStateTimerCtx, [ParserReady, SerializerReady, CommandsReady])\n    .record(EditorStateReady)\n\n  return async () => {\n    await ctx.waitTimers(editorStateTimerCtx)\n\n    const schema = ctx.get(schemaCtx)\n    const parser = ctx.get(parserCtx)\n    const rules = ctx.get(inputRulesCtx)\n    const optionsOverride = ctx.get(editorStateOptionsCtx)\n    const prosePlugins = ctx.get(prosePluginsCtx)\n    const defaultValue = ctx.get(defaultValueCtx)\n    const doc = getDoc(defaultValue, parser, schema)\n\n    const plugins = [\n      ...prosePlugins,\n      new Plugin({\n        key,\n        state: {\n          init: () => {\n            // do nothing\n          },\n          apply: (_tr, _value, _oldState, newState) => {\n            ctx.set(editorStateCtx, newState)\n          },\n        },\n      }),\n      createInputRules({ rules }),\n      createKeymap(baseKeymap),\n    ]\n\n    ctx.set(prosePluginsCtx, plugins)\n\n    const options = optionsOverride({\n      schema,\n      doc,\n      plugins,\n    })\n\n    const state = EditorState.create(options)\n    ctx.set(editorStateCtx, state)\n    ctx.done(EditorStateReady)\n\n    return () => {\n      ctx.remove(defaultValueCtx)\n        .remove(editorStateCtx)\n        .remove(editorStateOptionsCtx)\n        .remove(editorStateTimerCtx)\n        .clearTimer(EditorStateReady)\n    }\n  }\n}\n\nwithMeta(editorState, {\n  displayName: 'EditorState',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx, MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport type { DirectEditorProps } from '@milkdown/prose/view'\nimport { EditorView } from '@milkdown/prose/view'\n\nimport { withMeta } from '../__internal__'\nimport { EditorStateReady, editorStateCtx } from './editor-state'\nimport { InitReady, markViewCtx, nodeViewCtx, prosePluginsCtx } from './init'\n\ntype EditorOptions = Omit<DirectEditorProps, 'state'>\n\ntype RootType = Node | undefined | null | string\n\n/// The timer which will be resolved when the editor view plugin is ready.\nexport const EditorViewReady = createTimer('EditorViewReady')\n\n/// A slice which contains the editor view instance.\nexport const editorViewCtx = createSlice({} as EditorView, 'editorView')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[EditorStateReady]`.\nexport const editorViewTimerCtx = createSlice([] as TimerType[], 'editorViewTimer')\n\n/// A slice which contains the editor view options which will be passed to the editor view.\nexport const editorViewOptionsCtx = createSlice({} as Partial<EditorOptions>, 'editorViewOptions')\n\n/// A slice which contains the value to get the root element.\n/// Can be a selector string, a node or null.\n/// If it's null, the editor will be created in the body.\nexport const rootCtx = createSlice(null as RootType, 'root')\n\n/// A slice which contains the actually root element.\nexport const rootDOMCtx = createSlice(null as unknown as HTMLElement, 'rootDOM')\n\n/// A slice which contains the root element attributes.\n/// You can add attributes to the root element by this slice.\nexport const rootAttrsCtx = createSlice({} as Record<string, string>, 'rootAttrs')\n\nconst createViewContainer = (root: Node, ctx: Ctx) => {\n  const container = document.createElement('div')\n  container.className = 'milkdown'\n  root.appendChild(container)\n  ctx.set(rootDOMCtx, container)\n\n  const attrs = ctx.get(rootAttrsCtx)\n  Object.entries(attrs).forEach(([key, value]) => container.setAttribute(key, value))\n\n  return container\n}\n\nconst prepareViewDom = (dom: Element) => {\n  dom.classList.add('editor')\n  dom.setAttribute('role', 'textbox')\n}\n\nconst key = new PluginKey('MILKDOWN_VIEW_CLEAR')\n\n/// The editor view plugin.\n/// This plugin will create an editor view.\n///\n/// This plugin will wait for the editor state plugin.\nexport const editorView: MilkdownPlugin = (ctx) => {\n  ctx.inject(rootCtx, document.body)\n    .inject(editorViewCtx, {} as EditorView)\n    .inject(editorViewOptionsCtx, {})\n    .inject(rootDOMCtx, null as unknown as HTMLElement)\n    .inject(rootAttrsCtx, {})\n    .inject(editorViewTimerCtx, [EditorStateReady])\n    .record(EditorViewReady)\n\n  return async () => {\n    await ctx.wait(InitReady)\n\n    const root = ctx.get(rootCtx) || document.body\n    const el = typeof root === 'string' ? document.querySelector(root) : root\n\n    ctx.update(prosePluginsCtx, xs => [\n      new Plugin({\n        key,\n        view: (editorView) => {\n          const container = el ? createViewContainer(el, ctx) : undefined\n\n          const handleDOM = () => {\n            if (container && el) {\n              const editor = editorView.dom\n              el.replaceChild(container, editor)\n              container.appendChild(editor)\n            }\n          }\n          handleDOM()\n          return {\n            destroy: () => {\n              if (container?.parentNode)\n                container?.parentNode.replaceChild(editorView.dom, container)\n\n              container?.remove()\n            },\n          }\n        },\n      }),\n      ...xs,\n    ])\n\n    await ctx.waitTimers(editorViewTimerCtx)\n\n    const state = ctx.get(editorStateCtx)\n    const options = ctx.get(editorViewOptionsCtx)\n    const nodeViews = Object.fromEntries(ctx.get(nodeViewCtx))\n    const markViews = Object.fromEntries(ctx.get(markViewCtx))\n    const view = new EditorView(el as Node, {\n      state,\n      nodeViews,\n      markViews,\n      ...options,\n    })\n    prepareViewDom(view.dom)\n    ctx.set(editorViewCtx, view)\n    ctx.done(EditorViewReady)\n\n    return () => {\n      view?.destroy()\n      ctx.remove(rootCtx)\n        .remove(editorViewCtx)\n        .remove(editorViewOptionsCtx)\n        .remove(rootDOMCtx)\n        .remove(rootAttrsCtx)\n        .remove(editorViewTimerCtx)\n        .clearTimer(EditorViewReady)\n    }\n  }\n}\n\nwithMeta(editorView, {\n  displayName: 'EditorView',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx, MilkdownPlugin, SliceType } from '@milkdown/ctx'\nimport { Container, createSlice, createTimer } from '@milkdown/ctx'\nimport { callCommandBeforeEditorView } from '@milkdown/exception'\nimport type { Command } from '@milkdown/prose/state'\n\nimport { withMeta } from '../__internal__'\nimport { editorViewCtx } from './editor-view'\nimport { SchemaReady } from './schema'\n\n/// @internal\nexport type Cmd<T = undefined> = (payload?: T) => Command\n\n/// @internal\nexport type CmdKey<T = undefined> = SliceType<Cmd<T>>\n\ntype InferParams<T> = T extends CmdKey<infer U> ? U : never\n\n/// The command manager.\n/// This manager will manage all commands in editor.\n/// Generally, you don't need to use this manager directly.\n/// You can use the `$command` and `$commandAsync` in `@milkdown/utils` to create and call a command.\nexport class CommandManager {\n  /// @internal\n  #container = new Container()\n\n  /// @internal\n  #ctx: Ctx | null = null\n\n  /// @internal\n  setCtx = (ctx: Ctx) => {\n    this.#ctx = ctx\n  }\n\n  /// Register a command into the manager.\n  create<T>(meta: CmdKey<T>, value: Cmd<T>) {\n    const slice = meta.create(this.#container.sliceMap)\n    slice.set(value)\n    return slice\n  }\n\n  /// Get a command from the manager.\n  get<T extends CmdKey<any>>(slice: string): Cmd<InferParams<T>>\n  get<T>(slice: CmdKey<T>): Cmd<T>\n  get(slice: string | CmdKey<any>): Cmd<any>\n  get(slice: string | CmdKey<any>): Cmd<any> {\n    return this.#container.get(slice).get()\n  }\n\n  /// Remove a command from the manager.\n  remove<T extends CmdKey<any>>(slice: string): void\n  remove<T>(slice: CmdKey<T>): void\n  remove(slice: string | CmdKey<any>): void\n  remove(slice: string | CmdKey<any>): void {\n    return this.#container.remove(slice)\n  }\n\n  /// Call a registered command.\n  call<T extends CmdKey<any>>(slice: string, payload?: InferParams<T>): boolean\n  call<T>(slice: CmdKey<T>, payload?: T): boolean\n  call(slice: string | CmdKey<any>, payload?: any): boolean\n  call(slice: string | CmdKey<any>, payload?: any): boolean {\n    if (this.#ctx == null)\n      throw callCommandBeforeEditorView()\n\n    const cmd = this.get(slice)\n    const command = cmd(payload)\n    const view = this.#ctx.get(editorViewCtx)\n    return command(view.state, view.dispatch, view)\n  }\n}\n\n/// @internal\nexport type CmdTuple<T = unknown> = [key: CmdKey<T>, value: Cmd<T>]\n\n/// Create a command instance.\nexport const createCmd = <T>(key: CmdKey<T>, value: Cmd<T>): CmdTuple => [key, value] as CmdTuple\n\n/// Create a command key, which is a slice type that contains a command.\nexport const createCmdKey = <T = undefined>(key = 'cmdKey'): CmdKey<T> =>\n  createSlice((() => () => false) as Cmd<T>, key)\n\n/// A slice which contains the command manager.\nexport const commandsCtx = createSlice(new CommandManager(), 'commands')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[SchemaReady]`.\nexport const commandsTimerCtx = createSlice([SchemaReady], 'commandsTimer')\n\n/// The timer which will be resolved when the commands plugin is ready.\nexport const CommandsReady = createTimer('CommandsReady')\n\n/// The commands plugin.\n/// This plugin will create a command manager.\n///\n/// This plugin will wait for the schema plugin.\nexport const commands: MilkdownPlugin = (ctx) => {\n  ctx.inject(commandsCtx, new CommandManager()).inject(commandsTimerCtx, [SchemaReady]).record(CommandsReady)\n  ctx.get(commandsCtx).setCtx(ctx)\n  return async () => {\n    await ctx.waitTimers(commandsTimerCtx)\n\n    ctx.done(CommandsReady)\n\n    return () => {\n      ctx.remove(commandsCtx).remove(commandsTimerCtx).clearTimer(CommandsReady)\n    }\n  }\n}\n\nwithMeta(commands, {\n  displayName: 'Commands',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { CtxRunner, MilkdownPlugin, Telemetry } from '@milkdown/ctx'\nimport { Clock, Container, Ctx } from '@milkdown/ctx'\n\nimport type { Config } from '../internal-plugin'\nimport {\n  commands,\n  config,\n  editorState,\n  editorView,\n  init,\n  parser,\n  schema,\n  serializer,\n} from '../internal-plugin'\n\n/// The status of the editor.\nexport enum EditorStatus {\n  /// The editor is not initialized.\n  Idle = 'Idle',\n  /// The editor is creating.\n  OnCreate = 'OnCreate',\n  /// The editor has been created and ready to use.\n  Created = 'Created',\n  /// The editor is destroying.\n  OnDestroy = 'OnDestroy',\n  /// The editor has been destroyed.\n  Destroyed = 'Destroyed',\n}\n\n/// Type for the callback called when editor status changed.\nexport type OnStatusChange = (status: EditorStatus) => void\n\ntype EditorPluginStore = Map<\n  MilkdownPlugin,\n  {\n    ctx: Ctx | undefined\n    handler: CtxRunner | undefined\n    cleanup: ReturnType<CtxRunner>\n  }\n>\n\n/// The milkdown editor class.\nexport class Editor {\n  /// Create a new editor instance.\n  static make() {\n    return new Editor()\n  }\n\n  /// @internal\n  #enableInspector = false\n  /// @internal\n  #status = EditorStatus.Idle\n  /// @internal\n  #configureList: Config[] = []\n  /// @internal\n  #onStatusChange: OnStatusChange = () => undefined\n\n  /// @internal\n  readonly #container = new Container()\n  /// @internal\n  readonly #clock = new Clock()\n\n  /// @internal\n  readonly #usrPluginStore: EditorPluginStore = new Map()\n\n  /// @internal\n  readonly #sysPluginStore: EditorPluginStore = new Map()\n\n  /// @internal\n  readonly #ctx = new Ctx(this.#container, this.#clock)\n\n  /// @internal\n  readonly #loadInternal = () => {\n    const configPlugin = config(async (ctx) => {\n      await Promise.all(this.#configureList.map(fn => fn(ctx)))\n    })\n    const internalPlugins = [\n      schema,\n      parser,\n      serializer,\n      commands,\n      editorState,\n      editorView,\n      init(this),\n      configPlugin,\n    ]\n    this.#prepare(internalPlugins, this.#sysPluginStore)\n  }\n\n  /// @internal\n  readonly #prepare = (plugins: MilkdownPlugin[], store: EditorPluginStore) => {\n    plugins.forEach((plugin) => {\n      const ctx = this.#ctx.produce(this.#enableInspector ? plugin.meta : undefined)\n      const handler = plugin(ctx)\n      store.set(plugin, { ctx, handler, cleanup: undefined })\n    })\n  }\n\n  /// @internal\n  readonly #cleanup = (plugins: MilkdownPlugin[], remove = false) => {\n    return Promise.all(\n      [plugins].flat().map((plugin) => {\n        const loader = this.#usrPluginStore.get(plugin)\n        const cleanup = loader?.cleanup\n        if (remove)\n          this.#usrPluginStore.delete(plugin)\n        else\n          this.#usrPluginStore.set(plugin, { ctx: undefined, handler: undefined, cleanup: undefined })\n\n        if (typeof cleanup === 'function')\n          return cleanup()\n\n        return cleanup\n      }),\n    )\n  }\n\n  /// @internal\n  readonly #cleanupInternal = async () => {\n    await Promise.all([...this.#sysPluginStore.entries()].map(([_, { cleanup }]) => {\n      if (typeof cleanup === 'function')\n        return cleanup()\n\n      return cleanup\n    }))\n    this.#sysPluginStore.clear()\n  }\n\n  /// @internal\n  readonly #setStatus = (status: EditorStatus) => {\n    this.#status = status\n    this.#onStatusChange(status)\n  }\n\n  /// @internal\n  readonly #loadPluginInStore = (store: EditorPluginStore) => {\n    return [...store.entries()].map(async ([key, loader]) => {\n      const { ctx, handler } = loader\n      if (!handler)\n        return\n\n      const cleanup = await handler()\n\n      store.set(key, { ctx, handler, cleanup })\n    })\n  }\n\n  /// Get the ctx of the editor.\n  get ctx() {\n    return this.#ctx\n  }\n\n  /// Get the status of the editor.\n  get status() {\n    return this.#status\n  }\n\n  /// Enable the inspector for the editor.\n  /// You can also pass `false` to disable the inspector.\n  readonly enableInspector = (enable = true) => {\n    this.#enableInspector = enable\n\n    return this\n  }\n\n  /// Subscribe to the status change event for the editor.\n  /// The new subscription will replace the old one.\n  readonly onStatusChange = (onChange: OnStatusChange) => {\n    this.#onStatusChange = onChange\n    return this\n  }\n\n  /// Add a config for the editor.\n  readonly config = (configure: Config) => {\n    this.#configureList.push(configure)\n    return this\n  }\n\n  /// Remove a config for the editor.\n  readonly removeConfig = (configure: Config) => {\n    this.#configureList = this.#configureList.filter(x => x !== configure)\n    return this\n  }\n\n  /// Use a plugin or a list of plugins for the editor.\n  readonly use = (plugins: MilkdownPlugin | MilkdownPlugin[]) => {\n    const _plugins = [plugins].flat()\n    _plugins.flat().forEach((plugin) => {\n      this.#usrPluginStore.set(plugin, {\n        ctx: undefined,\n        handler: undefined,\n        cleanup: undefined,\n      })\n    })\n\n    if (this.#status === EditorStatus.Created)\n      this.#prepare(_plugins, this.#usrPluginStore)\n\n    return this\n  }\n\n  /// Remove a plugin or a list of plugins from the editor.\n  readonly remove = async (plugins: MilkdownPlugin | MilkdownPlugin[]): Promise<Editor> => {\n    if (this.#status === EditorStatus.OnCreate) {\n      console.warn('[Milkdown]: You are trying to remove plugins when the editor is creating, this is not recommended, please check your code.')\n      return new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(this.remove(plugins))\n        }, 50)\n      })\n    }\n\n    await this.#cleanup([plugins].flat(), true)\n    return this\n  }\n\n  /// Create the editor with current config and plugins.\n  /// If the editor is already created, it will be recreated.\n  readonly create = async (): Promise<Editor> => {\n    if (this.#status === EditorStatus.OnCreate)\n      return this\n\n    if (this.#status === EditorStatus.Created)\n      await this.destroy()\n\n    this.#setStatus(EditorStatus.OnCreate)\n\n    this.#loadInternal()\n    this.#prepare([...this.#usrPluginStore.keys()], this.#usrPluginStore)\n\n    await Promise.all(\n      [\n        this.#loadPluginInStore(this.#sysPluginStore),\n        this.#loadPluginInStore(this.#usrPluginStore),\n      ].flat(),\n    )\n\n    this.#setStatus(EditorStatus.Created)\n    return this\n  }\n\n  /// Destroy the editor.\n  /// If you want to clear all plugins, set `clearPlugins` to `true`.\n  readonly destroy = async (clearPlugins = false): Promise<Editor> => {\n    if (this.#status === EditorStatus.Destroyed || this.#status === EditorStatus.OnDestroy)\n      return this\n\n    if (this.#status === EditorStatus.OnCreate) {\n      return new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(this.destroy(clearPlugins))\n        }, 50)\n      })\n    }\n\n    if (clearPlugins)\n      this.#configureList = []\n\n    this.#setStatus(EditorStatus.OnDestroy)\n    await this.#cleanup([...this.#usrPluginStore.keys()], clearPlugins)\n    await this.#cleanupInternal()\n\n    this.#setStatus(EditorStatus.Destroyed)\n    return this\n  }\n\n  /// Call an action with the ctx of the editor.\n  /// This method should be used after the editor is created.\n  readonly action = <T>(action: (ctx: Ctx) => T) => action(this.#ctx)\n\n  /// Get inspections of plugins in editor.\n  /// Make sure you have enabled inspector by `editor.enableInspector()` before calling this method.\n  readonly inspect = (): Telemetry[] => {\n    if (!this.#enableInspector) {\n      console.warn('[Milkdown]: You are trying to collect inspection when inspector is disabled, please enable inspector by `editor.enableInspector()` first.')\n      return []\n    }\n    return [...this.#sysPluginStore.values(), ...this.#usrPluginStore.values()]\n      .map(({ ctx }) => ctx?.inspector?.read())\n      .filter((x): x is Telemetry => Boolean(x))\n  }\n}\n"],"names":["withMeta","plugin","meta","remarkHandlers","node","_","state","info","marker","exit","tracker","value","ConfigReady","createTimer","config","configure","ctx","InitReady","initTimerCtx","createSlice","editorCtx","inputRulesCtx","prosePluginsCtx","remarkPluginsCtx","nodeViewCtx","markViewCtx","remarkCtx","unified","remarkParse","remarkStringify","remarkStringifyOptionsCtx","init","editor","options","SchemaReady","schemaTimerCtx","schemaCtx","nodesCtx","marksCtx","extendPriority","x","_a","rule","schema","remark","processor","acc","plug","nodes","key","marks","Schema","ParserReady","outOfScope","ctxCallOutOfScope","parserCtx","parserTimerCtx","parser","ParserState","SerializerReady","serializerTimerCtx","serializerCtx","serializer","SerializerState","defaultValueCtx","editorStateCtx","editorStateOptionsCtx","editorStateTimerCtx","EditorStateReady","getDoc","defaultValue","DOMParser","Node","docTypeError","PluginKey","editorState","CommandsReady","rules","optionsOverride","prosePlugins","doc","plugins","Plugin","_tr","_value","_oldState","newState","createInputRules","createKeymap","baseKeymap","EditorState","EditorViewReady","editorViewCtx","editorViewTimerCtx","editorViewOptionsCtx","rootCtx","rootDOMCtx","rootAttrsCtx","createViewContainer","root","container","attrs","prepareViewDom","dom","editorView","el","xs","nodeViews","markViews","view","EditorView","CommandManager","__privateAdd","_container","_ctx","__privateSet","Container","slice","__privateGet","payload","callCommandBeforeEditorView","command","createCmd","createCmdKey","commandsCtx","commandsTimerCtx","commands","EditorStatus","_Editor","_enableInspector","_status","_configureList","_onStatusChange","_clock","_usrPluginStore","_sysPluginStore","_loadInternal","_prepare","_cleanup","_cleanupInternal","_setStatus","_loadPluginInStore","Clock","Ctx","configPlugin","fn","internalPlugins","store","handler","remove","loader","cleanup","status","enable","onChange","_plugins","resolve","clearPlugins","action","Editor"],"mappings":"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"}