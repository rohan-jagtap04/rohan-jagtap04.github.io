var ke = (e, t, r) => {
  if (!t.has(e))
    throw TypeError("Cannot " + r);
};
var s = (e, t, r) => (ke(e, t, "read from private field"), r ? r.call(e) : t.get(e)), h = (e, t, r) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, r);
}, c = (e, t, r, i) => (ke(e, t, "write to private field"), i ? i.call(e, r) : t.set(e, r), r);
import { createTimer as g, createSlice as o, Container as Se, Clock as Be, Ctx as Ye } from "@milkdown/ctx";
import { Schema as $e, DOMParser as qe, Node as He } from "@milkdown/prose/model";
import he from "remark-parse";
import le from "remark-stringify";
import { unified as ue } from "unified";
import { ctxCallOutOfScope as Pe, docTypeError as Je, callCommandBeforeEditorView as Fe } from "@milkdown/exception";
import { ParserState as Ge, SerializerState as Qe } from "@milkdown/transformer";
import { PluginKey as Re, Plugin as be, EditorState as Ue } from "@milkdown/prose/state";
import { EditorView as Xe } from "@milkdown/prose/view";
import { customInputRules as Ze } from "@milkdown/prose";
import { baseKeymap as xe } from "@milkdown/prose/commands";
import { keymap as et } from "@milkdown/prose/keymap";
const C = (e, t) => (e.meta = {
  package: "@milkdown/core",
  group: "System",
  ...t
}, e), De = {
  strong: (e, t, r, i) => {
    const n = e.marker || r.options.strong || "*", a = r.enter("strong"), d = r.createTracker(i);
    let m = d.move(n + n);
    return m += d.move(
      r.containerPhrasing(e, {
        before: m,
        after: n,
        ...d.current()
      })
    ), m += d.move(n + n), a(), m;
  },
  emphasis: (e, t, r, i) => {
    const n = e.marker || r.options.emphasis || "*", a = r.enter("emphasis"), d = r.createTracker(i);
    let m = d.move(n);
    return m += d.move(
      r.containerPhrasing(e, {
        before: m,
        after: n,
        ...d.current()
      })
    ), m += d.move(n), a(), m;
  }
}, W = g("ConfigReady"), tt = (e) => {
  const t = (r) => (r.record(W), async () => (await e(r), r.done(W), () => {
    r.clearTimer(W);
  }));
  return C(t, {
    displayName: "Config"
  }), t;
}, I = g("InitReady"), G = o([], "initTimer"), Te = o({}, "editor"), pe = o([], "inputRules"), M = o([], "prosePlugins"), ye = o([], "remarkPlugins"), we = o([], "nodeView"), fe = o([], "markView"), S = o(ue().use(he).use(le), "remark"), Q = o({
  handlers: De
}, "remarkStringifyOptions"), rt = (e) => {
  const t = (r) => (r.inject(Te, e).inject(M, []).inject(ye, []).inject(pe, []).inject(we, []).inject(fe, []).inject(Q, {
    handlers: De
  }).inject(S, ue().use(he).use(le)).inject(G, [W]).record(I), async () => {
    await r.waitTimers(G);
    const i = r.get(Q);
    return r.set(S, ue().use(he).use(le, i)), r.done(I), () => {
      r.remove(Te).remove(M).remove(ye).remove(pe).remove(we).remove(fe).remove(Q).remove(S).remove(G).clearTimer(I);
    };
  });
  return C(t, {
    displayName: "Init"
  }), t;
}, P = g("SchemaReady"), U = o([], "schemaTimer"), R = o({}, "schema"), X = o([], "nodes"), Z = o([], "marks"), Oe = (e) => {
  var t;
  return {
    ...e,
    parseDOM: (t = e.parseDOM) == null ? void 0 : t.map((r) => ({ priority: e.priority, ...r }))
  };
}, Ee = (e) => (e.inject(R, {}).inject(X, []).inject(Z, []).inject(U, [I]).record(P), async () => {
  await e.waitTimers(U);
  const t = e.get(S), i = e.get(ye).reduce((d, m) => d.use(m), t);
  e.set(S, i);
  const n = Object.fromEntries(e.get(X).map(([d, m]) => [d, Oe(m)])), a = Object.fromEntries(e.get(Z).map(([d, m]) => [d, Oe(m)]));
  return e.set(
    R,
    new $e({
      nodes: n,
      marks: a
    })
  ), e.done(P), () => {
    e.remove(R).remove(X).remove(Z).remove(U).clearTimer(P);
  };
});
C(Ee, {
  displayName: "Schema"
});
const B = g("ParserReady"), Ve = () => {
  throw Pe();
}, Y = o(Ve, "parser"), x = o([], "parserTimer"), Ie = (e) => (e.inject(Y, Ve).inject(x, [P]).record(B), async () => {
  await e.waitTimers(x);
  const t = e.get(S), r = e.get(R);
  return e.set(Y, Ge.create(r, t)), e.done(B), () => {
    e.remove(Y).remove(x).clearTimer(B);
  };
});
C(Ie, {
  displayName: "Parser"
});
const $ = g("SerializerReady"), ee = o([], "serializerTimer"), Me = () => {
  throw Pe();
}, te = o(Me, "serializer"), Ne = (e) => (e.inject(te, Me).inject(ee, [P]).record($), async () => {
  await e.waitTimers(ee);
  const t = e.get(S), r = e.get(R);
  return e.set(te, Qe.create(r, t)), e.done($), () => {
    e.remove(te).remove(ee).clearTimer($);
  };
});
C(Ne, {
  displayName: "Serializer"
});
const re = o("", "defaultValue"), V = o({}, "editorState"), se = o((e) => e, "stateOptions"), ie = o([], "editorStateTimer"), q = g("EditorStateReady"), st = (e, t, r) => {
  if (typeof e == "string")
    return t(e);
  if (e.type === "html")
    return qe.fromSchema(r).parse(e.dom);
  if (e.type === "json")
    return He.fromJSON(r, e.value);
  throw Je(e);
}, it = new Re("MILKDOWN_STATE_TRACKER"), _e = (e) => (e.inject(re, "").inject(V, {}).inject(se, (t) => t).inject(ie, [B, $, J]).record(q), async () => {
  await e.waitTimers(ie);
  const t = e.get(R), r = e.get(Y), i = e.get(pe), n = e.get(se), a = e.get(M), d = e.get(re), m = st(d, r, t), K = [
    ...a,
    new be({
      key: it,
      state: {
        init: () => {
        },
        apply: (Le, F, mt, We) => {
          e.set(V, We);
        }
      }
    }),
    Ze({ rules: i }),
    et(xe)
  ];
  e.set(M, K);
  const L = n({
    schema: t,
    doc: m,
    plugins: K
  }), l = Ue.create(L);
  return e.set(V, l), e.done(q), () => {
    e.remove(re).remove(V).remove(se).remove(ie).clearTimer(q);
  };
});
C(_e, {
  displayName: "EditorState"
});
const ne = g("EditorViewReady"), H = o({}, "editorView"), oe = o([], "editorViewTimer"), ae = o({}, "editorViewOptions"), ce = o(null, "root"), ge = o(null, "rootDOM"), Ce = o({}, "rootAttrs"), nt = (e, t) => {
  const r = document.createElement("div");
  r.className = "milkdown", e.appendChild(r), t.set(ge, r);
  const i = t.get(Ce);
  return Object.entries(i).forEach(([n, a]) => r.setAttribute(n, a)), r;
}, ot = (e) => {
  e.classList.add("editor"), e.setAttribute("role", "textbox");
}, at = new Re("MILKDOWN_VIEW_CLEAR"), ze = (e) => (e.inject(ce, document.body).inject(H, {}).inject(ae, {}).inject(ge, null).inject(Ce, {}).inject(oe, [q]).record(ne), async () => {
  await e.wait(I);
  const t = e.get(ce) || document.body, r = typeof t == "string" ? document.querySelector(t) : t;
  e.update(M, (K) => [
    new be({
      key: at,
      view: (L) => {
        const l = r ? nt(r, e) : void 0;
        return (() => {
          if (l && r) {
            const F = L.dom;
            r.replaceChild(l, F), l.appendChild(F);
          }
        })(), {
          destroy: () => {
            l != null && l.parentNode && (l == null || l.parentNode.replaceChild(L.dom, l)), l == null || l.remove();
          }
        };
      }
    }),
    ...K
  ]), await e.waitTimers(oe);
  const i = e.get(V), n = e.get(ae), a = Object.fromEntries(e.get(we)), d = Object.fromEntries(e.get(fe)), m = new Xe(r, {
    state: i,
    nodeViews: a,
    markViews: d,
    ...n
  });
  return ot(m.dom), e.set(H, m), e.done(ne), () => {
    m == null || m.destroy(), e.remove(ce).remove(H).remove(ae).remove(ge).remove(Ce).remove(oe).clearTimer(ne);
  };
});
C(ze, {
  displayName: "EditorView"
});
var v, k;
class Ae {
  constructor() {
    h(this, v, void 0);
    h(this, k, void 0);
    c(this, v, new Se()), c(this, k, null), this.setCtx = (t) => {
      c(this, k, t);
    };
  }
  /// Register a command into the manager.
  create(t, r) {
    const i = t.create(s(this, v).sliceMap);
    return i.set(r), i;
  }
  get(t) {
    return s(this, v).get(t).get();
  }
  remove(t) {
    return s(this, v).remove(t);
  }
  call(t, r) {
    if (s(this, k) == null)
      throw Fe();
    const n = this.get(t)(r), a = s(this, k).get(H);
    return n(a.state, a.dispatch, a);
  }
}
v = new WeakMap(), k = new WeakMap();
const Ot = (e, t) => [e, t], jt = (e = "cmdKey") => o(() => () => !1, e), me = o(new Ae(), "commands"), de = o([P], "commandsTimer"), J = g("CommandsReady"), Ke = (e) => (e.inject(me, new Ae()).inject(de, [P]).record(J), e.get(me).setCtx(e), async () => (await e.waitTimers(de), e.done(J), () => {
  e.remove(me).remove(de).clearTimer(J);
}));
C(Ke, {
  displayName: "Commands"
});
var ct = /* @__PURE__ */ ((e) => (e.Idle = "Idle", e.OnCreate = "OnCreate", e.Created = "Created", e.OnDestroy = "OnDestroy", e.Destroyed = "Destroyed", e))(ct || {}), T, p, y, b, N, _, u, w, O, z, j, D, A, f, E;
const ve = class {
  constructor() {
    h(this, T, void 0);
    h(this, p, void 0);
    h(this, y, void 0);
    h(this, b, void 0);
    h(this, N, void 0);
    h(this, _, void 0);
    h(this, u, void 0);
    h(this, w, void 0);
    h(this, O, void 0);
    h(this, z, void 0);
    h(this, j, void 0);
    h(this, D, void 0);
    h(this, A, void 0);
    h(this, f, void 0);
    h(this, E, void 0);
    c(this, T, !1), c(this, p, "Idle"), c(this, y, []), c(this, b, () => {
    }), c(this, N, new Se()), c(this, _, new Be()), c(this, u, /* @__PURE__ */ new Map()), c(this, w, /* @__PURE__ */ new Map()), c(this, O, new Ye(s(this, N), s(this, _))), c(this, z, () => {
      const t = tt(async (i) => {
        await Promise.all(s(this, y).map((n) => n(i)));
      }), r = [
        Ee,
        Ie,
        Ne,
        Ke,
        _e,
        ze,
        rt(this),
        t
      ];
      s(this, j).call(this, r, s(this, w));
    }), c(this, j, (t, r) => {
      t.forEach((i) => {
        const n = s(this, O).produce(s(this, T) ? i.meta : void 0), a = i(n);
        r.set(i, { ctx: n, handler: a, cleanup: void 0 });
      });
    }), c(this, D, (t, r = !1) => Promise.all(
      [t].flat().map((i) => {
        const n = s(this, u).get(i), a = n == null ? void 0 : n.cleanup;
        return r ? s(this, u).delete(i) : s(this, u).set(i, { ctx: void 0, handler: void 0, cleanup: void 0 }), typeof a == "function" ? a() : a;
      })
    )), c(this, A, async () => {
      await Promise.all([...s(this, w).entries()].map(([t, { cleanup: r }]) => typeof r == "function" ? r() : r)), s(this, w).clear();
    }), c(this, f, (t) => {
      c(this, p, t), s(this, b).call(this, t);
    }), c(this, E, (t) => [...t.entries()].map(async ([r, i]) => {
      const { ctx: n, handler: a } = i;
      if (!a)
        return;
      const d = await a();
      t.set(r, { ctx: n, handler: a, cleanup: d });
    })), this.enableInspector = (t = !0) => (c(this, T, t), this), this.onStatusChange = (t) => (c(this, b, t), this), this.config = (t) => (s(this, y).push(t), this), this.removeConfig = (t) => (c(this, y, s(this, y).filter((r) => r !== t)), this), this.use = (t) => {
      const r = [t].flat();
      return r.flat().forEach((i) => {
        s(this, u).set(i, {
          ctx: void 0,
          handler: void 0,
          cleanup: void 0
        });
      }), s(this, p) === "Created" && s(this, j).call(this, r, s(this, u)), this;
    }, this.remove = async (t) => s(this, p) === "OnCreate" ? (console.warn("[Milkdown]: You are trying to remove plugins when the editor is creating, this is not recommended, please check your code."), new Promise((r) => {
      setTimeout(() => {
        r(this.remove(t));
      }, 50);
    })) : (await s(this, D).call(this, [t].flat(), !0), this), this.create = async () => s(this, p) === "OnCreate" ? this : (s(this, p) === "Created" && await this.destroy(), s(this, f).call(this, "OnCreate"), s(this, z).call(this), s(this, j).call(this, [...s(this, u).keys()], s(this, u)), await Promise.all(
      [
        s(this, E).call(this, s(this, w)),
        s(this, E).call(this, s(this, u))
      ].flat()
    ), s(this, f).call(this, "Created"), this), this.destroy = async (t = !1) => s(this, p) === "Destroyed" || s(this, p) === "OnDestroy" ? this : s(this, p) === "OnCreate" ? new Promise((r) => {
      setTimeout(() => {
        r(this.destroy(t));
      }, 50);
    }) : (t && c(this, y, []), s(this, f).call(this, "OnDestroy"), await s(this, D).call(this, [...s(this, u).keys()], t), await s(this, A).call(this), s(this, f).call(this, "Destroyed"), this), this.action = (t) => t(s(this, O)), this.inspect = () => s(this, T) ? [...s(this, w).values(), ...s(this, u).values()].map(({ ctx: t }) => {
      var r;
      return (r = t == null ? void 0 : t.inspector) == null ? void 0 : r.read();
    }).filter((t) => !!t) : (console.warn("[Milkdown]: You are trying to collect inspection when inspector is disabled, please enable inspector by `editor.enableInspector()` first."), []);
  }
  /// Create a new editor instance.
  static make() {
    return new ve();
  }
  /// Get the ctx of the editor.
  get ctx() {
    return s(this, O);
  }
  /// Get the status of the editor.
  get status() {
    return s(this, p);
  }
};
let je = ve;
T = new WeakMap(), p = new WeakMap(), y = new WeakMap(), b = new WeakMap(), N = new WeakMap(), _ = new WeakMap(), u = new WeakMap(), w = new WeakMap(), O = new WeakMap(), z = new WeakMap(), j = new WeakMap(), D = new WeakMap(), A = new WeakMap(), f = new WeakMap(), E = new WeakMap();
export {
  Ae as CommandManager,
  J as CommandsReady,
  W as ConfigReady,
  je as Editor,
  q as EditorStateReady,
  ct as EditorStatus,
  ne as EditorViewReady,
  I as InitReady,
  B as ParserReady,
  P as SchemaReady,
  $ as SerializerReady,
  Ke as commands,
  me as commandsCtx,
  de as commandsTimerCtx,
  tt as config,
  Ot as createCmd,
  jt as createCmdKey,
  re as defaultValueCtx,
  Te as editorCtx,
  _e as editorState,
  V as editorStateCtx,
  se as editorStateOptionsCtx,
  ie as editorStateTimerCtx,
  ze as editorView,
  H as editorViewCtx,
  ae as editorViewOptionsCtx,
  oe as editorViewTimerCtx,
  st as getDoc,
  rt as init,
  G as initTimerCtx,
  pe as inputRulesCtx,
  fe as markViewCtx,
  Z as marksCtx,
  we as nodeViewCtx,
  X as nodesCtx,
  Ie as parser,
  Y as parserCtx,
  x as parserTimerCtx,
  M as prosePluginsCtx,
  S as remarkCtx,
  ye as remarkPluginsCtx,
  Q as remarkStringifyOptionsCtx,
  Ce as rootAttrsCtx,
  ce as rootCtx,
  ge as rootDOMCtx,
  Ee as schema,
  R as schemaCtx,
  U as schemaTimerCtx,
  Ne as serializer,
  te as serializerCtx,
  ee as serializerTimerCtx
};
//# sourceMappingURL=index.es.js.map
