import { createSlice as f } from "@milkdown/ctx";
import { InitReady as c, SerializerReady as m, serializerCtx as L, prosePluginsCtx as w, EditorViewReady as y } from "@milkdown/core";
import { PluginKey as b, Plugin as g } from "@milkdown/prose/state";
import k from "lodash.debounce";
class u {
  constructor() {
    this.beforeMountedListeners = [], this.mountedListeners = [], this.updatedListeners = [], this.markdownUpdatedListeners = [], this.blurListeners = [], this.focusListeners = [], this.destroyListeners = [], this.beforeMount = (t) => (this.beforeMountedListeners.push(t), this), this.mounted = (t) => (this.mountedListeners.push(t), this), this.updated = (t) => (this.updatedListeners.push(t), this);
  }
  /// A getter to get all [subscribers](#interface-subscribers). You should not use this method directly.
  get listeners() {
    return {
      beforeMount: this.beforeMountedListeners,
      mounted: this.mountedListeners,
      updated: this.updatedListeners,
      markdownUpdated: this.markdownUpdatedListeners,
      blur: this.blurListeners,
      focus: this.focusListeners,
      destroy: this.destroyListeners
    };
  }
  /// Subscribe to the markdownUpdated event.
  /// This event will be triggered after the editor state is updated and **the document is changed**.
  /// The second parameter is the current markdown and the third parameter is the previous markdown.
  markdownUpdated(t) {
    return this.markdownUpdatedListeners.push(t), this;
  }
  /// Subscribe to the blur event.
  /// This event will be triggered when the editor is blurred.
  blur(t) {
    return this.blurListeners.push(t), this;
  }
  /// Subscribe to the focus event.
  /// This event will be triggered when the editor is focused.
  focus(t) {
    return this.focusListeners.push(t), this;
  }
  /// Subscribe to the destroy event.
  /// This event will be triggered before the editor is destroyed.
  destroy(t) {
    return this.destroyListeners.push(t), this;
  }
}
const a = f(new u(), "listener"), E = new b("MILKDOWN_LISTENER"), M = (e) => (e.inject(a, new u()), async () => {
  await e.wait(c);
  const t = e.get(a), { listeners: r } = t;
  r.beforeMount.forEach((s) => s(e)), await e.wait(m);
  const h = e.get(L);
  let n = null, d = null;
  const l = new g({
    key: E,
    view: () => ({
      destroy: () => {
        r.destroy.forEach((s) => s(e));
      }
    }),
    props: {
      handleDOMEvents: {
        focus: () => (r.focus.forEach((s) => s(e)), !1),
        blur: () => (r.blur.forEach((s) => s(e)), !1)
      }
    },
    state: {
      init: () => {
      },
      apply: (s) => !s.docChanged || s.getMeta("addToHistory") === !1 ? void 0 : k(() => {
        const { doc: i } = s;
        if (r.updated.length > 0 && (n == null || !n.eq(i)) && r.updated.forEach((o) => {
          o(e, i, n);
        }), r.markdownUpdated.length > 0 && (n == null || !n.eq(i))) {
          const o = h(i);
          r.markdownUpdated.forEach((p) => {
            p(e, o, d);
          }), d = o;
        }
        n = i;
      }, 200)()
    }
  });
  e.update(w, (s) => s.concat(l)), await e.wait(y), r.mounted.forEach((s) => s(e));
});
M.meta = {
  package: "@milkdown/plugin-listener",
  displayName: "Listener"
};
export {
  u as ListenerManager,
  E as key,
  M as listener,
  a as listenerCtx
};
//# sourceMappingURL=index.es.js.map
